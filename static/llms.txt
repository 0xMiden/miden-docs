# User Provided Header
# Miden Documentation

> Miden is a zero-knowledge rollup for Ethereum that enables private, scalable smart contracts using STARK proofs.

## AI Integration

- Skills: https://docs.miden.xyz/skill.md
- Docs: https://docs.miden.xyz
- GitHub: https://github.com/0xMiden


# Directory Structure
```
docs/
  builder/
    develop/
      tutorials/
        rust-compiler/
          miden-bank/
            _category_.json
            00-project-setup.md
            01-account-components.md
            02-constants-constraints.md
            03-asset-management.md
            04-note-scripts.md
            05-cross-component-calls.md
            06-transaction-scripts.md
            07-output-notes.md
            08-complete-flows.md
            index.md
          _category_.json
          debugging.md
          index.md
          pitfalls.md
          testing.md
        _category_.json
      _category_.json
      index.md
    migration/
      _category_.json
      01-imports-dependencies.md
      02-account-changes.md
      03-note-changes.md
      04-transaction-changes.md
      05-client-changes.md
      06-masm-changes.md
      07-assembler-changes.md
      index.md
    quick-start/
      setup/
        _category_.json
        cli-basics.md
        installation.md
      your-first-smart-contract/
        _category_.json
        create.md
        deploy.md
        index.md
        test.md
      _category_.json
      accounts.md
      index.md
      notes.md
      read-storage.md
    tools/
      _category_.json
      index.md
    _category_.json
    faq.md
    glossary.md
    index.md
  design/
    _category_.json
    index.md
```

# Files

## File: docs/builder/develop/tutorials/rust-compiler/miden-bank/_category_.json
````json
{
  "label": "Miden Bank",
  "position": 1,
  "link": {
    "type": "doc",
    "id": "builder/develop/tutorials/rust-compiler/miden-bank/index"
  }
}
````

## File: docs/builder/develop/tutorials/rust-compiler/miden-bank/00-project-setup.md
````markdown
---
sidebar_position: 0
title: "Part 0: Project Setup"
description: "Set up a new Miden project and prepare the workspace for building the banking application."
---

# Part 0: Project Setup

In this section, you'll create a new Miden project and set up the workspace structure for our banking application. By the end, you'll have a working project that compiles successfully.

## What You'll Build in This Part

By the end of this section, you will have:

- Created a new Miden project using `miden new`
- Understood the workspace structure
- Renamed and configured the project for our bank
- Successfully compiled a minimal account component

## Prerequisites

Before starting, ensure you have completed the [Quick Start installation guide](../../../../quick-start/setup/installation) and have:

- **Rust toolchain** installed and configured
- **midenup toolchain** installed with Miden CLI tools (`miden` command available)

Verify your installation:

```bash title=">_ Terminal"
miden --version
```

<details>
<summary>Expected output</summary>

```text
miden-cli 0.8.x
```

</details>

## Step 1: Create the Project

Create a new Miden project using the CLI:

```bash title=">_ Terminal"
miden new miden-bank
cd miden-bank
```

This creates a workspace with the following structure:

```text
miden-bank/
├── contracts/                   # Smart contract code
│   ├── counter-account/         # Example account contract (we'll replace this)
│   └── increment-note/          # Example note script (we'll replace this)
├── integration/                 # Tests and deployment scripts
│   ├── src/
│   │   ├── bin/                 # Executable scripts for on-chain interactions
│   │   ├── lib.rs
│   │   └── helpers.rs           # Helper functions for tests
│   └── tests/                   # Test files
├── Cargo.toml                   # Workspace root
└── rust-toolchain.toml          # Rust toolchain specification
```

The project follows Miden's design philosophy:

- **`contracts/`**: Your smart contract code (account components, note scripts, transaction scripts)
- **`integration/`**: All on-chain interactions, deployment scripts, and tests

## Step 2: Set Up the Bank Account Contract

We'll replace the example `counter-account` with our `bank-account`. First, rename the directory:

```bash title=">_ Terminal"
mv contracts/counter-account contracts/bank-account
```

Now update the `Cargo.toml` inside `contracts/bank-account/`:

```toml title="contracts/bank-account/Cargo.toml"
[package]
name = "bank-account"
version = "0.1.0"
edition = "2021"

[lib]
crate-type = ["cdylib"]

[dependencies]
miden = { workspace = true }

[package.metadata.component]
package = "miden:bank-account"

[package.metadata.miden]
project-kind = "account"
supported-types = ["RegularAccountImmutableCode"]
```

### Key Configuration Options

| Field | Description |
|-------|-------------|
| `crate-type = ["cdylib"]` | Required for WebAssembly compilation |
| `project-kind = "account"` | Tells the compiler this is an account component |
| `supported-types` | Account types this component supports |
| `package = "miden:bank-account"` | The component package name for cross-component calls |

:::info Supported Account Types
`RegularAccountImmutableCode` means the account code cannot be changed after deployment. This is appropriate for our bank since we want the logic to be fixed.
:::

## Step 3: Create a Minimal Bank Component

Replace the contents of `contracts/bank-account/src/lib.rs` with a minimal bank structure:

```rust title="contracts/bank-account/src/lib.rs"
// Do not link against libstd (i.e. anything defined in `std::`)
#![no_std]
#![feature(alloc_error_handler)]

#[macro_use]
extern crate alloc;

use miden::*;

/// Bank account component - we'll build this up throughout the tutorial.
#[component]
struct Bank {
    /// Tracks whether the bank has been initialized (deposits enabled).
    /// Word layout: [is_initialized (0 or 1), 0, 0, 0]
    #[storage(slot(0), description = "initialized")]
    initialized: Value,

    /// Maps depositor AccountId -> balance (as Felt).
    /// We'll use this to track user balances in Part 1.
    #[storage(slot(1), description = "balances")]
    balances: StorageMap,
}

#[component]
impl Bank {
    /// Initialize the bank account, enabling deposits.
    pub fn initialize(&mut self) {
        // Read current value from storage
        let current: Word = self.initialized.read();

        // Check not already initialized
        assert!(
            current[0].as_u64() == 0,
            "Bank already initialized"
        );

        // Set initialized flag to 1
        let initialized_word = Word::from([felt!(1), felt!(0), felt!(0), felt!(0)]);
        self.initialized.write(initialized_word);
    }

    /// Get the balance for a depositor.
    ///
    /// This method is required for the component to compile correctly -
    /// account components must use WIT binding types (like AccountId)
    /// in at least one public method.
    pub fn get_balance(&self, depositor: AccountId) -> Felt {
        let key = Word::from([depositor.prefix, depositor.suffix, felt!(0), felt!(0)]);
        self.balances.get(&key)
    }
}
```

This is our starting point with two storage slots:
- `initialized`: A `Value` slot to track whether the bank is ready
- `balances`: A `StorageMap` to track user balances (we'll use this starting in Part 1)

:::note Compiler Requirement
Account components must use WIT binding types (like `AccountId`, `Asset`, etc.) in at least one public method signature for the compiler to generate the required bindings correctly. The `get_balance` method serves this purpose.
:::

## Step 4: Update the Workspace Configuration

Update the root `Cargo.toml` to reflect our renamed contract:

```toml title="Cargo.toml"
[workspace]
resolver = "2"

members = [
    "contracts/bank-account",
    "contracts/increment-note",  # We'll replace this later
    "integration",
]

[workspace.dependencies]
miden = { version = "0.8" }
```

## Step 5: Build and Verify

Let's verify everything compiles correctly:

```bash title=">_ Terminal"
cd contracts/bank-account
miden build --release
```

<details>
<summary>Expected output</summary>

```text
   Compiling bank-account v0.1.0 (/path/to/miden-bank/contracts/bank-account)
    Finished `release` profile [optimized] target(s)
Creating Miden package /path/to/miden-bank/target/miden/release/bank_account.masp
```

</details>

The compiled output is stored in `target/miden/release/bank_account.masp`.

:::tip What's a .masp File?
A `.masp` file is a Miden Assembly Package. It contains the compiled MASM (Miden Assembly) code and metadata needed to deploy and interact with your contract.
:::

## Try It: Verify Your Setup

Let's create a simple test to verify the bank account can be created. Create a new test file:

```rust title="integration/tests/part0_setup_test.rs"
use integration::helpers::{
    build_project_in_dir, create_testing_account_from_package, AccountCreationConfig,
};
use miden_client::account::{StorageMap, StorageSlot};
use miden_client::Word;
use std::{path::Path, sync::Arc};

#[tokio::test]
async fn test_bank_account_builds_and_loads() -> anyhow::Result<()> {
    // Build the bank account contract
    let bank_package = Arc::new(build_project_in_dir(
        Path::new("../contracts/bank-account"),
        true,
    )?);

    // Create the bank account with initial storage
    // Slot 0: initialized flag (Value, starts as [0, 0, 0, 0])
    // Slot 1: balances map (StorageMap, starts empty)
    let bank_cfg = AccountCreationConfig {
        storage_slots: vec![
            StorageSlot::Value(Word::default()),
            StorageSlot::Map(StorageMap::with_entries([])?),
        ],
        ..Default::default()
    };

    let bank_account =
        create_testing_account_from_package(bank_package.clone(), bank_cfg).await?;

    // Verify the account was created
    println!("Bank account created with ID: {:?}", bank_account.id());
    println!("Part 0 setup verified!");

    Ok(())
}
```

Run the test from the project root:

```bash title=">_ Terminal"
cargo test --package integration part0_setup_test -- --nocapture
```

<details>
<summary>Expected output</summary>

```text
   Compiling integration v0.1.0 (/path/to/miden-bank/integration)
    Finished `test` profile [unoptimized + debuginfo] target(s)
     Running tests/part0_setup_test.rs

running 1 test
Bank account created with ID: 0x...
Part 0 setup verified!
test test_bank_account_builds_and_loads ... ok

test result: ok. 1 passed; 0 failed; 0 ignored
```

</details>

:::tip Troubleshooting
**"Failed to build bank account contract"**: Make sure the `contracts/bank-account/Cargo.toml` is properly configured and you've updated the root `Cargo.toml` members list.

**"cannot find module helpers"**: Ensure the `integration/src/helpers.rs` file exists (it should have been generated by `miden new`).
:::

## What We've Built So Far

At this point, you have:

| Component | Status | Description |
|-----------|--------|-------------|
| `bank-account` | Minimal | Initialization flag + balance storage |
| `deposit-note` | Not started | Coming in Part 4 |
| `withdraw-note` | Not started | Coming in Part 7 |
| `init-tx-script` | Not started | Coming in Part 6 |

Your bank can be created, but doesn't do anything useful yet. In the next parts, we'll add:

1. **Part 1**: Deeper dive into storage (Value vs StorageMap)
2. **Part 2**: Business rules and constraints
3. **Part 3**: Asset handling for deposits
4. And more...

## Key Takeaways

1. **`miden new`** creates a complete project workspace with contracts and integration folders
2. **Account components** are defined with `#[component]` on a struct
3. **Storage slots** are declared with `#[storage(slot(N))]` attributes
4. **`miden build`** compiles Rust to Miden Assembly (.masp package)
5. **Tests verify** that your code works before moving on

## Next Steps

Now that your project is set up, let's dive deeper into account components and storage in [Part 1: Account Components and Storage](./01-account-components).
````

## File: docs/builder/develop/tutorials/rust-compiler/_category_.json
````json
{
  "label": "Rust Compiler",
  "position": 1,
  "link": {
    "type": "doc",
    "id": "builder/develop/tutorials/rust-compiler/index"
  }
}
````

## File: docs/builder/develop/tutorials/rust-compiler/testing.md
````markdown
---
sidebar_position: 1
title: "Testing with MockChain"
description: "Learn how to test Miden Rust compiler contracts using MockChain for simulating blockchain behavior locally."
---

# Testing with MockChain

MockChain provides a local simulation of the Miden blockchain for testing your contracts without connecting to a network. This guide covers testing patterns for account components, note scripts, and transaction scripts.

## Overview

MockChain simulates:
- Block production and proving
- Account state management
- Note creation and consumption
- Transaction execution

This enables fast, deterministic testing of your Miden contracts.

## Test Project Setup

Create an integration test crate alongside your contracts:

```text
your-project/
├── contracts/
│   ├── my-account/
│   └── my-note/
└── integration/
    ├── Cargo.toml
    ├── src/
    │   └── helpers.rs    # Test utilities
    └── tests/
        └── my_test.rs    # Test files
```

### Cargo.toml for Tests

```toml title="integration/Cargo.toml"
[package]
name = "integration"
version = "0.1.0"
edition = "2021"

[lib]
path = "src/helpers.rs"

[[test]]
name = "my_test"
path = "tests/my_test.rs"

[dependencies]
anyhow = "1.0"
tokio = { version = "1", features = ["rt-multi-thread", "macros"] }

# Miden dependencies
miden-testing = { version = "0.8" }
miden-client = { version = "0.8", features = ["testing"] }
miden-objects = { version = "0.8" }
miden-core = { version = "0.13" }
cargo-miden = { version = "0.1" }
miden-mast-package = { version = "0.1" }
```

## Building Contracts for Tests

Use `cargo-miden` to build your contracts programmatically:

```rust title="integration/src/helpers.rs"
use std::path::Path;
use anyhow::{bail, Context, Result};
use cargo_miden::{run, OutputType};
use miden_mast_package::Package;

pub fn build_project_in_dir(dir: &Path, release: bool) -> Result<Package> {
    let profile = if release { "--release" } else { "--debug" };
    let manifest_path = dir.join("Cargo.toml");
    let manifest_arg = manifest_path.to_string_lossy();

    let args = vec![
        "cargo", "miden", "build",
        profile,
        "--manifest-path", &manifest_arg,
    ];

    let output = run(args.into_iter().map(String::from), OutputType::Masm)
        .context("Failed to compile project")?
        .context("Cargo miden build returned None")?;

    let artifact_path = match output {
        cargo_miden::CommandOutput::BuildCommandOutput { output } => match output {
            cargo_miden::BuildOutput::Masm { artifact_path } => artifact_path,
            other => bail!("Expected Masm output, got {:?}", other),
        },
        other => bail!("Expected BuildCommandOutput, got {:?}", other),
    };

    let package_bytes = std::fs::read(&artifact_path)?;
    Package::read_from_bytes(&package_bytes)
        .context("Failed to deserialize package")
}
```

## MockChain Basics

### Creating a MockChain

Use the builder pattern to set up your test environment:

```rust
use miden_testing::{Auth, MockChain};

#[tokio::test]
async fn my_test() -> anyhow::Result<()> {
    // Create builder
    let mut builder = MockChain::builder();

    // Add accounts, faucets, notes...

    // Build the chain
    let mut mock_chain = builder.build()?;

    Ok(())
}
```

### Adding a Faucet

Faucets mint assets for testing:

```rust
// Create a faucet with 1,000,000 total supply, decimals = 10
let faucet = builder.add_existing_basic_faucet(
    Auth::BasicAuth,
    "TEST",           // Token symbol
    1_000_000,        // Total supply
    Some(10),         // Decimals
)?;
```

### Adding Wallet Accounts

Create accounts with initial assets:

```rust
use miden_objects::asset::FungibleAsset;

// Create a wallet with 100 tokens from the faucet
let sender = builder.add_existing_wallet_with_assets(
    Auth::BasicAuth,
    [FungibleAsset::new(faucet.id(), 100)?.into()],
)?;
```

## Creating Custom Accounts

For accounts with custom components, create configuration helpers:

```rust title="integration/src/helpers.rs"
use miden_client::account::{AccountStorageMode, AccountType, StorageSlot};

#[derive(Clone)]
pub struct AccountCreationConfig {
    pub account_type: AccountType,
    pub storage_mode: AccountStorageMode,
    pub storage_slots: Vec<StorageSlot>,
}

impl Default for AccountCreationConfig {
    fn default() -> Self {
        Self {
            account_type: AccountType::RegularAccountImmutableCode,
            storage_mode: AccountStorageMode::Public,
            storage_slots: vec![],
        }
    }
}
```

### Creating Account from Package

```rust
use miden_client::account::StorageMap;
use std::sync::Arc;

// Build the contract
let bank_package = Arc::new(build_project_in_dir(
    Path::new("../contracts/bank-account"),
    true,  // release mode
)?);

// Configure storage slots
let config = AccountCreationConfig {
    storage_slots: vec![
        // Slot 0: Value storage (initialized flag)
        StorageSlot::Value(Word::default()),
        // Slot 1: Map storage (balances)
        StorageSlot::Map(StorageMap::with_entries([])?),
    ],
    ..Default::default()
};

// Create the account
let mut account = create_testing_account_from_package(
    bank_package.clone(),
    config,
).await?;

// Add to MockChain
builder.add_account(account.clone())?;
```

## Creating Notes

### Note Configuration

```rust title="integration/src/helpers.rs"
use miden_client::note::{NoteAssets, NoteExecutionHint, NoteTag, NoteType};
use miden_core::Felt;

pub struct NoteCreationConfig {
    pub note_type: NoteType,
    pub tag: NoteTag,
    pub assets: NoteAssets,
    pub inputs: Vec<Felt>,
    pub execution_hint: NoteExecutionHint,
    pub aux: Felt,
}

impl Default for NoteCreationConfig {
    fn default() -> Self {
        Self {
            note_type: NoteType::Public,
            tag: NoteTag::for_local_use_case(0, 0).unwrap(),
            assets: Default::default(),
            inputs: Default::default(),
            execution_hint: NoteExecutionHint::always(),
            aux: Felt::ZERO,
        }
    }
}
```

### Creating Notes with Assets

```rust
use miden_objects::asset::{Asset, FungibleAsset};
use miden_client::note::NoteAssets;

// Build note script
let deposit_note_package = Arc::new(build_project_in_dir(
    Path::new("../contracts/deposit-note"),
    true,
)?);

// Create assets to attach
let deposit_amount: u64 = 1000;
let fungible_asset = FungibleAsset::new(faucet.id(), deposit_amount)?;
let note_assets = NoteAssets::new(vec![Asset::Fungible(fungible_asset)])?;

// Create the note
let deposit_note = create_testing_note_from_package(
    deposit_note_package.clone(),
    sender.id(),  // Note sender
    NoteCreationConfig {
        assets: note_assets,
        ..Default::default()
    },
)?;

// Add to MockChain
builder.add_output_note(OutputNote::Full(deposit_note.clone().into()));
```

### Creating Notes with Inputs

For notes that read parameters via `active_note::get_inputs()`:

```rust
use miden_core::Felt;

// Note inputs are a vector of Felts
let inputs = vec![
    // Asset data [0-3]
    Felt::new(withdraw_amount),
    Felt::new(0),
    faucet.id().suffix(),
    faucet.id().prefix().as_felt(),
    // Serial number [4-7]
    Felt::new(0x1234567890abcdef),
    Felt::new(0xfedcba0987654321),
    Felt::new(0xdeadbeefcafebabe),
    Felt::new(0x0123456789abcdef),
    // Additional parameters
    Felt::new(tag as u64),
    Felt::new(0),  // aux
    Felt::new(1),  // note_type (1 = Public)
];

let note = create_testing_note_from_package(
    note_package.clone(),
    sender.id(),
    NoteCreationConfig {
        inputs,
        ..Default::default()
    },
)?;
```

## Executing Transactions

### Basic Transaction Execution

```rust
// Build MockChain after adding all accounts and notes
let mut mock_chain = builder.build()?;

// Build transaction context
// Args: (account_id, input_note_ids, expected_output_note_ids)
let tx_context = mock_chain
    .build_tx_context(account.id(), &[note.id()], &[])?
    .build()?;

// Execute
let executed_tx = tx_context.execute().await?;

// Apply state changes to local account copy
account.apply_delta(&executed_tx.account_delta())?;

// Add to pending transactions and prove block
mock_chain.add_pending_executed_transaction(&executed_tx)?;
mock_chain.prove_next_block()?;
```

### Transaction with Script

For transaction scripts (like initialization):

```rust
use miden_objects::transaction::TransactionScript;

// Build the transaction script
let init_package = Arc::new(build_project_in_dir(
    Path::new("../contracts/init-tx-script"),
    true,
)?);

let init_program = init_package.unwrap_program();
let init_tx_script = TransactionScript::new((*init_program).clone());

// Execute with script
let tx_context = mock_chain
    .build_tx_context(account.id(), &[], &[])?
    .tx_script(init_tx_script)
    .build()?;

let executed_tx = tx_context.execute().await?;
```

### Transactions with Expected Output Notes

When your contract creates output notes, specify them:

```rust
use miden_client::transaction::OutputNote;

// Build the expected output note
let expected_note = Note::new(
    output_assets,
    output_metadata,
    recipient,
);

let tx_context = mock_chain
    .build_tx_context(account.id(), &[input_note.id()], &[])?
    .extend_expected_output_notes(vec![OutputNote::Full(expected_note.into())])
    .build()?;
```

## Verifying State Changes

### Reading Storage After Transaction

```rust
// After executing and applying delta...

// Read Value storage (slot 0)
let value: Word = account.storage().get_item(0)?;

// Read Map storage (slot 1)
let key = Word::from([
    depositor.prefix().as_felt(),
    depositor.suffix(),
    faucet.id().prefix().as_felt(),
    faucet.id().suffix(),
]);
let balance = account.storage().get_map_item(1, key)?;

// Assert expected values
assert_eq!(
    balance,
    Word::from([Felt::new(0), Felt::new(0), Felt::new(0), Felt::new(1000)]),
    "Balance should match deposited amount"
);
```

## Testing Error Conditions

### Expecting Transaction Failure

```rust
#[tokio::test]
async fn should_fail_without_initialization() -> anyhow::Result<()> {
    // Setup WITHOUT initialization step...

    let tx_context = mock_chain
        .build_tx_context(account.id(), &[note.id()], &[])?
        .build()?;

    // Execute and expect failure
    let result = tx_context.execute().await;

    assert!(
        result.is_err(),
        "Expected transaction to fail, but it succeeded"
    );

    // Optionally check error message
    if let Err(e) = result {
        println!("Expected error: {}", e);
    }

    Ok(())
}
```

### Testing Constraint Violations

```rust
#[tokio::test]
async fn deposit_exceeds_max_should_fail() -> anyhow::Result<()> {
    // Create deposit with amount > MAX_DEPOSIT_AMOUNT
    let large_amount: u64 = 2_000_000;  // Max is 1,000,000

    // ... setup code ...

    let result = tx_context.execute().await;

    assert!(
        result.is_err(),
        "Expected deposit to fail due to max limit"
    );

    Ok(())
}
```

## Complete Test Example

```rust title="integration/tests/deposit_test.rs"
use integration::helpers::{
    build_project_in_dir, create_testing_account_from_package,
    create_testing_note_from_package, AccountCreationConfig, NoteCreationConfig,
};
use miden_client::{account::StorageMap, note::NoteAssets, transaction::OutputNote, Felt, Word};
use miden_objects::{asset::{Asset, FungibleAsset}, transaction::TransactionScript};
use miden_testing::{Auth, MockChain};
use std::{path::Path, sync::Arc};

#[tokio::test]
async fn deposit_test() -> anyhow::Result<()> {
    // 1. Setup MockChain builder
    let mut builder = MockChain::builder();

    // 2. Create faucet and sender
    let faucet = builder.add_existing_basic_faucet(Auth::BasicAuth, "TEST", 1000, Some(10))?;
    let sender = builder.add_existing_wallet_with_assets(
        Auth::BasicAuth,
        [FungibleAsset::new(faucet.id(), 100)?.into()],
    )?;

    // 3. Build contracts
    let bank_package = Arc::new(build_project_in_dir(
        Path::new("../contracts/bank-account"), true
    )?);
    let deposit_note_package = Arc::new(build_project_in_dir(
        Path::new("../contracts/deposit-note"), true
    )?);
    let init_tx_script_package = Arc::new(build_project_in_dir(
        Path::new("../contracts/init-tx-script"), true
    )?);

    // 4. Create bank account with storage
    let bank_cfg = AccountCreationConfig {
        storage_slots: vec![
            miden_client::account::StorageSlot::Value(Word::default()),
            miden_client::account::StorageSlot::Map(StorageMap::with_entries([])?),
        ],
        ..Default::default()
    };
    let mut bank_account = create_testing_account_from_package(
        bank_package.clone(), bank_cfg
    ).await?;

    // 5. Create deposit note
    let deposit_amount: u64 = 1000;
    let fungible_asset = FungibleAsset::new(faucet.id(), deposit_amount)?;
    let note_assets = NoteAssets::new(vec![Asset::Fungible(fungible_asset)])?;
    let deposit_note = create_testing_note_from_package(
        deposit_note_package.clone(),
        sender.id(),
        NoteCreationConfig { assets: note_assets, ..Default::default() },
    )?;

    // 6. Add to builder and build chain
    builder.add_account(bank_account.clone())?;
    builder.add_output_note(OutputNote::Full(deposit_note.clone().into()));
    let mut mock_chain = builder.build()?;

    // 7. Initialize bank
    let init_program = init_tx_script_package.unwrap_program();
    let init_tx_script = TransactionScript::new((*init_program).clone());
    let init_tx_context = mock_chain
        .build_tx_context(bank_account.id(), &[], &[])?
        .tx_script(init_tx_script)
        .build()?;
    let executed_init = init_tx_context.execute().await?;
    bank_account.apply_delta(&executed_init.account_delta())?;
    mock_chain.add_pending_executed_transaction(&executed_init)?;
    mock_chain.prove_next_block()?;

    // 8. Execute deposit
    let tx_context = mock_chain
        .build_tx_context(bank_account.id(), &[deposit_note.id()], &[])?
        .build()?;
    let executed_tx = tx_context.execute().await?;
    bank_account.apply_delta(&executed_tx.account_delta())?;
    mock_chain.add_pending_executed_transaction(&executed_tx)?;
    mock_chain.prove_next_block()?;

    // 9. Verify balance
    let depositor_key = Word::from([
        sender.id().prefix().as_felt(),
        sender.id().suffix(),
        faucet.id().prefix().as_felt(),
        faucet.id().suffix(),
    ]);
    let balance = bank_account.storage().get_map_item(1, depositor_key)?;
    let expected = Word::from([
        Felt::new(0), Felt::new(0), Felt::new(0), Felt::new(deposit_amount)
    ]);
    assert_eq!(balance, expected, "Balance should match deposit");

    println!("Deposit test passed!");
    Ok(())
}
```

## Running Tests

```bash title=">_ Terminal"
# Run all tests
cargo test -p integration -- --nocapture

# Run specific test
cargo test -p integration deposit_test -- --nocapture

# Run with verbose output
RUST_LOG=debug cargo test -p integration -- --nocapture
```

## Key Takeaways

1. **MockChain Builder Pattern** - Use `MockChain::builder()` to set up test environments
2. **Build Contracts First** - Use `build_project_in_dir()` to compile contracts before tests
3. **Configure Storage Slots** - Match your contract's storage layout when creating accounts
4. **Apply Deltas** - Always call `apply_delta()` on local account copies after transactions
5. **Prove Blocks** - Call `prove_next_block()` after adding executed transactions
6. **Test Failures** - Use `result.is_err()` to verify constraint violations

:::tip View Complete Source
See the complete test implementations in the [miden-bank repository](https://github.com/keinberger/miden-bank/tree/main/integration/tests).
:::

## Next Steps

- **[Debugging Guide](./debugging)** - Troubleshoot common issues
- **[Common Pitfalls](./pitfalls)** - Avoid known gotchas
- **[Miden Bank Tutorial](./miden-bank/)** - See testing in action
````

## File: docs/builder/develop/tutorials/_category_.json
````json
{
  "label": "Tutorials",
  "position": 1
}
````

## File: docs/builder/develop/_category_.json
````json
{
  "label": "Develop on Miden",
  "position": 4
}
````

## File: docs/builder/migration/_category_.json
````json
{
  "label": "Migration",
  "position": 6,
  "link": {
    "type": "doc",
    "id": "builder/migration/index"
  }
}
````

## File: docs/builder/migration/01-imports-dependencies.md
````markdown
---
sidebar_position: 1
title: "Imports & Dependencies"
description: "Crate renames and dependency changes in v0.13"
---

# Imports & Dependencies

:::warning Breaking Change
The `miden-objects` and `miden-lib` crates have been renamed. All imports must be updated.
:::

## Quick Fix

```toml title="Cargo.toml"
# Remove these
miden-objects = "0.12"
miden-lib = "0.12"

# Add these
miden-protocol = "0.13"
miden-standards = "0.13"
```

---

## Crate Renames

Core types have moved from `miden-objects` and `miden-lib` to new packages.

| Old Package | New Package | Contains |
|-------------|-------------|----------|
| `miden-objects` | `miden-protocol` | Core protocol types |
| `miden-lib` | `miden-standards` | Standard library |

### Cargo.toml

```diff title="Cargo.toml"
# Before
- miden-objects = "0.12"
- miden-lib = "0.12"

# After
+ miden-protocol = "0.13"
+ miden-standards = "0.13"
```

### Rust Imports

```diff title="src/lib.rs"
# Before
- use miden_objects::{Account, Note, Transaction};
- use miden_lib::StdLibrary;

# After
+ use miden_protocol::{Account, Note, Transaction};
+ use miden_standards::CoreLibrary;
```

:::tip Helper Script
Use your IDE's find-and-replace to update all imports at once:
- Find: `miden_objects` → Replace: `miden_protocol`
- Find: `miden_lib` → Replace: `miden_standards`
:::

---

## Miden VM and Crypto Updates

Update Miden VM to 0.20 and `miden-crypto` to 0.19:

```toml title="Cargo.toml"
miden-vm = "0.20"
miden-crypto = "0.19"
```

---

## Core Library Rename

The standard library has been renamed from `StdLibrary` to `CoreLibrary`.

### Rust

```diff title="src/lib.rs"
- use miden_lib::StdLibrary;
- let stdlib = StdLibrary::default();

+ use miden_standards::CoreLibrary;
+ let corelib = CoreLibrary::default();
```

### MASM Imports

```diff title="src/contract.masm"
# Before
- use.std::crypto::hashes

# After
+ use.miden::core::crypto::hashes
```

---

## Migration Steps

1. Update `Cargo.toml` with new package names and versions
2. Run `cargo update` to fetch new packages
3. Find and replace old import paths throughout your codebase
4. Rename `StdLibrary` to `CoreLibrary`
5. Update MASM imports from `std::` to `miden::core::`
6. Compile and fix any remaining import errors

---

## Common Errors

| Error | Cause | Fix |
|-------|-------|-----|
| `unresolved import 'miden_objects'` | Old package name | Change to `miden_protocol` |
| `cannot find 'StdLibrary' in 'miden_lib'` | Renamed to CoreLibrary | Use `miden_standards::CoreLibrary` |
| `unresolved import 'std::crypto'` | MASM namespace change | Use `miden::core::crypto` |
````

## File: docs/builder/migration/02-account-changes.md
````markdown
---
sidebar_position: 2
title: "Account Changes"
description: "Named storage slots, keystore, components, and procedure root changes"
---

# Account Changes

:::warning Breaking Change
Storage is now name-based, not index-based. All storage access code must be updated.
:::

## Quick Fix

Replace numeric indices with `StorageSlotName`:

```rust title="src/account.rs"
// Before
let value = account.storage().get_slot(0)?;

// After
let slot_name = StorageSlotName::new("my_slot")?;
let value = account.storage().get_slot(&slot_name)?;
```

---

## Named Storage Slots

Replace index-based storage access with `StorageSlotName` identifiers.

### Rust

```diff title="src/account.rs"
- // Before: access by numeric index
- let value = account.storage().get_slot(0)?;
- account.storage_mut().set_slot(0, new_value)?;

+ // After: access by name
+ let slot_name = StorageSlotName::new("my_slot")?;
+ let value = account.storage().get_slot(&slot_name)?;
+ account.storage_mut().set_slot(&slot_name, new_value)?;
```

### MASM Updates

The `set_map_item` procedure now takes slot IDs and returns only old values:

```diff title="src/contract.masm"
- # Before
- exec.account::set_map_item
- # Returns: [OLD_MAP_ROOT, OLD_VALUE, ...]

+ # After
+ exec.account::set_map_item
+ # Returns: [OLD_VALUE, ...]
```

:::info Good to know
The return value change means you may need to update stack manipulation after calling `set_map_item`.
:::

---

## Keystore Changes

Remove RNG generics from `FilesystemKeyStore`:

```diff title="src/client.rs"
- use miden_client::keystore::FilesystemKeyStore;
- let keystore = FilesystemKeyStore::<rand::rngs::StdRng>::new(path)?;

+ use miden_client::keystore::FilesystemKeyStore;
+ let keystore = FilesystemKeyStore::new(path)?;
```

---

## Web Component Compilation

Web component compilation now requires `AccountComponentCode` from `CodeBuilder`:

```diff title="src/component.rs"
- // Before
- let component = AccountComponent::compile(source)?;

+ // After
+ use miden_protocol::code::CodeBuilder;
+ let code = CodeBuilder::new()
+     .with_source(source)
+     .build()?;
+ let component = AccountComponent::new(code)?;
```

---

## Storage Schemas

Replace `AccountComponentTemplate` with metadata-driven `StorageSchema`:

```diff title="src/schema.rs"
- use miden_lib::AccountComponentTemplate;
- let template = AccountComponentTemplate::new(slots)?;

+ use miden_standards::StorageSchema;
+ let schema = StorageSchema::builder()
+     .add_slot("balance", StorageSlotType::Value)
+     .add_slot("metadata", StorageSlotType::Map)
+     .build()?;
```

---

## Procedure Roots

Use `AccountProcedureRoot` instead of `AccountProcedureInfo`:

```diff title="src/procedure.rs"
- use miden_objects::accounts::AccountProcedureInfo;
- let info = AccountProcedureInfo::new(digest, storage_offset)?;

+ use miden_protocol::accounts::AccountProcedureRoot;
+ let root = AccountProcedureRoot::new(digest)?;
```

---

## Migration Steps

1. Identify all storage slot access patterns in your code
2. Define `StorageSlotName` constants for each slot
3. Update storage access to use names instead of indices
4. Remove RNG type parameters from keystore initialization
5. Update component compilation to use `CodeBuilder`
6. Migrate storage templates to `StorageSchema`
7. Replace `AccountProcedureInfo` with `AccountProcedureRoot`

---

## Common Errors

| Error | Cause | Fix |
|-------|-------|-----|
| `no method named 'get_slot' taking u32` | API changed to names | Use `StorageSlotName` |
| `FilesystemKeyStore expects 0 type parameters` | RNG generic removed | Remove type parameter |
| `AccountComponentTemplate not found` | Renamed | Use `StorageSchema` |
````

## File: docs/builder/migration/03-note-changes.md
````markdown
---
sidebar_position: 3
title: "Note Changes"
description: "Note attachments, tags, network accounts, and input notes API changes"
---

# Note Changes

:::warning Breaking Change
The note system has been redesigned. `NoteMetadata` no longer stores `aux` or `NoteExecutionHint` — use `NoteAttachment` instead.
:::

## Quick Fix

```rust title="src/note.rs"
// Before
let metadata = NoteMetadata::new(sender, note_type, tag, aux, execution_hint)?;

// After
let metadata = NoteMetadata::new(sender, note_type, tag)?;
let attachment = NoteAttachment::new(aux_data, execution_hint)?;
let note = Note::new(metadata, script, inputs, attachment)?;
```

---

## Note Attachments

`NoteMetadata` no longer stores `aux` or `NoteExecutionHint`. Use `NoteAttachment` instead.

```diff title="src/note.rs"
- // Before: aux and hints in metadata
- let metadata = NoteMetadata::new(
-     sender,
-     note_type,
-     tag,
-     aux,                    // No longer here
-     execution_hint,         // No longer here
- )?;

+ // After: use attachments
+ let metadata = NoteMetadata::new(sender, note_type, tag)?;
+ let attachment = NoteAttachment::new(aux_data, execution_hint)?;
+ let note = Note::new(metadata, script, inputs, attachment)?;
```

:::info Good to know
This separation makes note metadata more lightweight and allows attachments to be optional.
:::

---

## Tag Semantics

`NoteTag` is now a plain `u32`. Use `with_account_target()` for account targeting:

```diff title="src/note.rs"
- // Before: tag with embedded target
- let tag = NoteTag::from_account_id(target_account)?;

+ // After: plain tag with explicit targeting
+ let tag: u32 = 12345;
+ let note = note.with_account_target(target_account)?;
```

---

## Network Account Target

Implement `NetworkAccountTarget` attachment for network-account notes:

```rust title="src/network_note.rs"
use miden_protocol::notes::NetworkAccountTarget;

let target = NetworkAccountTarget::new(account_id, network_id)?;
let note = note.with_attachment(target)?;
```

---

## MINT Notes

New `MintNoteInputs` enum supports private and public output notes:

```diff title="src/mint.rs"
- // Before
- let mint_note = MintNote::new(amount, recipient)?;

+ // After: explicit private/public choice
+ use miden_standards::notes::MintNoteInputs;
+
+ // For private notes
+ let inputs = MintNoteInputs::Private { amount, recipient };
+
+ // For public notes
+ let inputs = MintNoteInputs::Public { amount, recipient, metadata };
```

:::tip
Choose `MintNoteInputs::Private` for most use cases. Use `Public` only when the note contents should be visible on-chain.
:::

---

## Input Notes API

Unified interface accepts full `Note` objects instead of IDs:

```diff title="src/transaction.rs"
- // Before: separate authenticated/unauthenticated lists
- let tx = TransactionRequest::new()
-     .with_authenticated_input_notes(auth_note_ids)
-     .with_unauthenticated_input_notes(unauth_note_ids)?;

+ // After: unified input notes
+ let tx = TransactionRequest::new()
+     .with_input_notes(notes)?;  // Full Note objects
```

---

## FetchedNote Structure

Private notes now carry `NoteHeader`; public notes expose `note` and `inclusionProof`:

```rust title="src/fetch.rs"
match fetched_note {
    FetchedNote::Private { header, .. } => {
        // Access header fields
        let note_id = header.id();
    }
    FetchedNote::Public { note, inclusion_proof } => {
        // Access full note and proof
        let inputs = note.inputs();
    }
}
```

---

## Migration Steps

1. Remove `aux` and `execution_hint` from `NoteMetadata` constructors
2. Create `NoteAttachment` objects for aux data and hints
3. Update `NoteTag` usage to plain `u32` values
4. Use `with_account_target()` for targeted notes
5. Implement `NetworkAccountTarget` for network notes
6. Update mint note creation to use `MintNoteInputs` enum
7. Refactor input notes to pass full `Note` objects
8. Update `FetchedNote` handling for new structure

---

## Common Errors

| Error | Cause | Fix |
|-------|-------|-----|
| `NoteMetadata::new takes 3 arguments` | aux/hint removed | Use `NoteAttachment` |
| `NoteTag::from_account_id not found` | API changed | Use `with_account_target()` |
| `with_authenticated_input_notes not found` | API unified | Use `with_input_notes()` |
````

## File: docs/builder/migration/04-transaction-changes.md
````markdown
---
sidebar_position: 4
title: "Transaction Changes"
description: "Transaction event and data extraction changes"
---

# Transaction Changes

:::warning Breaking Change
`TransactionEvent` was renamed to `TransactionEventId`, and event data extraction is now handled separately.
:::

## Quick Fix

```rust title="src/events.rs"
// Before
use miden_protocol::TransactionEvent;

// After
use miden_protocol::TransactionEventId;
use miden_protocol::TransactionEventData;
```

---

## TransactionEvent Renamed

`TransactionEvent` was renamed to `TransactionEventId`, and event data extraction is now handled separately.

```diff title="src/events.rs"
- use miden_protocol::TransactionEvent;
-
- fn handle_event(event: TransactionEvent) {
-     let data = event.data();
-     let event_type = event.event_type();
- }

+ use miden_protocol::TransactionEventId;
+ use miden_protocol::TransactionEventData;
+
+ fn handle_event(event_id: TransactionEventId, data: TransactionEventData) {
+     // Event ID and data are now separate
+     let event_type = event_id.event_type();
+     let payload = data.payload();
+ }
```

---

## Event Processing

Event processing now uses separate ID and data objects:

```diff title="src/processor.rs"
- // Before: combined event object
- for event in transaction.events() {
-     match event {
-         TransactionEvent::NoteCreated(data) => { ... }
-         TransactionEvent::AccountUpdated(data) => { ... }
-     }
- }

+ // After: ID-based matching with separate data
+ for (event_id, event_data) in transaction.events() {
+     match event_id {
+         TransactionEventId::NoteCreated => {
+             let note_data = event_data.as_note_created()?;
+         }
+         TransactionEventId::AccountUpdated => {
+             let account_data = event_data.as_account_updated()?;
+         }
+     }
+ }
```

:::info Good to know
The separation of event ID and data allows for more efficient event filtering without deserializing data.
:::

---

## Migration Steps

1. Replace all `TransactionEvent` imports with `TransactionEventId`
2. Add `TransactionEventData` imports where needed
3. Update event handling to use separate ID and data objects
4. Use typed accessor methods on `TransactionEventData`

---

## Common Errors

| Error | Cause | Fix |
|-------|-------|-----|
| `TransactionEvent not found` | Renamed | Use `TransactionEventId` |
| `event.data() not found` | Data separated | Use `TransactionEventData` |
````

## File: docs/builder/migration/05-client-changes.md
````markdown
---
sidebar_position: 5
title: "Client Changes"
description: "Rust RPC, WebClient, and CLI changes"
---

# Client Changes

This section covers client API updates for both Rust and Web clients.

:::info Good to know
These changes affect both Rust SDK users and JavaScript/TypeScript WebClient users. Check which sections apply to your stack.
:::

---

## Rust RPC Changes

:::warning Breaking Change
The batch `get_account_proofs` method has been removed. Use individual `get_account` calls instead.
:::

```diff title="src/rpc.rs"
- // Before: batch account proofs
- let proofs = client.get_account_proofs(&account_ids).await?;

+ // After: individual account calls
+ let mut accounts = Vec::new();
+ for account_id in &account_ids {
+     let account = client.get_account(account_id).await?;
+     accounts.push(account);
+ }
```

:::tip
For better performance with many accounts, consider using `futures::join_all` to parallelize the requests.
:::

---

## RNG Requirements

Client RNG must implement `Send + Sync`:

```diff title="src/client.rs"
- use rand::rngs::ThreadRng;
- let client = Client::new(config, ThreadRng::default())?;

+ use rand::rngs::StdRng;
+ use rand::SeedableRng;
+ let rng = StdRng::from_entropy();  // StdRng is Send + Sync
+ let client = Client::new(config, rng)?;
```

---

## CLI Changes

The swap command no longer accepts `payback_note_type`:

```diff title="Terminal"
# Before
- miden-client swap --amount 100 --payback-note-type private

# After
miden-client swap --amount 100
# Note type is now determined automatically
```

---

## WebClient Store

:::warning Breaking Change (JavaScript/TypeScript)
WebClient store now requires optional store name for multiple instances.
:::

```diff title="src/client.ts"
- // Before
- const client = await WebClient.create(config);

+ // After: optional store name for isolation
+ const client = await WebClient.create(config, {
+     storeName: 'my-app-store'  // Optional, for multiple instances
+ });
```

---

## Block Numbers

Block numbers changed from strings to numeric types:

```diff title="src/api.ts"
- // Before (JavaScript)
- const blockNum = response.blockNumber; // "12345"
- const parsed = parseInt(blockNum);

+ // After
+ const blockNum = response.blockNumber; // 12345 (number)
```

---

## NetworkId

`NetworkId` replaced enum with class using static constructors:

```diff title="src/network.ts"
- // Before (TypeScript)
- import { NetworkId } from 'miden-client';
- const network = NetworkId.Testnet;

+ // After
+ import { NetworkId } from 'miden-client';
+ const network = NetworkId.testnet();  // Static constructor
+ const custom = NetworkId.custom(chainId);
```

---

## Migration Steps

1. Replace batch `get_account_proofs` with individual `get_account` calls
2. Ensure RNG types implement `Send + Sync` (use `StdRng`)
3. Remove `payback_note_type` from swap CLI commands
4. Add store name parameter to WebClient if using multiple instances
5. Update code expecting string block numbers to handle numeric types
6. Replace `NetworkId` enum usage with static constructors

---

## Common Errors

| Error | Cause | Fix |
|-------|-------|-----|
| `get_account_proofs not found` | API removed | Use `get_account` per account |
| `ThreadRng does not implement Send` | RNG constraint | Use `StdRng` |
| `unexpected argument 'payback-note-type'` | CLI changed | Remove the argument |
| `NetworkId.Testnet is not a function` | Enum → class | Use `NetworkId.testnet()` |
````

## File: docs/builder/migration/06-masm-changes.md
````markdown
---
sidebar_position: 6
title: "MASM Changes"
description: "Syntax modernization and cryptography updates"
---

# MASM Changes

:::warning Breaking Change
MASM syntax has been modernized. Replace dotted keywords (`const.`, `export.`, `use.`) with spaced forms.
:::

## Quick Fix

```masm title="src/contract.masm"
# Before
const.MY_CONSTANT=42
use.miden::account
export.my_procedure

# After
const MY_CONSTANT=42
use miden::account
export my_procedure
```

---

## Syntax Modernization

Replace dotted keywords with spaced forms:

### Constants

```diff title="src/contract.masm"
- const.MY_CONSTANT=42
+ const MY_CONSTANT=42
```

### Exports

```diff title="src/contract.masm"
- export.my_procedure
+ export my_procedure
    # procedure body
- end
+ end
```

### Imports

```diff title="src/contract.masm"
- use.miden::account
- use.miden::note

+ use miden::account
+ use miden::note
```

### Re-exports

```diff title="src/contract.masm"
- export.miden::account::get_id
+ pub use miden::account::get_id
```

:::tip Helper Script
Use sed to batch-update MASM files:
```bash
# Update constants
sed -i 's/const\./const /g' *.masm

# Update exports
sed -i 's/export\./export /g' *.masm

# Update imports
sed -i 's/use\./use /g' *.masm
```
:::

---

## Cryptography Updates

### Falcon Signature Rename

Rename `RpoFalcon512` to `Falcon512Rpo` throughout codebase:

```diff title="src/auth.masm"
- use.miden::contracts::auth::basic::auth_tx_rpo_falcon512
+ use miden::contracts::auth::basic::auth_tx_falcon512_rpo
```

### ECDSA Procedures

ECDSA procedures moved to new namespace:

```diff title="src/crypto.masm"
- use.miden::crypto::dsa::ecdsa
- exec.ecdsa::verify_k256

+ use miden::core::crypto::dsa::ecdsa_k256_keccak
+ exec.ecdsa_k256_keccak::verify
```

### RPO Hash Helpers

Hash helper procedures renamed:

```diff title="src/hash.masm"
- exec.rpo::hash_memory_words
+ exec.rpo::hash_words
```

---

## Complete MASM Migration Example

Before:
```masm title="src/contract.masm (before)"
use.miden::account
use.std::crypto::hashes::rpo

const.BALANCE_SLOT=0

export.get_balance
    push.BALANCE_SLOT
    exec.account::get_item
end

export.transfer
    exec.rpo::hash_memory_words
    # ... rest of procedure
end
```

After:
```masm title="src/contract.masm (after)"
use miden::account
use miden::core::crypto::hashes::rpo

const BALANCE_SLOT=0

export get_balance
    push.BALANCE_SLOT
    exec.account::get_item
end

export transfer
    exec.rpo::hash_words
    # ... rest of procedure
end
```

---

## Migration Steps

1. Find all `.masm` files in your project
2. Replace `const.` with `const ` (space instead of dot)
3. Replace `export.` with `export ` (space instead of dot)
4. Replace `use.` with `use ` (space instead of dot)
5. Replace `export.<path>` re-exports with `pub use <path>`
6. Update `std::` namespace to `miden::core::`
7. Rename `RpoFalcon512` to `Falcon512Rpo`
8. Update ECDSA procedure paths
9. Rename `hash_memory_words` to `hash_words`

---

## Common Errors

| Error | Cause | Fix |
|-------|-------|-----|
| `unexpected token '.'` | Old syntax | Use space: `const X` not `const.X` |
| `module 'std' not found` | Namespace changed | Use `miden::core::` |
| `procedure 'auth_tx_rpo_falcon512' not found` | Renamed | Use `auth_tx_falcon512_rpo` |
| `procedure 'hash_memory_words' not found` | Renamed | Use `hash_words` |
````

## File: docs/builder/migration/07-assembler-changes.md
````markdown
---
sidebar_position: 7
title: "Assembler Changes"
description: "LibraryPath removal and debug mode changes"
---

# Assembler Changes

:::warning Breaking Change
`LibraryPath` has been removed. Use `Path` directly from `miden_assembly`.
:::

## Quick Fix

```rust title="src/assembler.rs"
// Before
use miden_assembly::LibraryPath;
let path = LibraryPath::new("miden::account")?;

// After
use miden_assembly::Path;
let path = Path::new("miden::account")?;
```

---

## LibraryPath Removal

Remove `LibraryPath`; use `Path` directly from `miden_assembly`:

```diff title="src/assembler.rs"
- use miden_assembly::LibraryPath;
- let path = LibraryPath::new("miden::account")?;

+ use miden_assembly::Path;
+ let path = Path::new("miden::account")?;
```

---

## Debug Mode Changes

Debug mode is now always enabled; remove toggle calls:

```diff title="src/assembler.rs"
- use miden_assembly::Assembler;
- let assembler = Assembler::new()
-     .with_debug_mode(true)  // No longer needed
-     .build()?;

+ use miden_assembly::Assembler;
+ let assembler = Assembler::new().build()?;
+ // Debug mode is always enabled
```

:::info Good to know
Debug mode being always-on simplifies development and has negligible performance impact in production.
:::

---

## Compile Function Argument Order

:::warning Breaking Change
`compile_and_statically_link_from_dir` argument order changed to `(dir, namespace)`.
:::

```diff title="src/compiler.rs"
- // Before: (namespace, dir)
- let program = assembler.compile_and_statically_link_from_dir(
-     "my_module",
-     "./src/masm",
- )?;

+ // After: (dir, namespace)
+ let program = assembler.compile_and_statically_link_from_dir(
+     "./src/masm",
+     "my_module",
+ )?;
```

---

## Library Compilation

Library compilation API updates to use builder pattern:

```diff title="src/library.rs"
- use miden_assembly::Library;
- let lib = Library::from_dir(path, namespace)?;

+ use miden_assembly::Library;
+ let lib = Library::builder()
+     .from_dir(path)
+     .with_namespace(namespace)
+     .build()?;
```

---

## Assembler Context

Assembler context creation simplified:

```diff title="src/context.rs"
- let ctx = AssemblerContext::new()
-     .with_libraries(&[lib1, lib2])
-     .with_debug_info(true)?;

+ let ctx = AssemblerContext::new()
+     .with_libraries(&[lib1, lib2])?;
+ // Debug info always included
```

---

## Migration Steps

1. Replace all `LibraryPath` imports with `Path`
2. Remove `with_debug_mode()` calls from assembler configuration
3. Swap argument order in `compile_and_statically_link_from_dir` calls
4. Update library compilation to use builder pattern
5. Remove `with_debug_info()` calls from context creation

---

## Common Errors

| Error | Cause | Fix |
|-------|-------|-----|
| `LibraryPath not found` | Removed | Use `Path` |
| `with_debug_mode not found` | Removed | Delete the call |
| `mismatched types` in compile_from_dir | Arg order swapped | Swap `(dir, namespace)` |
| `with_debug_info not found` | Removed | Delete the call |
````

## File: docs/builder/migration/index.md
````markdown
---
title: "v0.13 Migration Guide"
description: "Complete guide for upgrading to Miden v0.13"
---

# v0.13 Migration Guide

## Quick Upgrade

Try upgrading first—most projects migrate with just a dependency update:

```toml title="Cargo.toml"
# Replace these
miden-objects = "0.12"
miden-lib = "0.12"

# With these
miden-protocol = "0.13"
miden-standards = "0.13"
```

Then run:

```bash
cargo update && cargo build
```

If you encounter errors, continue reading for detailed migration steps.

---

:::info Who should read this?
This guide is for:
- **Rust client developers** migrating from v0.12 → v0.13
- **App developers** using `miden-objects`, `miden-lib`, or legacy MASM syntax
- **Smart contract authors** using storage slots or note APIs

If you're starting fresh on v0.13, you can skip this guide and go directly to the [Quick Start](../quick-start).
:::

---

## What's New in v0.13

This release brings significant improvements alongside the breaking changes:

| Feature | Benefit |
|---------|---------|
| **Named Storage** | More intuitive and self-documenting storage access |
| **Unified Auth** | Simpler authentication with `AuthScheme` enum |
| **Note Attachments** | Cleaner separation of note data and metadata |
| **Modern MASM Syntax** | Cleaner syntax aligned with Rust conventions |

---

## Compatibility

| Component | Required | Tested With |
|-----------|----------|-------------|
| Miden VM | 0.20+ | 0.20.0 |
| miden-crypto | 0.19+ | 0.19.0 |
| Rust | 1.75+ | 1.82.0 |

---

## Migration Philosophy

We group breaking changes into major releases to minimize disruption. When possible, we deprecate before removing—this guide covers features deprecated in v0.12 that are now removed, plus new breaking changes in v0.13.

Expect migration guides with each major version (roughly quarterly).

---

## At a Glance

Key themes in this release:

| Change | Summary |
|--------|---------|
| **Named Storage** | Storage slots now identified by `StorageSlotName` instead of numeric indices |
| **Note Attachments** | `NoteMetadata` no longer stores `aux` or `NoteExecutionHint`; use `NoteAttachment` |
| **Unified Input Notes** | Input notes no longer split into authenticated/unauthenticated lists |
| **Authentication APIs** | Auth APIs unified around `AuthScheme` enum |

---

## Migration Sections

Work through these sections in order for a complete migration:

| Section | Topics |
|---------|--------|
| [1. Imports & Dependencies](./imports-dependencies) | Crate renames, `miden-protocol`, `miden-standards` |
| [2. Account Changes](./account-changes) | Named storage, keystore, components, procedure roots |
| [3. Note Changes](./note-changes) | Attachments, tags, `NetworkAccountTarget`, MINT notes |
| [4. Transaction Changes](./transaction-changes) | `TransactionEvent` → `TransactionEventId` |
| [5. Client Changes](./client-changes) | Rust RPC, WebClient store, CLI changes |
| [6. MASM Changes](./masm-changes) | Syntax modernization, crypto renames |
| [7. Assembler Changes](./assembler-changes) | `LibraryPath` removal, debug mode changes |

---

## Final Checklist

Complete these steps to verify your migration:

- [ ] Update `Cargo.toml` dependencies to v0.13
- [ ] Rename `miden-objects` → `miden-protocol` imports
- [ ] Rename `miden-lib` → `miden-standards` imports
- [ ] Rename `StdLibrary` → `CoreLibrary`
- [ ] Update storage slot access to use `StorageSlotName`
- [ ] Refactor `NoteMetadata` to use `NoteAttachment`
- [ ] Update input notes API to use unified interface
- [ ] Update MASM syntax (`const.` → `const `, etc.)
- [ ] Run `cargo build` — **no errors**
- [ ] Run `cargo test` — **all tests pass**

:::tip You're done!
If your project builds and all tests pass, you've successfully migrated to v0.13.
:::
````

## File: docs/builder/quick-start/setup/cli-basics.md
````markdown
---
sidebar_position: 2
title: CLI Basics
description: Learn essential Miden CLI commands to create your wallet and mint your first tokens.
---

This guide covers essential Miden CLI commands for creating accounts, minting and managing tokens. Make sure to have [installed Miden development tools](./installation.md) using the `midenup` toolchain.

## Create Your First Account

### Generate a New Wallet

Create a new Miden wallet account:

```bash title=">_ Terminal"
miden client new-wallet
```

<details>
<summary>Expected output</summary>

```text
Successfully created new wallet.
To view account details execute miden-client account --show 0x05bd1f642cd368800cc95956b2696a
Config updated successfully
Setting account 0x05bd1f642cd368800cc95956b2696a as the default account ID.
You can unset it with `miden-client account --default none`.
```

</details>

This command creates a **BasicMutable** account with **private** storage mode, giving you full control while keeping your data confidential.

### View Your Account

List all your accounts:

```bash title=">_ Terminal"
miden client account
```

<details>
<summary>Expected output</summary>

```text
| Account ID | Type | Storage Mode | Nonce | Status |
|------------|------|--------------|-------|--------|
| 0x970e3e4dbcd09b8035532edaa87bc9 | Regular | private | 0 | New |
```

</details>

View detailed information about your account:

```bash title=">_ Terminal"
miden client account -s <ACCOUNT_ID>
```

<details>
<summary>Expected output</summary>

```text
Account Information
==================

| Field              | Value                                                                    |
|-------------------|--------------------------------------------------------------------------|
| Address           | mtst1qztsu0jdhngfhqp42vhd42rme9cqzkzy89e                                |
| Account ID (hex)  | 0x970e3e4dbcd09b8035532edaa87bc9                                        |
| Account Commitment| 0x404a762b9a19e70bc8752381b17f909bc0bbab02c0b4636d8923d088ac8ebc04      |
| Type              | Regular                                                                   |
| Storage mode      | private                                                                   |
| Code Commitment   | 0x6a11161925930dae89cc24cbddf0d161cead39b0fe88c262d4e790cff35be01d      |
| Vault Root        | 0x3e128c57f6cfa0d44ab1308994171af13cb513422add28d1916b3ff254fef82d      |
| Storage Root      | 0x5f95d38174f10c8ce91a0202763b0813fdcbb2714704cda411af6483ebc8d012      |
| Nonce             | 0                                                                         |

Assets:

| Asset Type | Faucet | Amount |
|------------|---------|---------|
| | | |

Storage:

| Item Slot Index | Item Slot Type | Value/Commitment |
|-----------------|----------------|------------------|
| 0 | Value | 0xa52ef6357625c54a2eaefd11b8cfc2ee3429c37d9f8a827e23886857ea284834 |
```

</details>

**Key Account Components:**

- **Account ID**: Unique 120-bit identifier encoding the account type and storage mode
- **Vault**: Secure storage for your assets
- **Storage**: Key-value store for account data (255 slots available)
- **Code Commitment**: Hash of the account's smart contract logic
- **Nonce**: Counter that increments with each state change

## Account Management

### Switch Between Accounts

If you have multiple accounts, set which one to use as default:

```bash title=">_ Terminal"
miden client account --default <ACCOUNT_ID>
```

### Deploy Your Account

To make your account visible on-chain, deploy it using:

```bash title=">_ Terminal"
miden client new-wallet
```

## Create a New Project

**Rust workspace template**: Designed for developing, testing, and deploying Miden smart contracts using Rust

**Frontend project template**: Provides a simple starting point for building web applications that interact with deployed contracts on the Miden Testnet, including publishing and consuming notes.

**Rust Workspace:**

```bash title=">_ Terminal"
miden new my-project
```

Creates a **Rust workspace** for writing, testing and deploying Miden smart contracts.

**Vite Frontend Project:**

```bash title=">_ Terminal"
# Using Yarn
yarn create-miden-app
# Using NPM
npx create-miden-app
```

Creates a minimal **Vite example project with Miden integration**, built on the standard Vite React TypeScript template.

## Custom client configuration

Initialize the client in your working directory when you want to test against a custom network endpoint or use different keys without touching your global config:

```bash title=">_ Terminal"
miden client init --network devnet
```

Available networks:

- `testnet` - Miden's public test network
- `devnet` - Development network
- `localhost` - Local node for testing

### Important Files Created

When you manually initialize the Miden client in your working directory, several local files are created:

- **`miden-client.toml`**: Configuration file with network settings
- **`store.sqlite3`**: Database storing your account data and transaction history
- **`keystore/`**: Directory containing your private keys (keep secure!)
- **`templates/`**: Pre-built smart contract components

:::danger
Private keys in the `keystore/` directory are **not encrypted**. Keep these files secure and never share them.
:::

To return to your global client configuration, remove the local `miden-client.toml` (and any local store/keystore files you no longer need).

---
````

## File: docs/builder/quick-start/setup/installation.md
````markdown
---
sidebar_position: 1
title: Installation
description: Get started with Miden development by installing Miden tools using the `midenup` toolchain.
---

This guide walks you through installing the Miden development tools using the `midenup` toolchain manager.

## Prerequisites

### Install Rust

Miden development requires Rust. Install it using rustup:

```bash title=">_ Terminal"
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y
```

Reload your PATH environment variable:

```bash title=">_ Terminal"
. "$HOME/.cargo/env"
```

Verify the installation:

```bash title=">_ Terminal"
rustc --version
```

<details>
<summary>Expected output</summary>

```text
rustc 1.92.0-nightly (fa3155a64 2025-09-30)
```

</details>

### Install Node.js & Yarn

For TypeScript development with the Miden Web Client, you'll need Node.js and Yarn.

**Install Node.js:**

```bash title=">_ Terminal"
# Install Node.js using the official installer or package manager
# For macOS with Homebrew:
brew install node

# For Ubuntu/Debian:
curl -fsSL https://deb.nodesource.com/setup_lts.x | sudo -E bash -
sudo apt-get install -y nodejs

# For Windows, download from nodejs.org
```

**Install Yarn:**

```bash title=">_ Terminal"
# Install Yarn globally via npm
npm install -g yarn
```

**Verify installations:**

```bash title=">_ Terminal"
node --version && yarn --version
```

<details>
<summary>Expected output</summary>

```text
v20.11.0
1.22.19
```

</details>

### Install Miden CLI

**Install midenup**

The Miden toolchain installer makes it easy to manage Miden components:

```bash title=">_ Terminal"
cargo install midenup
```

:::info
Until published to crates.io, install using: `cargo install --git https://github.com/0xMiden/midenup.git`
:::

**Initialize midenup**

```bash title=">_ Terminal"
midenup init
```

This creates the `$MIDENUP_HOME` directory and sets up symlinks for the `miden` command.

**Configure PATH**

Add the midenup bin directory to your PATH. First, check your current `$MIDENUP_HOME`:

```bash title=">_ Terminal"
midenup show home
```

Then add it to your shell configuration:

**For Zsh (macOS default):**

```bash title="~/.zshrc"
export PATH="/Users/$(whoami)/Library/Application Support/midenup/bin:$PATH"
source ~/.zshrc
```

**For Bash:**

```bash title="~/.bashrc"
export PATH="$XDG_DATA_DIR/midenup/bin:$PATH"
source ~/.bashrc
```

**Install Miden Toolchain**

Install the latest stable Miden components:

```bash title=">_ Terminal"
midenup install stable
```

### Verify Installation

Check that everything is working correctly:

```bash title=">_ Terminal"
midenup show active-toolchain
```

<details>
<summary>Expected output</summary>

```text
stable
```

</details>

```bash title=">_ Terminal"
which miden
```

<details>
<summary>Expected output</summary>

```text
/Users/<USERNAME>/Library/Application Support/midenup/bin/miden
```

</details>

Test by creating a new project:

```bash title=">_ Terminal"
miden new my-test-project
```

If successful, you'll see a new directory with Miden project files.

### Troubleshooting

**"miden: command not found"**

This means the PATH isn't configured correctly. Verify midenup's bin directory is in your PATH:

```bash title=">_ Terminal"
echo $PATH | grep midenup
```

If missing, re-add the export command to your shell configuration and reload it.

---
````

## File: docs/builder/quick-start/your-first-smart-contract/index.md
````markdown
---
sidebar_position: 1
title: Your First Smart Contract
description: Learn to build, test, and deploy smart contracts on Miden using Rust.
---

# Your First Smart Contract

Welcome to the **Your First Smart Contract** guide! This tutorial will walk you through building, testing, and deploying your first Miden smart contract using Rust.

## What You'll Learn

By the end of this tutorial, you will have:

- **Set up a Miden project** with the proper workspace structure
- **Written and understood** a counter smart contract and increment note
- **Deployed your contract** to the Miden testnet using integration scripts
- **Mastered the fundamentals** of Miden's account-based smart contract model

This guide focuses on practical, hands-on learning. You'll work with real code and deploy to a live network, giving you everything needed to start building on Miden.

## What We'll Build

You'll create a **counter contract system** consisting of:

- **Counter Account**: A smart contract that stores and manages a counter value in its storage
- **Increment Note**: A note script that increments the counter when executed
- **Integration Scripts**: Deployment and interaction scripts for managing the contract lifecycle

The counter example is designed to teach core Miden concepts through a simple, understandable use case that you can extend for your own projects.

## Prerequisites

Before starting this guide, ensure you have completed the [Installation](../setup/installation) tutorial and have:

- **Rust toolchain** installed and configured
- **midenup toolchain** installed with Miden CLI tools

:::tip Prerequisites Required
You need those development tools installed for this guide. If you haven't set up your environment yet, please complete the [installation](../setup/installation) guide first.
:::

## No Prior Experience Required

This tutorial is designed for developers new to Miden. You don't need prior experience with:

- Miden's account model or note-based transactions
- Smart contract development on Miden
- The specifics of Rust development for blockchain

We'll explain these concepts as we encounter them in the tutorial.

## Getting Help

If you get stuck during this tutorial:

- Check the rest of the Miden Docs for detailed technical references
- Join the [Build On Miden](https://t.me/BuildOnMiden) Telegram community for support
- Review the code examples in your project's `contracts` and `integration/` folder

## Guide Structure

This tutorial is divided into focused sections:

1. **[Create Your Project](./create)** - Set up your workspace and understand the counter contract code
2. **[Deploy Your Contract](./deploy)** - Learn the integration folder and deploy to testnet
3. **[Test Your Contract](./test)** - Learn how to effectively test your contracts

Each section builds on the previous one, so we recommend following them in order.

Ready to build your first Miden smart contract? Let's get started!
````

## File: docs/builder/quick-start/_category_.json
````json
{
  "label": "Quick Start",
  "position": 1,
  "link": {
    "type": "doc",
    "id": "builder/quick-start/index"
  }
}
````

## File: docs/builder/quick-start/index.md
````markdown
---
sidebar_position: 0
title: Quick Start V2
description: Get started with Miden by installing Miden tools using the `midenup` toolchain, creating your first wallet, performing basic operations, and building your first smart contract!
---

# Quick Start

Welcome to Miden! This guide will get you up and running with the Miden blockchain by walking you through the essential setup and core operations.

## What is Miden?

Miden is a privacy-focused, ZK-based blockchain that uses an actor model where each account is a smart contract. Unlike traditional blockchains where accounts simply hold balances, Miden accounts are programmable entities that can execute custom logic, store data, and manage assets autonomously.

Key concepts you'll encounter:

- **Accounts**: Smart contracts that hold assets and execute code
- **Notes**: Messages that exchange data and assets between accounts - also programmable
- **Assets**: Tokens that can be fungible or non-fungible
- **Privacy**: Every transaction, note and account in Miden is private by default — only the involved parties can view asset amounts or transfer details, offering strong confidentiality guarantees.

## Getting Started

Follow these guides in order to get started with Miden:

import DocCard from '@theme/DocCard';

<div className="row">
  <div className="col col--6">
    <DocCard
      item={{
        type: 'link',
        href: './setup/installation',
        label: 'Installation',
        description: 'Get started with Miden development by installing Miden tools using the midenup toolchain.',
      }}
    />
  </div>
  <div className="col col--6">
    <DocCard
      item={{
        type: 'link',
        href: './setup/cli-basics',
        label: 'CLI Basics',
        description: 'Learn essential Miden CLI commands to create your wallet and mint your first tokens.',
      }}
    />
  </div>
</div>

<div className="row">
  <div className="col col--6">
    <DocCard
      item={{
        type: 'link',
        href: './accounts',
        label: 'Accounts',
        description: 'Learn how to create and manage Miden accounts programmatically using Rust and TypeScript.',
      }}
    />
  </div>
  <div className="col col--6">
    <DocCard
      item={{
        type: 'link',
        href: './notes',
        label: 'Notes & Transactions',
        description: 'Learn Miden\'s unique note-based transaction model for private asset transfers.',
      }}
    />
  </div>
</div>

<div className="row">
  <div className="col col--6">
    <DocCard
      item={{
        type: 'link',
        href: './read-storage',
        label: 'Read Storage Values',
        description: 'Learn how to query account storage data and interact with deployed smart contracts.',
      }}
    />
  </div>
  <div className="col col--6">
    <DocCard
      item={{
        type: 'link',
        href: './your-first-smart-contract',
        label: 'Your First Smart Contract',
        description: 'Learn to build, test, and deploy smart contracts on Miden using Rust.',
      }}
    />
  </div>
</div>
````

## File: docs/builder/quick-start/notes.md
````markdown
---
sidebar_position: 3
title: Notes & Transactions
description: Learn Miden's unique note-based transaction model for private asset transfers.
---

import { CodeTabs } from '@site/src/components';

# Notes & Transactions

Miden's transaction model is uniquely powerful, combining private asset transfers through notes with zero-knowledge proofs. Let's explore how to mint, consume, and send tokens using this innovative approach.

## Understanding Miden's Transaction Model

Traditional blockchains move tokens directly between account balances. Miden uses a more sophisticated **note-based system** that provides enhanced privacy and flexibility.

**Think of Notes Like Sealed Envelopes:**

- Alice puts 100 tokens in a sealed envelope (note) addressed to Bob
- She posts the envelope to the public board (network)
- Only Bob can open envelopes addressed to him
- When Bob opens it, the 100 tokens move to his vault

**Key Components:**

- **Notes**: Sealed containers that carry data and assets between accounts
- **P2ID (Pay-To-ID) Notes**: Notes addressed to a specific account ID (like Bob's address)
- **Nullifiers**: Prevent someone from opening the same envelope twice
- **Zero-Knowledge Proofs**: Prove transactions are valid without revealing private details

## The Two-Transaction Model

Miden uses a **two-transaction model** for asset transfers that provides enhanced privacy and scalability:

### Transaction 1: Sender Creates Note

- **Alice's account** creates a P2ID (Pay-To-ID) note containing 100 tokens
- The note specifies **Bob** as the only valid consumer
- Alice's balance decreases, note is available for consumption
- Alice's transaction is complete and final

### Transaction 2: Recipient Consumes Note

- **Bob's account** discovers the note (addressed to his ID)
- Bob creates a transaction to consume the note
- Tokens move from the note into Bob's vault
- Bob's balance increases, note is nullified

### Benefits

This approach provides several advantages over direct transfers:

1. **Privacy**: Alice and Bob's transactions are unlinkable
2. **Parallelization**: Multiple transactions can be processed concurrently, enabling simultaneous creation of notes.
3. **Flexibility**: Notes can include complex conditions (time locks, multi-sig, etc.)
4. **Scalability**: No global state synchronization required

## Set Up Development Environment

To run the code examples in this guide, you'll need to set up a development environment. If you haven't already, follow the setup instructions in the [Accounts](./accounts#set-up-development-environment) guide.

## Minting Tokens

**What is Minting?**
Minting in Miden creates new tokens and packages them into a **P2ID note** (Pay-to-ID note) addressed to a specific account. Unlike traditional blockchains where tokens appear directly in your balance, Miden uses a two-step process:

1. **Faucet mints tokens** → Creates a P2ID note containing the tokens
2. **Recipient consumes the note** → Tokens move into their account vault

**Key Concepts:**

- **P2ID Note**: A note that can only be consumed by the account it's addressed to
- **NoteType**: Determines visibility - `Public` notes are visible onchain and are stored by the Miden network, while `Private` notes are not stored by the network and must be exchanged directly between parties via other channels.
- **FungibleAsset**: Represents tokens that can be divided and exchanged (like currencies)

Let's see this in action:

<CodeTabs
tsFilename="src/lib/mint.ts"
rustFilename="integration/src/bin/mint.rs"
example={{
rust: {
code: `use miden_client::{
    account::{
        component::{AuthRpoFalcon512, BasicFungibleFaucet, BasicWallet},
        AccountBuilder, AccountId, AccountStorageMode, AccountType,
    },
    asset::{FungibleAsset, TokenSymbol},
    auth::AuthSecretKey,
    builder::ClientBuilder,
    crypto::rpo_falcon512::SecretKey,
    keystore::FilesystemKeyStore,
    note::{create_p2id_note, NoteType},
    rpc::{Endpoint, GrpcClient},
    transaction::{OutputNote, TransactionRequestBuilder},
    Felt,
};
use miden_client_sqlite_store::ClientBuilderSqliteExt;
use rand::RngCore;
use std::sync::Arc;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Initialize RPC connection
    let endpoint = Endpoint::testnet();
    let timeout_ms = 10_000;
    let rpc_client = Arc::new(GrpcClient::new(&endpoint, timeout_ms));

    // Initialize keystore
    let keystore_path = std::path::PathBuf::from("./keystore");
    let keystore: FilesystemKeyStore<rand::prelude::StdRng> =
        FilesystemKeyStore::new(keystore_path).unwrap().into();

    let store_path = std::path::PathBuf::from("./store.sqlite3");

    // Initialize client to connect with the Miden Testnet.
    // NOTE: The client is our entry point to the Miden network.
    // All interactions with the network go through the client.
    let mut client = ClientBuilder::new()
        .rpc(rpc_client)
        .sqlite_store(store_path)
        .authenticator(keystore.clone().into())
        .in_debug_mode(true.into())
        .build()
        .await?;

    client.sync_state().await?;

    //------------------------------------------------------------
    // CREATING A FAUCET AND MINTING TOKENS
    //------------------------------------------------------------

    // Faucet seed
    let mut init_seed = [0u8; 32];
    client.rng().fill_bytes(&mut init_seed);

    // Faucet parameters
    let symbol = TokenSymbol::new("TEST")?;
    let decimals = 8;
    let max_supply = Felt::new(1_000_000);

    // Generate key pair
    let alice_key_pair = SecretKey::with_rng(client.rng());
    let faucet_key_pair = SecretKey::with_rng(client.rng());

    // Build the account
    let account_builder = AccountBuilder::new(init_seed)
        .account_type(AccountType::RegularAccountUpdatableCode)
        .storage_mode(AccountStorageMode::Public)
        .with_auth_component(AuthRpoFalcon512::new(
            alice_key_pair.public_key().to_commitment().into(),
        ))
        .with_component(BasicWallet);

    // Build the faucet
    let faucet_builder = AccountBuilder::new(init_seed)
        .account_type(AccountType::FungibleFaucet)
        .storage_mode(AccountStorageMode::Public)
        .with_auth_component(AuthRpoFalcon512::new(
            faucet_key_pair.public_key().to_commitment().into(),
        ))
        .with_component(BasicFungibleFaucet::new(symbol, decimals, max_supply)?);

    let alice_account = account_builder.build()?;
    let faucet_account = faucet_builder.build()?;

    println!("Alice's account ID: {:?}", alice_account.id().to_hex());
    println!("Faucet account ID: {:?}", faucet_account.id().to_hex());

    // Add accounts to client
    client.add_account(&alice_account, false).await?;
    client.add_account(&faucet_account, false).await?;

    // Add keys to keystore
    keystore.add_key(&AuthSecretKey::RpoFalcon512(alice_key_pair))?;
    keystore.add_key(&AuthSecretKey::RpoFalcon512(faucet_key_pair))?;

    let amount: u64 = 1000;
    let fungible_asset = FungibleAsset::new(faucet_account.id(), amount)?;

    // Build transaction request to mint fungible asset to Alice's account
    // NOTE: This transaction will create a P2ID note (a Miden note containing the minted asset)
    // for Alice's account. Alice will be able to consume these notes to get the fungible asset in her vault
    let transaction_request = TransactionRequestBuilder::new().build_mint_fungible_asset(
        fungible_asset,
        alice_account.id(),
        NoteType::Public,
        client.rng(),
    )?;

    // Create transaction and submit it to create P2ID notes for Alice's account
    let tx_id = client
        .submit_new_transaction(faucet_account.id(), transaction_request)
        .await?;
    client.sync_state().await?;

    println!(
        "Mint transaction submitted successfully, ID: {:?}",
        tx_id.to_hex()
    );

    Ok(())
}
`},
  typescript: {
    code:`import {
    WebClient,
    AccountStorageMode,
    NoteType,
} from "@demox-labs/miden-sdk";

export async function demo() {
    // Initialize client to connect with the Miden Testnet.
    // NOTE: The client is our entry point to the Miden network.
    // All interactions with the network go through the client.
    const nodeEndpoint = "https://rpc.testnet.miden.io:443";

    // Initialize client
    const client = await WebClient.createClient(nodeEndpoint);
    await client.syncState();

    // Creating Alice's account
    const alice = await client.newWallet(AccountStorageMode.public(), true);
    console.log("Alice's account ID:", alice.id().toString());

    // Creating a faucet account
    const symbol = "TEST";
    const decimals = 8;
    const initialSupply = BigInt(10_000_000 * 10 ** decimals);
    const faucet = await client.newFaucet(
        AccountStorageMode.public(), // Public: account state is visible on-chain
        false, // Mutable: account code cannot be upgraded later
        symbol, // Symbol of the token
        decimals, // Number of decimals
        initialSupply // Initial supply of tokens
    );
    console.log("Faucet account ID:", faucet.id().toString());

    // Create transaction request to mint fungible asset to Alice's account
    // NOTE: This transaction will create a P2ID note (a Miden note containing the minted asset)
    // for Alice's account. Alice will be able to consume these notes to get the fungible asset in her vault
    console.log("Minting 1000 tokens to Alice...");
    const mintTxRequest = client.newMintTransactionRequest(
        alice.id(), // Target account (who receives the tokens)
        faucet.id(), // Faucet account (who mints the tokens)
        NoteType.Public, // Note visibility (public = on-chain)
        BigInt(1000) // Amount to mint (in base units)
    );
    const mintTxId = await client.submitNewTransaction(
        faucet.id(),
        mintTxRequest
    );

    console.log("Mint transaction submitted successfully, ID:", mintTxId.toHex());

    await client.syncState();
}
`
}
}}
/>

<details>
<summary>Expected output</summary>

```text
Alice's account ID: 0x49e27aa5fa5686102fde8e81b89999
Faucet account ID: 0x9796be9c72f137206676f7821a9968
Minting 1000 tokens to Alice...
Mint transaction submitted successfully, ID: 0x7a2dbde87ea2f4d41b396d6d3f6bdb9a8d7e2a51555fa57064a1657ad70fca06
```

</details>

## Consuming Notes

**Why Consume Notes?**
After minting creates a P2ID note containing tokens, the recipient must **consume** the note to actually receive the tokens in their account vault. This two-step process provides several benefits:

- **Privacy**: The mint transaction and consume transaction are unlinkable
- **Flexibility**: Recipients can consume notes when they choose
- **Atomic Operations**: Each step either succeeds completely or fails safely

**The Process:**

1. **Find consumable notes** addressed to your account
2. **Create a consume transaction** referencing the note IDs
3. **Submit the transaction** to move tokens into your vault

Here's how to consume notes programmatically:

<CodeTabs
tsFilename="src/lib/consume.ts"
rustFilename="integration/src/bin/consume.rs"
example={{
rust: {
code: `use miden_client::{
    account::{
        component::{AuthRpoFalcon512, BasicFungibleFaucet, BasicWallet},
        AccountBuilder, AccountStorageMode, AccountType,
    },
    asset::{FungibleAsset, TokenSymbol},
    auth::AuthSecretKey,
    builder::ClientBuilder,
    crypto::rpo_falcon512::SecretKey,
    keystore::FilesystemKeyStore,
    note::{NoteType},
    rpc::{Endpoint, GrpcClient},
    transaction::{TransactionRequestBuilder},
    Felt,
};
use miden_client_sqlite_store::ClientBuilderSqliteExt;
use rand::RngCore;
use std::sync::Arc;
use tokio::time::Duration;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Initialize RPC connection
    let endpoint = Endpoint::testnet();
    let timeout_ms = 10_000;
    let rpc_client = Arc::new(GrpcClient::new(&endpoint, timeout_ms));

    // Initialize keystore
    let keystore_path = std::path::PathBuf::from("./keystore");
    let keystore: FilesystemKeyStore<rand::prelude::StdRng> =
        FilesystemKeyStore::new(keystore_path).unwrap().into();

    let store_path = std::path::PathBuf::from("./store.sqlite3");

    // Initialize client to connect with the Miden Testnet.
    // NOTE: The client is our entry point to the Miden network.
    // All interactions with the network go through the client.
    let mut client = ClientBuilder::new()
        .rpc(rpc_client)
        .sqlite_store(store_path)
        .authenticator(keystore.clone().into())
        .in_debug_mode(true.into())
        .build()
        .await?;

    client.sync_state().await?;

    //------------------------------------------------------------
    // CREATING A FAUCET AND MINTING TOKENS
    //------------------------------------------------------------

    // Faucet seed
    let mut init_seed = [0u8; 32];
    client.rng().fill_bytes(&mut init_seed);

    // Faucet parameters
    let symbol = TokenSymbol::new("TEST")?;
    let decimals = 8;
    let max_supply = Felt::new(1_000_000);

    // Generate key pair
    let alice_key_pair = SecretKey::with_rng(client.rng());
    let faucet_key_pair = SecretKey::with_rng(client.rng());

    // Build the account
    let account_builder = AccountBuilder::new(init_seed)
        .account_type(AccountType::RegularAccountUpdatableCode)
        .storage_mode(AccountStorageMode::Public)
        .with_auth_component(AuthRpoFalcon512::new(
            alice_key_pair.public_key().to_commitment().into(),
        ))
        .with_component(BasicWallet);

    // Build the faucet
    let faucet_builder = AccountBuilder::new(init_seed)
        .account_type(AccountType::FungibleFaucet)
        .storage_mode(AccountStorageMode::Public)
        .with_auth_component(AuthRpoFalcon512::new(
            faucet_key_pair.public_key().to_commitment().into(),
        ))
        .with_component(BasicFungibleFaucet::new(symbol, decimals, max_supply)?);

    let alice_account = account_builder.build()?;
    let faucet_account = faucet_builder.build()?;

    println!("Alice's account ID: {:?}", alice_account.id().to_hex());
    println!("Faucet account ID: {:?}", faucet_account.id().to_hex());

    // Add accounts to client
    client.add_account(&alice_account, false).await?;
    client.add_account(&faucet_account, false).await?;

    // Add keys to keystore
    keystore.add_key(&AuthSecretKey::RpoFalcon512(alice_key_pair))?;
    keystore.add_key(&AuthSecretKey::RpoFalcon512(faucet_key_pair))?;

    let amount: u64 = 1000;
    let fungible_asset = FungibleAsset::new(faucet_account.id(), amount)?;

    // Build transaction request to mint fungible asset to Alice's account
    // NOTE: This transaction will create a P2ID note (a Miden note containing the minted asset)
    // for Alice's account. Alice will be able to consume these notes to get the fungible asset in her vault
    let transaction_request = TransactionRequestBuilder::new().build_mint_fungible_asset(
        fungible_asset,
        alice_account.id(),
        NoteType::Public,
        client.rng(),
    )?;

    // Create transaction and submit it to create P2ID notes for Alice's account
    let tx_id = client
        .submit_new_transaction(faucet_account.id(), transaction_request)
        .await?;
    client.sync_state().await?;

    println!(
        "Mint transaction submitted successfully, ID: {:?}",
        tx_id.to_hex()
    );

    //------------------------------------------------------------
    // CONSUMING P2ID NOTES
    //------------------------------------------------------------

    loop {
        // Sync state to get the latest block
        client.sync_state().await?;

        let consumable_notes = client
            .get_consumable_notes(Some(alice_account.id()))
            .await?;
        let note_ids = consumable_notes
            .iter()
            .map(|(note, _)| note.id())
            .collect::<Vec<_>>();

        if note_ids.len() == 0 {
            println!("Waiting for P2ID note to be comitted...");
            tokio::time::sleep(Duration::from_secs(2)).await;
            continue;
        }

        let consume_tx_request = TransactionRequestBuilder::new().build_consume_notes(note_ids)?;

        // Create transaction and submit it to consume notes
        let consume_tx_id = client
            .submit_new_transaction(alice_account.id(), consume_tx_request)
            .await?;

        println!(
            "Consume transaction submitted successfully, ID: {:?}",
            consume_tx_id.to_hex()
        );

        client.sync_state().await?;

        let alice_account_record = client
            .get_account(alice_account.id())
            .await?
            .ok_or_else(|| anyhow::anyhow!("Account not found"))?;
        let alice_account = alice_account_record.account().clone();
        let vault = alice_account.vault();
        println!(
            "Alice's TEST token balance: {:?}",
            vault.get_balance(faucet_account.id())
        );

        break; // Exit the loop after consuming the note
    }

    Ok(())
}
`},
  typescript: {
    code:`import {
    WebClient,
    AccountStorageMode,
    NoteType,
    ConsumableNoteRecord,
} from "@demox-labs/miden-sdk";

export async function demo() {
    // Initialize client to connect with the Miden Testnet.
    // NOTE: The client is our entry point to the Miden network.
    // All interactions with the network go through the client.
    const nodeEndpoint = "https://rpc.testnet.miden.io:443";

    // Initialize client
    const client = await WebClient.createClient(nodeEndpoint);
    await client.syncState();

    // Creating Alice's account
    const alice = await client.newWallet(AccountStorageMode.public(), true);
    console.log("Alice's account ID:", alice.id().toString());

    // Creating a faucet account
    const symbol = "TEST";
    const decimals = 8;
    const initialSupply = BigInt(10_000_000 * 10 ** decimals);
    const faucet = await client.newFaucet(
        AccountStorageMode.public(), // Public: account state is visible on-chain
        false, // Mutable: account code cannot be upgraded later
        symbol, // Symbol of the token
        decimals, // Number of decimals
        initialSupply // Initial supply of tokens
    );
    console.log("Faucet account ID:", faucet.id().toString());

    // Create transaction request to mint fungible asset to Alice's account
    // NOTE: This transaction will create a P2ID note (a Miden note containing the minted asset)
    // for Alice's account. Alice will be able to consume these notes to get the fungible asset in her vault
    console.log("Minting 1000 tokens to Alice...");
    const mintTxRequest = client.newMintTransactionRequest(
        alice.id(), // Target account (who receives the tokens)
        faucet.id(), // Faucet account (who mints the tokens)
        NoteType.Public, // Note visibility (public = on-chain)
        BigInt(1000) // Amount to mint (in base units)
    );
    const mintTxId = await client.submitNewTransaction(
        faucet.id(),
        mintTxRequest
    );

    console.log("Mint transaction submitted successfully, ID:", mintTxId.toHex());

    await client.syncState();

    let consumableNotes: ConsumableNoteRecord[] = [];
    while (consumableNotes.length === 0) {
        // Find consumable notes
        consumableNotes = await client.getConsumableNotes(alice.id());

        console.log("Waiting for note to be consumable...");
        await new Promise((resolve) => setTimeout(resolve, 3000));
    }

    const noteIds = consumableNotes.map((note) =>
        note.inputNoteRecord().id().toString()
    );

    // Create transaction request to consume notes
    // NOTE: This transaction will consume the notes and add the fungible asset to Alice's vault
    const consumeTxRequest = client.newConsumeTransactionRequest(noteIds);
    const consumeTxId = await client.submitNewTransaction(
        alice.id(),
        consumeTxRequest
    );
    console.log(
        "Consume transaction submitted successfully, ID:",
        consumeTxId.toHex()
    );

    console.log(
        "Alice's TEST token balance:",
        Number(alice.vault().getBalance(faucet.id()))
    );

    await client.syncState();
}
`
}
}}
/>

<details>
<summary>Expected output</summary>

```text
Alice's account ID: "0x49e27aa5fa5686102fde8e81b89999"
Faucet account ID: "0x9796be9c72f137206676f7821a9968"
Minting 1000 tokens to Alice...
Mint transaction submitted successfully, ID: "0x7a2dbde87ea2f4d41b396d6d3f6bdb9a8d7e2a51555fa57064a1657ad70fca06"
Waiting for note to be consumable...
Consume transaction submitted successfully, ID: "0xa75872c498ee71cd6725aef9411d2559094cec1e1e89670dbf99c60bb8843481"
Alice's TEST token balance: Ok(1000)
```

</details>

## Sending Tokens Between Accounts

**How Sending Works in Miden**
Sending tokens between accounts follows the same note-based pattern. The sender creates a new P2ID note containing tokens from their vault and addresses it to the recipient:

**The Flow:**

1. **Sender creates P2ID note** containing tokens and recipient's account ID
2. **Sender submits transaction** - their balance decreases, note is published
3. **Recipient discovers note** addressed to their account ID
4. **Recipient consumes note** - tokens move into their vault

This approach means Alice and Bob's transactions are completely separate and unlinkable, providing strong privacy guarantees.

Let's implement the complete flow - mint, consume, then send:

<CodeTabs
tsFilename="src/lib/send.ts"
rustFilename="integration/src/bin/send.rs"
example={{
rust: {
code: `use miden_client::{
    account::{
        component::{AuthRpoFalcon512, BasicFungibleFaucet, BasicWallet},
        AccountBuilder, AccountId, AccountStorageMode, AccountType,
    },
    asset::{FungibleAsset, TokenSymbol},
    auth::AuthSecretKey,
    builder::ClientBuilder,
    crypto::rpo_falcon512::SecretKey,
    keystore::FilesystemKeyStore,
    note::{create_p2id_note, NoteType},
    rpc::{Endpoint, GrpcClient},
    transaction::{OutputNote, TransactionRequestBuilder},
    Felt,
};
use miden_client_sqlite_store::ClientBuilderSqliteExt;
use rand::RngCore;
use std::sync::Arc;
use tokio::time::Duration;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Initialize RPC connection
    let endpoint = Endpoint::testnet();
    let timeout_ms = 10_000;
    let rpc_client = Arc::new(GrpcClient::new(&endpoint, timeout_ms));

    // Initialize keystore
    let keystore_path = std::path::PathBuf::from("./keystore");
    let keystore: FilesystemKeyStore<rand::prelude::StdRng> =
        FilesystemKeyStore::new(keystore_path).unwrap().into();

    let store_path = std::path::PathBuf::from("./store.sqlite3");

    // Initialize client to connect with the Miden Testnet.
    // NOTE: The client is our entry point to the Miden network.
    // All interactions with the network go through the client.
    let mut client = ClientBuilder::new()
        .rpc(rpc_client)
        .sqlite_store(store_path)
        .authenticator(keystore.clone().into())
        .in_debug_mode(true.into())
        .build()
        .await?;

    client.sync_state().await?;

    //------------------------------------------------------------
    // CREATING A FAUCET AND MINTING TOKENS
    //------------------------------------------------------------

    // Faucet seed
    let mut init_seed = [0u8; 32];
    client.rng().fill_bytes(&mut init_seed);

    // Faucet parameters
    let symbol = TokenSymbol::new("TEST")?;
    let decimals = 8;
    let max_supply = Felt::new(1_000_000);

    // Generate key pair
    let alice_key_pair = SecretKey::with_rng(client.rng());
    let faucet_key_pair = SecretKey::with_rng(client.rng());

    // Build the account
    let account_builder = AccountBuilder::new(init_seed)
        .account_type(AccountType::RegularAccountUpdatableCode)
        .storage_mode(AccountStorageMode::Public)
        .with_auth_component(AuthRpoFalcon512::new(
            alice_key_pair.public_key().to_commitment().into(),
        ))
        .with_component(BasicWallet);

    // Build the faucet
    let faucet_builder = AccountBuilder::new(init_seed)
        .account_type(AccountType::FungibleFaucet)
        .storage_mode(AccountStorageMode::Public)
        .with_auth_component(AuthRpoFalcon512::new(
            faucet_key_pair.public_key().to_commitment().into(),
        ))
        .with_component(BasicFungibleFaucet::new(symbol, decimals, max_supply)?);

    let alice_account = account_builder.build()?;
    let faucet_account = faucet_builder.build()?;

    println!("Alice's account ID: {:?}", alice_account.id().to_hex());
    println!("Faucet account ID: {:?}", faucet_account.id().to_hex());

    // Add accounts to client
    client.add_account(&alice_account, false).await?;
    client.add_account(&faucet_account, false).await?;

    // Add keys to keystore
    keystore.add_key(&AuthSecretKey::RpoFalcon512(alice_key_pair))?;
    keystore.add_key(&AuthSecretKey::RpoFalcon512(faucet_key_pair))?;

    let amount: u64 = 1000;
    let fungible_asset = FungibleAsset::new(faucet_account.id(), amount)?;

    // Build transaction request to mint fungible asset to Alice's account
    // NOTE: This transaction will create a P2ID note (a Miden note containing the minted asset)
    // for Alice's account. Alice will be able to consume these notes to get the fungible asset in her vault
    let transaction_request = TransactionRequestBuilder::new().build_mint_fungible_asset(
        fungible_asset,
        alice_account.id(),
        NoteType::Public,
        client.rng(),
    )?;

    // Create transaction and submit it to create P2ID notes for Alice's account
    let tx_id = client
        .submit_new_transaction(faucet_account.id(), transaction_request)
        .await?;
    client.sync_state().await?;

    println!(
        "Mint transaction submitted successfully, ID: {:?}",
        tx_id.to_hex()
    );

    //------------------------------------------------------------
    // CONSUMING P2ID NOTES
    //------------------------------------------------------------

    loop {
        // Sync state to get the latest block
        client.sync_state().await?;

        let consumable_notes = client
            .get_consumable_notes(Some(alice_account.id()))
            .await?;
        let note_ids = consumable_notes
            .iter()
            .map(|(note, _)| note.id())
            .collect::<Vec<_>>();

        if note_ids.len() == 0 {
            println!("Waiting for P2ID note to be comitted...");
            tokio::time::sleep(Duration::from_secs(2)).await;
            continue;
        }

        let consume_tx_request = TransactionRequestBuilder::new().build_consume_notes(note_ids)?;

        // Create transaction and submit it to consume notes
        let consume_tx_id = client
            .submit_new_transaction(alice_account.id(), consume_tx_request)
            .await?;

        println!(
            "Consume transaction submitted successfully, ID: {:?}",
            consume_tx_id.to_hex()
        );

        client.sync_state().await?;

        let alice_account_record = client
            .get_account(alice_account.id())
            .await?
            .ok_or_else(|| anyhow::anyhow!("Account not found"))?;
        let alice_account = alice_account_record.account().clone();
        let vault = alice_account.vault();
        println!(
            "Alice's TEST token balance: {:?}",
            vault.get_balance(faucet_account.id())
        );

        break; // Exit the loop after consuming the note
    }

    //------------------------------------------------------------
    // SENDING TOKENS TO BOB
    //------------------------------------------------------------

    let bob_account_id = AccountId::from_hex("0x599a54603f0cf9000000ed7a11e379")?;
    let send_amount = 100;
    let fungible_asset_to_send = FungibleAsset::new(faucet_account.id(), send_amount)?;

    let p2id_note = create_p2id_note(
        alice_account.id(),
        bob_account_id,
        vec![fungible_asset_to_send.into()],
        NoteType::Public,
        Felt::new(0),
        client.rng(),
    )?;

    // Create transaction request to send P2ID note to Bob
    let send_p2id_note_transaction_request = TransactionRequestBuilder::new()
        .own_output_notes(vec![OutputNote::Full(p2id_note)])
        .build()?;

    // Create transaction and submit it to send P2ID note to Bob
    let send_p2id_note_tx_id = client
        .submit_new_transaction(alice_account.id(), send_p2id_note_transaction_request)
        .await?;
    client.sync_state().await?;

    println!(
        "Send 100 tokens to Bob note transaction ID: {:?}",
        send_p2id_note_tx_id.to_hex()
    );

    Ok(())
}
`},
  typescript: {
    code:`import {
    WebClient,
    AccountStorageMode,
    NoteType,
    ConsumableNoteRecord,
    AccountId,
} from "@demox-labs/miden-sdk";

export async function demo() {
    // Initialize client to connect with the Miden Testnet.
    // NOTE: The client is our entry point to the Miden network.
    // All interactions with the network go through the client.
    const nodeEndpoint = "https://rpc.testnet.miden.io:443";

    // Initialize client
    const client = await WebClient.createClient(nodeEndpoint);
    await client.syncState();

    // Creating Alice's account
    const alice = await client.newWallet(AccountStorageMode.public(), true);
    console.log("Alice's account ID:", alice.id().toString());

    // Creating a faucet account
    const symbol = "TEST";
    const decimals = 8;
    const initialSupply = BigInt(10_000_000 * 10 ** decimals);
    const faucet = await client.newFaucet(
        AccountStorageMode.public(), // Public: account state is visible on-chain
        false, // Mutable: account code cannot be upgraded later
        symbol, // Symbol of the token
        decimals, // Number of decimals
        initialSupply // Initial supply of tokens
    );
    console.log("Faucet account ID:", faucet.id().toString());

    // Create transaction request to mint fungible asset to Alice's account
    // NOTE: This transaction will create a P2ID note (a Miden note containing the minted asset)
    // for Alice's account. Alice will be able to consume these notes to get the fungible asset in her vault
    console.log("Minting 1000 tokens to Alice...");
    const mintTxRequest = client.newMintTransactionRequest(
        alice.id(), // Target account (who receives the tokens)
        faucet.id(), // Faucet account (who mints the tokens)
        NoteType.Public, // Note visibility (public = on-chain)
        BigInt(1000) // Amount to mint (in base units)
    );
    const mintTxId = await client.submitNewTransaction(
        faucet.id(),
        mintTxRequest
    );

    console.log("Mint transaction submitted successfully, ID:", mintTxId.toHex());

    await client.syncState();

    let consumableNotes: ConsumableNoteRecord[] = [];
    while (consumableNotes.length === 0) {
        // Find consumable notes
        consumableNotes = await client.getConsumableNotes(alice.id());

        console.log("Waiting for note to be consumable...");
        await new Promise((resolve) => setTimeout(resolve, 3000));
    }

    const noteIds = consumableNotes.map((note) =>
        note.inputNoteRecord().id().toString()
    );

    // Create transaction request to consume notes
    // NOTE: This transaction will consume the notes and add the fungible asset to Alice's vault
    const consumeTxRequest = client.newConsumeTransactionRequest(noteIds);
    const consumeTxId = await client.submitNewTransaction(
        alice.id(),
        consumeTxRequest
    );
    console.log(
        "Consume transaction submitted successfully, ID:",
        consumeTxId.toHex()
    );

    console.log(
        "Alice's TEST token balance:",
        Number(alice.vault().getBalance(faucet.id()))
    );

    await client.syncState();

    // Send tokens from Alice to Bob
    const bobAccountId = "0x599a54603f0cf9000000ed7a11e379";
    console.log("Sending 100 tokens to Bob...");

    // Build transaction request to send tokens from Alice to Bob
    const sendTxRequest = client.newSendTransactionRequest(
        alice.id(), // Sender account
        AccountId.fromHex(bobAccountId), // Recipient account
        faucet.id(), // Asset ID (faucet that created the tokens)
        NoteType.Public, // Note visibility
        BigInt(100) // Amount to send
    );

    const sendTxId = await client.submitNewTransaction(alice.id(), sendTxRequest);
    console.log("Send transaction submitted successfully, ID:", sendTxId.toHex());

    await client.syncState();
}
`
}
}}
/>

<details>
<summary>Expected output</summary>

```text
Alice's account ID: 0xd6b8bb0ed10b1610282c513501778a
Faucet account ID: 0xe48c43d6ad6496201bcfa585a5a4b6
Minting 1000 tokens to Alice...
Mint transaction submitted successfully, ID: 0x948a0eef754068b3126dd3261b6b54214fa5608fb13c5e5953faf59bad79c75f
Consume transaction submitted successfully, ID: 0xc69ab84b784120abe858bb536aebda90bd2067695f11d5da93ab0b704f39ad78
Alice's TEST token balance: 100
Send 100 tokens to Bob note transaction ID: "0x51ac27474ade3a54adadd50db6c2b9a2ede254c5f9137f93d7a970f0bc7d66d5"
```

</details>

## Key Takeaways

**Miden's Note-Based Transaction Model:**

- **Notes** enable private asset transfers between accounts
- **Two-transaction model** provides privacy and parallelization benefits
- **Zero-knowledge proofs** validate transaction execution without revealing details
- **P2ID notes** target specific recipients using their account IDs

**Transaction Flow:**

1. **Mint** tokens to create notes containing assets
2. **Consume** notes to add assets to account vaults
3. **Send** tokens using P2ID notes targeted to recipients
4. **Nullify** consumed notes to prevent double-spending

This innovative approach provides unprecedented privacy and flexibility while maintaining the security guarantees of blockchain technology. The note-based model enables scalable, private transactions that can be processed in parallel without global state synchronization.

---
````

## File: docs/builder/quick-start/read-storage.md
````markdown
---
sidebar_position: 4
title: Read Storage Values
description: Learn how to query account storage data and interact with deployed smart contracts.
---

import { CodeTabs } from '@site/src/components';

# Read Storage Values

Let's explore how to interact with public accounts and retrieve their storage data.

## Understanding Account Storage

Miden accounts contain several types of data you can read.

**Account Components:**

- **Vault**: Contains the account's assets (tokens)
- **Storage**: Key-value data store with up to 255 slots
- **Code**: The account's smart contract logic (MAST root)
- **Nonce**: Nonce that increments with each state change to prevent double spend

**Storage Visibility:**

- **Public accounts**: All data is publicly accessible and can be read by anyone
- **Private accounts**: Only commitments are public; full data is held privately

## Set Up Development Environment

To run the code examples in this guide, you'll need to set up a development environment. If you haven't already, follow the setup instructions in the [Accounts](./accounts#set-up-development-environment) guide.

## Reading from a Public Smart Contract

Let's interact with a counter contract deployed on the Miden testnet. This contract maintains a simple counter value in its storage at storage slot `0`.

### Reading the Count of a Counter contract

<CodeTabs
tsFilename="src/lib/read-count.ts"
rustFilename="integration/src/bin/read-count.rs"
example={{
rust: {
code: `use miden_client::{
    account::AccountId,
    builder::ClientBuilder,
    keystore::FilesystemKeyStore,
    rpc::{Endpoint, GrpcClient},
};
use miden_client_sqlite_store::ClientBuilderSqliteExt;
use std::sync::Arc;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Initialize RPC connection
    let endpoint = Endpoint::testnet();
    let timeout_ms = 10_000;
    let rpc_client = Arc::new(GrpcClient::new(&endpoint, timeout_ms));

    // Initialize keystore
    let keystore_path = std::path::PathBuf::from("./keystore");
    let keystore: FilesystemKeyStore<rand::prelude::StdRng> =
        FilesystemKeyStore::new(keystore_path).unwrap().into();

    let store_path = std::path::PathBuf::from("./store.sqlite3");

    // Initialize client to connect with the Miden Testnet.
    // NOTE: The client is our entry point to the Miden network.
    // All interactions with the network go through the client.
    let mut client = ClientBuilder::new()
        .rpc(rpc_client)
        .sqlite_store(store_path)
        .authenticator(keystore.clone().into())
        .in_debug_mode(true.into())
        .build()
        .await?;

    client.sync_state().await?;

    //------------------------------------------------------------
    // READ PUBLIC STATE OF THE COUNTER ACCOUNT
    //------------------------------------------------------------

    let counter_account_id = AccountId::from_hex("0xe59d8cd3c9ff2a0055da0b83ed6432")?;

    client.import_account_by_id(counter_account_id).await?;

    let counter_account = client
        .get_account(counter_account_id)
        .await?
        .ok_or_else(|| anyhow::anyhow!("Account not found"))?;

    println!(
        "Count: {:?}",
        counter_account
            .account()
            .storage()
            .slots()
            .first()
            .ok_or_else(|| anyhow::anyhow!("No storage slots found"))?
    );

    Ok(())
}
` },
  typescript: {
    code:`import { WebClient, AccountId } from "@demox-labs/miden-sdk";

export async function demo() {
    // Initialize client to connect with the Miden Testnet.
    // NOTE: The client is our entry point to the Miden network.
    // All interactions with the network go through the client.
    const nodeEndpoint = "https://rpc.testnet.miden.io:443";

    // Initialize client
    const client = await WebClient.createClient(nodeEndpoint);
    await client.syncState();

    const accountId = AccountId.fromHex("0xe59d8cd3c9ff2a0055da0b83ed6432");

    // Import the account into the client's database
    let account = await client.getAccount(accountId);
    if (account === undefined) {
        account = await client.getAccount(accountId);
    }

    // Define counter account instance
    const counter = await client.getAccount(accountId);

    // Get the count from the counter account by querying the first
    // storage slot.
    const count = counter?.storage().getItem(0);

    // Convert the 4th value of the WORD Storage value to a number.
    // NOTE: The WORD Storage value is an array of 4 values, each of which is a 64-bit unsigned integer.
    // NOTE: The 4th value is the u64 number of the counter.
    console.log("Count:", Number(count?.toU64s()[3]));
}
`
}
}}
/>

<details>
<summary>Expected output</summary>

```text
Count: 43
```

</details>

## Reading Account Token Balances

You can also query the assets (tokens) held by an account:

<CodeTabs
tsFilename="src/lib/token-balance.ts"
rustFilename="integration/src/bin/token-balance.rs"
example={{
rust: {
code: `use miden_client::{
    account::AccountId,
    builder::ClientBuilder,
    keystore::FilesystemKeyStore,
    rpc::{Endpoint, GrpcClient},
};
use miden_client_sqlite_store::ClientBuilderSqliteExt;
use std::sync::Arc;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Initialize RPC connection
    let endpoint = Endpoint::testnet();
    let timeout_ms = 10_000;
    let rpc_client = Arc::new(GrpcClient::new(&endpoint, timeout_ms));

    // Initialize keystore
    let keystore_path = std::path::PathBuf::from("./keystore");
    let keystore: FilesystemKeyStore<rand::prelude::StdRng> =
        FilesystemKeyStore::new(keystore_path).unwrap().into();

    let store_path = std::path::PathBuf::from("./store.sqlite3");

    // Initialize client to connect with the Miden Testnet.
    // NOTE: The client is our entry point to the Miden network.
    // All interactions with the network go through the client.
    let mut client = ClientBuilder::new()
        .rpc(rpc_client)
        .sqlite_store(store_path)
        .authenticator(keystore.clone().into())
        .in_debug_mode(true.into())
        .build()
        .await?;

    client.sync_state().await?;

    //------------------------------------------------------------
    // READ TOKEN BALANCE OF AN ACCOUNT
    //------------------------------------------------------------

    let alice_account_id = AccountId::from_hex("0x49e27aa5fa5686102fde8e81b89999")?;
    let faucet_account_id = AccountId::from_hex("0x9796be9c72f137206676f7821a9968")?;

    client.import_account_by_id(alice_account_id).await?;

    let alice_account = client
        .get_account(alice_account_id)
        .await?
        .ok_or_else(|| anyhow::anyhow!("Account not found"))?;

    let balance = alice_account
        .account()
        .vault()
        .get_balance(faucet_account_id)?;

    println!("Alice's TEST token balance: {:?}", balance);

    Ok(())
}
`},
  typescript: {
    code:`import { WebClient, AccountId } from "@demox-labs/miden-sdk";

export async function demo() {
    // Initialize client to connect with the Miden Testnet.
    // NOTE: The client is our entry point to the Miden network.
    // All interactions with the network go through the client.
    const nodeEndpoint = "https://rpc.testnet.miden.io:443";

    // Initialize client
    const client = await WebClient.createClient(nodeEndpoint);
    await client.syncState();

    const aliceId = AccountId.fromHex("0x49e27aa5fa5686102fde8e81b89999");
    const faucetId = AccountId.fromHex("0x9796be9c72f137206676f7821a9968");

    // Import the account into the client's database
    let aliceAccount = await client.getAccount(aliceId);
    if (aliceAccount === undefined) {
        await client.importAccountById(aliceId);
        aliceAccount = await client.getAccount(aliceId);
    }

    const balance = aliceAccount?.vault().getBalance(faucetId);
    console.log("Alice's TEST token balance:", Number(balance));
}
`
}
}}
/>

<details>
<summary>Expected output</summary>

```text
Alice's TEST token balance: 900
```

</details>

---
````

## File: docs/builder/tools/_category_.json
````json
{
  "label": "Tools",
  "position": 5
}
````

## File: docs/builder/faq.md
````markdown
# FAQ

## How is privacy implemented in Miden?

Miden leverages zero-knowledge proofs and client side execution and proving to provide security and privacy.

## Does Miden support encrypted notes?

At the moment, Miden does not have support for encrypted notes but it is a planned feature.

## Why does Miden have delegated proving?

Miden leverages delegated proving for a few technical and practical reasons:

1. **Computational:** Generating zero-knowledge proofs is a computationally intensive work. The proving process requires significant processing power and memory, making it impractical for some end-user devices (like smartphones) to generate.
2. **Technical architecture**:
Miden's architecture separates concerns between:
    - **Transaction Creation**: End users create and sign transactions
    - **Proof Generation**: Specialized provers generate validity proofs
    - **Verification**: The network verifies these proofs
3. **Proving efficiency**:
Delegated provers can use optimized hardware that wouldn't be available to end-user devices, specifically designed for the mathematical operations needed in STARK proof generation.

## What is the lifecycle of a transaction?

### 1. Transaction Creation

- User creates a transaction specifying the operations to perform (transfers, contract interactions, etc.)
- Client performs preliminary validation of the transaction and its structure
- The user authorizes the specified state transitions by signing the transaction

### 2. Transaction Submission

- The signed transaction is submitted to Miden network nodes
- The transaction enters the mempool (transaction pool) where it waits to be selected to be included in the state
- Nodes perform basic validation checks on the transaction structure and signature

### 3. Transaction Selection

- A sequencer (or multiple sequencers in a decentralized setting) selects transactions from the mempool
- The sequencer groups transactions into bundles based on state access patterns and other criteria
- The transaction execution order is determined according to protocol mechanism

### 4. Transaction Execution

- The current state relevant to the transaction is loaded
- The Miden VM executes the transaction operations
- **State Transition Computation**: The resulting state transitions are computed
- An execution trace of the transaction is generated which captures all the computation

### 5. Proof Generation

- A STARK based cryptographic proof is generated attesting to the correctness of the execution
- A proof for the aggregated transaction is created

### 6. Block Production

- The aggregated bundle of transactions along with their proofs are assembled into a block
- A recursive proof attesting to all bundle proofs is generated
- The block data structure is finalized with the aggregated proof

### 7. L1 Submission

- Transaction data is posted to the data availability layer
- The block proof and state delta commitment are submitted to the Miden contract (that is bridged to Ethereum/Agglayer)
- The L1 contract verifies validity of the proof
- Upon successful verification, the L1 contract updates the state root

### 8. Finalization

- Transaction receipts and events are generated
- The global state commitment is updated to reflect the new state
- The transaction is now considered finalized on the L1
- Users and indexers get notified/updated about the transaction completion

## Do notes in Miden support recency conditions?

Yes, Miden enables consumption of notes based on time conditions, such as:

- A specific block height being reached
- A timestamp threshold being passed
- An oracle providing specific data
- Another transaction being confirmed

## What does a Miden operator do in Miden?

A Miden operator is an entity that maintains the infrastructure necessary for the functioning of the Miden rollup. Their roles may involve:

1. Running Sequencer Nodes
2. Operating the Prover Infrastructure
3. Submitting Proofs to L1
4. Maintaining Data Availability
5. Participating in the Consensus Mechanism

## How does bridging works in Miden?

Miden does not yet have a fully operational bridge, work in progress.

## What does the gas fee model of Miden look like?

Miden does not yet have a fully implemented fee model, work in progress.
````

## File: docs/builder/glossary.md
````markdown
# Glossary

## Account

An account is a data structure that represents an entity (user account, smart contract) of the Miden blockchain, they are analogous to smart contracts.

## Account builder

Account builder provides a structured way to create and initialize new accounts on the Miden network with specific properties, permissions, and initial state.

## AccountCode

Represents the executable code associated with an account.

## AccountComponent

An AccountComponent can be described as a modular unit of code to represent the functionality of a Miden Account. Each AccountCode is composed of multiple AccountComponent's.

## AccountId

The AccountId is a value that uniquely identifies each account in Miden.

## AccountIdVersion

The AccountIdVersion represents the different versions of account identifier formats supported by Miden.

## AccountStorage

The AccountStorage is a key-value store associated with an account. It is made up of storage slots.

## Asset

An Asset represents a digital resource with value that can be owned, transferred, and managed within the Miden blockchain.

## AssetVault

The AssetVault is used for managing assets within accounts. It provides a way for storing and transfering assets associated with each account.

## Batch

A Batch allows multiple transactions to be grouped together, these batches will then be aggregated into blocks, improving network throughput.

## Block

A Block is a fundamental data structure which groups multiple batches together and forms the blockchain's state.

## Delta

A Delta represents the changes between two states `s` and `s'`. Applying a Delta `d` to `s` would result in `s'`.

## Felt

A Felt or Field Element is a data type used for cryptographic operations. It represents an element in the finite field used in Miden.

## Kernel

A fundamental module of the MidenVM that acts as a base layer by providing core functionality and security guarantees for the protocol.

## Miden Assembly

An assembly language specifically designed for the Miden VM. It's a low-level programming language with specialized instructions optimized for zero-knowledge proof generation.

## Note

A Note is a fundamental data structure that represents an offchain asset or a piece of information that can be transferred between accounts. Miden's UTXO-like (Unspent Transaction Output) model is designed around the concept of notes. There are output notes which are new notes created by the transaction and input notes which are consumed (spent) by the transaction.

## Note script

A Note script is a program that defines the rules and conditions under which a note can be consumed.

## Note tag

A Note tag is an identifier or metadata associated with notes that provide additional filtering capabilities.

## Note ID

Note ID is a unique identifier assigned to each note to distinguish it from other notes.

## Nullifier

A nullifier is a cryptographic commitment that marks a note as spent, preventing it from being consumed again.

## Prover

A Prover is responsible for generating zero-knowledge proofs that attest to the correctness of the execution of a program without revealing the underlying data.

## Word

A Word is a data structure that represents the basic unit of computation and storage in Miden, it is composed or four Felt's.
````

## File: docs/builder/develop/tutorials/rust-compiler/miden-bank/01-account-components.md
````markdown
---
sidebar_position: 1
title: "Part 1: Account Components and Storage"
description: "Learn how to define account components with the #[component] attribute and manage persistent state using Value and StorageMap storage types."
---

# Part 1: Account Components and Storage

In this section, you'll learn the fundamentals of building Miden account components. We'll expand our Bank to include balance tracking with a `StorageMap`, giving us the foundation for deposits and withdrawals.

## What You'll Build in This Part

By the end of this section, you will have:

- Understood the `#[component]` attribute and what it generates
- Added a `StorageMap` for tracking depositor balances
- Implemented a `get_balance()` query method
- **Verified it works** with a MockChain test

## Building on Part 0

In Part 0, we created a minimal bank with just an `initialized` flag. Now we'll add balance tracking:

```text
Part 0:                          Part 1:
┌────────────────────┐             ┌────────────────────┐
│ Bank               │             │ Bank               │
│ ─────────────────  │    ──►      │ ─────────────────  │
│ slot 0: initialized│             │ slot 0: initialized│
│                    │             │ slot 1: balances   │ ◄── NEW
└────────────────────┘             └────────────────────┘
```

## The #[component] Attribute

The `#[component]` attribute marks a struct as a Miden account component. When you compile with `miden build`, it generates:

- **WIT (WebAssembly Interface Types)** bindings for cross-component calls
- **MASM (Miden Assembly)** code for the account logic
- **Storage slot management** code

Let's expand our Bank component:

## Step 1: Add the Balances Storage Map

Update `contracts/bank-account/src/lib.rs`:

```rust title="contracts/bank-account/src/lib.rs" {17-20}
#![no_std]
#![feature(alloc_error_handler)]

#[macro_use]
extern crate alloc;

use miden::*;

/// Bank account component that tracks depositor balances.
#[component]
struct Bank {
    /// Tracks whether the bank has been initialized (deposits enabled).
    /// Word layout: [is_initialized (0 or 1), 0, 0, 0]
    #[storage(slot(0), description = "initialized")]
    initialized: Value,

    /// Maps depositor AccountId -> balance (as Felt)
    /// Key: [prefix, suffix, asset_prefix, asset_suffix]
    #[storage(slot(1), description = "balances")]
    balances: StorageMap,
}
```

We've added a `StorageMap` in slot 1 that will track each depositor's balance.

## Storage Types Explained

Miden accounts have storage slots that persist state on-chain. Each slot holds one `Word` (4 Felts = 32 bytes). The Miden Rust compiler provides two abstractions:

### Value Storage

The `Value` type provides access to a single storage slot:

```rust
#[storage(slot(0), description = "initialized")]
initialized: Value,
```

Use `Value` when you need to store a single `Word` of data.

**Reading and writing:**

```rust
// Read returns a Word
let current: Word = self.initialized.read();

// Check the first element (our flag)
if current[0].as_u64() == 0 {
    // Not initialized
}

// Write a new value
let new_value = Word::from([felt!(1), felt!(0), felt!(0), felt!(0)]);
self.initialized.write(new_value);
```

:::tip Type Annotations
The `.read()` method requires a type annotation: `let current: Word = self.initialized.read();`
:::

### StorageMap

The `StorageMap` type provides key-value storage within a slot:

```rust
#[storage(slot(1), description = "balances")]
balances: StorageMap,
```

Use `StorageMap` when you need to store multiple values indexed by keys.

**Reading and writing:**

```rust
// Create a key (must be a Word)
let key = Word::from([
    depositor.prefix,
    depositor.suffix,
    felt!(0),
    felt!(0),
]);

// Get returns a Felt (single value, not a Word)
let balance: Felt = self.balances.get(&key);

// Set stores a Felt at the key
let new_balance = balance + deposit_amount;
self.balances.set(key, new_balance);
```

:::warning StorageMap Returns Felt
Unlike `Value::read()` which returns a `Word`, `StorageMap::get()` returns a single `Felt`. This is an important distinction.
:::

### Storage Slot Layout

Plan your storage layout carefully:

| Slot | Type | Purpose |
|------|------|---------|
| 0 | `Value` | Initialization flag |
| 1 | `StorageMap` | Depositor balances |

The `description` attribute is for documentation and debugging - it doesn't affect runtime behavior.

## Step 2: Implement Component Methods

Now let's add methods to our Bank. The `#[component]` attribute is also used on the `impl` block:

```rust title="contracts/bank-account/src/lib.rs"
#[component]
impl Bank {
    /// Initialize the bank account, enabling deposits.
    pub fn initialize(&mut self) {
        // Read current value from storage
        let current: Word = self.initialized.read();

        // Check not already initialized
        assert!(
            current[0].as_u64() == 0,
            "Bank already initialized"
        );

        // Set initialized flag to 1
        let initialized_word = Word::from([felt!(1), felt!(0), felt!(0), felt!(0)]);
        self.initialized.write(initialized_word);
    }

    /// Get the balance for a depositor.
    pub fn get_balance(&self, depositor: AccountId) -> Felt {
        let key = Word::from([depositor.prefix, depositor.suffix, felt!(0), felt!(0)]);
        self.balances.get(&key)
    }

    /// Check that the bank is initialized.
    fn require_initialized(&self) {
        let current: Word = self.initialized.read();
        assert!(
            current[0].as_u64() == 1,
            "Bank not initialized - deposits not enabled"
        );
    }
}
```

### Public vs Private Methods

- **Public methods** (`pub fn`) are exposed in the generated WIT interface and can be called by other contracts
- **Private methods** (`fn`) are internal and cannot be called from outside

```rust
// Public: Can be called by note scripts and other contracts
pub fn get_balance(&self, depositor: AccountId) -> Felt { ... }

// Private: Internal helper, not exposed
fn require_initialized(&self) { ... }
```

## Step 3: Build the Component

Build your updated account component:

```bash title=">_ Terminal"
cd contracts/bank-account
miden build
```

This compiles the Rust code to Miden Assembly and generates:

- `target/miden/release/bank_account.masp` - The compiled package
- `target/generated-wit/` - WIT interface files for other contracts to use

## Try It: Verify Your Code

Let's write a MockChain test to verify our Bank component works correctly. This test will:
1. Create a bank account
2. Initialize it
3. Verify the storage was updated

Create a new test file:

```rust title="integration/tests/part1_account_test.rs"
use integration::helpers::{
    build_project_in_dir, create_testing_account_from_package, AccountCreationConfig,
};
use miden_client::account::{StorageMap, StorageSlot};
use miden_client::{Felt, Word};
use std::{path::Path, sync::Arc};

#[tokio::test]
async fn test_bank_account_storage() -> anyhow::Result<()> {
    // =========================================================================
    // SETUP: Build contracts and create the bank account
    // =========================================================================

    // Build the bank account contract
    let bank_package = Arc::new(build_project_in_dir(
        Path::new("../contracts/bank-account"),
        true,
    )?);

    // Create the bank account with storage slots
    let bank_cfg = AccountCreationConfig {
        storage_slots: vec![
            // Slot 0: initialized flag (starts as 0)
            StorageSlot::Value(Word::default()),
            // Slot 1: balances map (empty)
            StorageSlot::Map(StorageMap::with_entries([])?),
        ],
        ..Default::default()
    };

    let bank_account =
        create_testing_account_from_package(bank_package.clone(), bank_cfg).await?;

    // =========================================================================
    // VERIFY: Check initial storage state
    // =========================================================================

    // Verify slot 0 (initialized) starts as 0
    let initialized_value = bank_account.storage().get_item(0)?;
    assert_eq!(
        initialized_value,
        Word::default(),
        "Initialized flag should start as 0"
    );

    println!("Bank account created successfully!");
    println!("  Account ID: {:?}", bank_account.id());
    println!("  Initialized flag: {:?}", initialized_value[0].as_int());

    // =========================================================================
    // VERIFY: Storage slots are correctly configured
    // =========================================================================

    // Check that we can query the balances map (should return 0 for any key)
    let test_key = Word::from([Felt::new(1), Felt::new(2), Felt::new(0), Felt::new(0)]);
    let balance = bank_account.storage().get_map_item(1, test_key)?;

    // Balance for non-existent depositor should be all zeros
    assert_eq!(
        balance,
        Word::default(),
        "Balance for unknown depositor should be zero"
    );

    println!("  Balances map accessible: Yes");
    println!("\nPart 1 test passed!");

    Ok(())
}
```

Run the test from the project root:

```bash title=">_ Terminal"
cargo test --package integration part1_account_test -- --nocapture
```

<details>
<summary>Expected output</summary>

```text
   Compiling integration v0.1.0 (/path/to/miden-bank/integration)
    Finished `test` profile [unoptimized + debuginfo] target(s)
     Running tests/part1_account_test.rs

running 1 test
Bank account created successfully!
  Account ID: 0x...
  Initialized flag: 0
  Balances map accessible: Yes

Part 1 test passed!
test test_bank_account_storage ... ok

test result: ok. 1 passed; 0 failed; 0 ignored
```

</details>

:::tip Troubleshooting
**"cannot find function `build_project_in_dir`"**: Make sure your `integration/src/helpers.rs` exports this function and `integration/src/lib.rs` has `pub mod helpers;`.

**"StorageSlot::Map not found"**: Ensure you're using the correct imports: `use miden_client::account::StorageSlot;`
:::

## Complete Code for This Part

Here's the full `lib.rs` after Part 1:

<details>
<summary>Click to expand full code</summary>

```rust title="contracts/bank-account/src/lib.rs"
#![no_std]
#![feature(alloc_error_handler)]

#[macro_use]
extern crate alloc;

use miden::*;

/// Bank account component that tracks depositor balances.
#[component]
struct Bank {
    /// Tracks whether the bank has been initialized (deposits enabled).
    /// Word layout: [is_initialized (0 or 1), 0, 0, 0]
    #[storage(slot(0), description = "initialized")]
    initialized: Value,

    /// Maps depositor AccountId -> balance (as Felt)
    /// Key: [prefix, suffix, asset_prefix, asset_suffix]
    #[storage(slot(1), description = "balances")]
    balances: StorageMap,
}

#[component]
impl Bank {
    /// Initialize the bank account, enabling deposits.
    pub fn initialize(&mut self) {
        // Read current value from storage
        let current: Word = self.initialized.read();

        // Check not already initialized
        assert!(
            current[0].as_u64() == 0,
            "Bank already initialized"
        );

        // Set initialized flag to 1
        let initialized_word = Word::from([felt!(1), felt!(0), felt!(0), felt!(0)]);
        self.initialized.write(initialized_word);
    }

    /// Get the balance for a depositor.
    pub fn get_balance(&self, depositor: AccountId) -> Felt {
        let key = Word::from([depositor.prefix, depositor.suffix, felt!(0), felt!(0)]);
        self.balances.get(&key)
    }

    /// Check that the bank is initialized.
    fn require_initialized(&self) {
        let current: Word = self.initialized.read();
        assert!(
            current[0].as_u64() == 1,
            "Bank not initialized - deposits not enabled"
        );
    }
}
```

</details>

## Key Takeaways

1. **`#[component]`** marks structs and impl blocks as Miden account components
2. **`Value`** stores a single Word, read with `.read()`, write with `.write()`
3. **`StorageMap`** stores key-value pairs, access with `.get()` and `.set()`
4. **Storage slots** are numbered from 0, each holds 4 Felts (32 bytes)
5. **Public methods** are callable by other contracts via generated bindings

:::tip View Complete Source
See the complete bank account implementation in the [miden-bank repository](https://github.com/keinberger/miden-bank/blob/main/contracts/bank-account/src/lib.rs).
:::

## Next Steps

Now that you understand account components and storage, let's learn how to define business rules with [Part 2: Constants and Constraints](./02-constants-constraints).
````

## File: docs/builder/develop/tutorials/rust-compiler/miden-bank/05-cross-component-calls.md
````markdown
---
sidebar_position: 5
title: "Part 5: Cross-Component Calls"
description: "Learn how note scripts and transaction scripts call account component methods using generated bindings and proper dependency configuration."
---

# Part 5: Cross-Component Calls

In this section, you'll learn how note scripts call methods on account components. We'll explore the generated bindings system and the dependency configuration that makes the deposit note work.

## What You'll Learn in This Part

By the end of this section, you will have:

- Understood how bindings are generated and imported
- Learned the dependency configuration in `Cargo.toml`
- Explored the WIT interface files
- **Verified cross-component calls work** via the deposit flow

## Building on Part 4

In Part 4, you wrote `bank_account::deposit(depositor, asset)` in the deposit note. But how does that call actually work? This part explains the binding system:

```text
┌────────────────────────────────────────────────────────────┐
│                  How Bindings Work                         │
├────────────────────────────────────────────────────────────┤
│                                                            │
│   bank-account/                                            │
│   └── src/lib.rs         miden build                       │
│       pub fn deposit()  ─────────────▶  generated-wit/     │
│       pub fn withdraw()                  miden_bank-account.wit
│                                                            │
│                              ┌───────────────────────────┐ │
│                              ▼                           │ │
│   deposit-note/                                          │ │
│   └── src/lib.rs                                         │ │
│       use crate::bindings::miden::bank_account::bank_account;
│       bank_account::deposit(...) ◄───── calls via binding │
│                                                            │
└────────────────────────────────────────────────────────────┘
```

## The Bindings System

When you build an account component with `miden build`, it generates:

1. **MASM code** - The compiled contract logic
2. **WIT files** - WebAssembly Interface Type definitions

Other contracts (note scripts, transaction scripts) import these WIT files to call the account's methods.

```text
Build Flow:
┌──────────────────┐    miden build    ┌─────────────────────────────────┐
│ bank-account/    │ ─────────────────▶│ target/generated-wit/           │
│  src/lib.rs      │                   │  miden_bank-account.wit         │
│                  │                   │  miden_bank-account_world.wit   │
└──────────────────┘                   └─────────────────────────────────┘
                                                      │
                                                      ▼
                                       ┌─────────────────────────────────┐
                                       │ deposit-note/                   │
                                       │  imports generated bindings     │
                                       └─────────────────────────────────┘
```

## Importing Bindings

In your note script, import the generated bindings:

```rust title="contracts/deposit-note/src/lib.rs"
// Import the bank account's generated bindings
use crate::bindings::miden::bank_account::bank_account;
```

The import path follows this pattern:
```
crate::bindings::{package-prefix}::{component-name}::{interface-name}
```

For our bank:
- `miden` - The package prefix from `[package.metadata.component]`
- `bank_account` - The component name (derived from package name with underscores)
- `bank_account` - The interface name (same as component)

## Calling Account Methods

Once imported, call the account methods directly:

```rust title="contracts/deposit-note/src/lib.rs"
#[note_script]
fn run(_arg: Word) {
    let depositor = active_note::get_sender();
    let assets = active_note::get_assets();

    for asset in assets {
        // Call the bank account's deposit method
        bank_account::deposit(depositor, asset);
    }
}
```

The binding automatically handles:
- Marshalling arguments across the component boundary
- Invoking the correct MASM procedures
- Returning results back to the caller

## Configuring Dependencies

Your `Cargo.toml` needs **two** dependency sections:

```toml title="contracts/deposit-note/Cargo.toml"
[package.metadata.miden.dependencies]
"miden:bank-account" = { path = "../bank-account" }

[package.metadata.component.target.dependencies]
"miden:bank-account" = { path = "../bank-account/target/generated-wit/" }
```

### miden.dependencies

```toml
[package.metadata.miden.dependencies]
"miden:bank-account" = { path = "../bank-account" }
```

This tells `cargo-miden` where to find the source package. Used during the build process to:
- Verify interface compatibility
- Link the compiled MASM code

### component.target.dependencies

```toml
[package.metadata.component.target.dependencies]
"miden:bank-account" = { path = "../bank-account/target/generated-wit/" }
```

This tells the Rust compiler where to find the WIT interface files. The path points to the `generated-wit/` directory created when you built the account component.

:::warning Both Sections Required
If either section is missing, your build will fail with linking or interface errors.
:::

## Build Order

Components must be built in dependency order:

```bash title=">_ Terminal"
# 1. Build the account component first
cd contracts/bank-account
miden build

# 2. Then build note scripts that depend on it
cd ../deposit-note
miden build
```

If you build out of order, you'll see errors about missing WIT files.

## What Methods Are Available?

Only **public methods** (`pub fn`) on the `#[component] impl` block are available through bindings:

```rust title="contracts/bank-account/src/lib.rs"
#[component]
impl Bank {
    // PUBLIC: Available through bindings
    pub fn deposit(&mut self, depositor: AccountId, deposit_asset: Asset) { ... }
    pub fn withdraw(&mut self, /* ... */) { ... }
    pub fn get_balance(&self, depositor: AccountId) -> Felt { ... }
    pub fn initialize(&mut self) { ... }

    // PRIVATE: NOT available through bindings
    fn require_initialized(&self) { ... }
    fn create_p2id_note(&mut self, /* ... */) { ... }
}
```

## Understanding the Generated WIT

The WIT files describe the interface. Here's a simplified example:

```wit title="target/generated-wit/miden_bank-account.wit"
interface bank-account {
    use miden:types/types.{account-id, asset, felt, word};

    initialize: func();
    deposit: func(depositor: account-id, deposit-asset: asset);
    withdraw: func(depositor: account-id, withdraw-asset: asset, ...);
    get-balance: func(depositor: account-id) -> felt;
}
```

This WIT is used to generate the Rust bindings that appear in `crate::bindings`.

## Transaction Script Bindings (Preview)

Transaction scripts use a slightly different import pattern:

```rust title="contracts/init-tx-script/src/lib.rs"
use crate::bindings::Account;

#[tx_script]
fn run(_arg: Word, account: &mut Account) {
    // The account parameter IS the bound component
    account.initialize();
}
```

The `Account` binding in transaction scripts wraps the entire component, giving direct method access through the `account` parameter. We'll implement this in Part 6.

## Try It: Verify Bindings Work

If you completed Part 4 and built both contracts, the bindings are already working! Let's verify:

```bash title=">_ Terminal"
# Check that the WIT files were generated
ls contracts/bank-account/target/generated-wit/
```

<details>
<summary>Expected output</summary>

```text
miden_bank-account.wit
miden_bank-account_world.wit
```

</details>

These files enable the deposit note to call `bank_account::deposit()`.

## Common Issues

### "Cannot find module" Error

```
error: cannot find module `bindings`
```

**Cause**: The account component wasn't built, or the WIT path is wrong.

**Solution**:
1. Build the account: `cd contracts/bank-account && miden build`
2. Verify the WIT path in `Cargo.toml` points to `target/generated-wit/`

### "Method not found" Error

```
error: no method named `deposit` found
```

**Cause**: The method isn't marked `pub` in the account component.

**Solution**: Ensure the method has `pub fn` visibility.

### "Dependency not found" Error

```
error: dependency 'miden:bank-account' not found
```

**Cause**: One of the dependency sections is missing or has the wrong path.

**Solution**: Ensure both `[package.metadata.miden.dependencies]` and `[package.metadata.component.target.dependencies]` are present with correct paths.

## Key Takeaways

1. **Build accounts first** - They generate WIT files that note scripts need
2. **Two dependency sections** - Both `miden.dependencies` and `component.target.dependencies` are required
3. **Import path pattern** - `crate::bindings::{package}::{component}::{interface}`
4. **Only public methods** - Private methods aren't exposed in bindings
5. **Transaction scripts differ** - They receive the account as a parameter (Part 6)

:::tip View Complete Source
See the complete Cargo.toml configurations:
- [Deposit Note Cargo.toml](https://github.com/keinberger/miden-bank/blob/main/contracts/deposit-note/Cargo.toml)
- [Withdraw Request Note Cargo.toml](https://github.com/keinberger/miden-bank/blob/main/contracts/withdraw-request-note/Cargo.toml)
:::

## Next Steps

Now that you understand cross-component calls, let's create the transaction script that initializes the bank in [Part 6: Transaction Scripts](./06-transaction-scripts).
````

## File: docs/builder/develop/tutorials/rust-compiler/miden-bank/06-transaction-scripts.md
````markdown
---
sidebar_position: 6
title: "Part 6: Transaction Scripts"
description: "Learn how to write transaction scripts for account initialization and owner-controlled operations using the #[tx_script] attribute."
---

# Part 6: Transaction Scripts

In this section, you'll learn how to write transaction scripts - code that the account owner explicitly executes. We'll implement an initialization script that enables the bank to accept deposits.

## What You'll Build in This Part

By the end of this section, you will have:

- Created the `init-tx-script` transaction script project
- Understood the `#[tx_script]` attribute and function signature
- Learned the difference between transaction scripts and note scripts
- **Verified initialization works** via a MockChain test

## Building on Part 5

In Parts 4-5, you created note scripts that execute when notes are consumed. Now you'll create a transaction script - code the account owner explicitly runs:

```text
┌────────────────────────────────────────────────────────────────┐
│                 Script Types Comparison                         │
├────────────────────────────────────────────────────────────────┤
│                                                                 │
│   Note Scripts (Parts 4-5)          Transaction Scripts (Part 6)│
│   ─────────────────────────         ────────────────────────────│
│   • Triggered by note consumption   • Explicitly called by owner│
│   • Import bindings via modules     • Receive account parameter │
│   • Process incoming assets         • Setup, admin operations   │
│                                                                 │
│   deposit-note/                     init-tx-script/             │
│   └── calls bank_account::deposit() └── calls account.initialize()
│                                                                 │
└────────────────────────────────────────────────────────────────┘
```

## Transaction Scripts vs Note Scripts

| Aspect | Transaction Script | Note Script |
|--------|-------------------|-------------|
| Initiation | Explicitly called by account owner | Triggered when note is consumed |
| Access | Direct account method access | Must call through bindings |
| Use case | Setup, owner operations | Receiving messages/assets |
| Parameter | `account: &mut Account` | Note context via `active_note::` |

**Use transaction scripts for:**
- One-time initialization
- Admin/owner operations
- Operations that don't involve receiving notes

**Use note scripts for:**
- Receiving assets from other accounts
- Processing requests from other accounts
- Multi-party interactions

## Step 1: Create the Transaction Script Project

Create a new directory for the transaction script:

```bash title=">_ Terminal"
mkdir -p contracts/init-tx-script/src
```

## Step 2: Configure Cargo.toml

Create the Cargo.toml with transaction script configuration:

```toml title="contracts/init-tx-script/Cargo.toml"
[package]
name = "init-tx-script"
version = "0.1.0"
edition = "2021"

[lib]
crate-type = ["cdylib"]

[dependencies]
miden = { workspace = true }

[package.metadata.component]
package = "miden:init-tx-script"

[package.metadata.miden]
project-kind = "transaction-script"

[package.metadata.miden.dependencies]
"miden:bank-account" = { path = "../bank-account" }

[package.metadata.component.target.dependencies]
"miden:bank-account" = { path = "../bank-account/target/generated-wit/" }
```

Key configuration:
- `project-kind = "transaction-script"` - Marks this as a transaction script (not "account" or "note")
- Dependencies reference the account component (same pattern as note scripts)

## Step 3: Add to Workspace

Update your root `Cargo.toml` to include the new project:

```toml title="Cargo.toml" {5}
[workspace]
resolver = "2"

members = [
    "contracts/bank-account",
    "contracts/deposit-note",
    "contracts/init-tx-script",  # Add this line
    "integration",
]

[workspace.dependencies]
miden = { version = "0.8" }
```

## Step 4: Implement the Transaction Script

Create the initialization script:

```rust title="contracts/init-tx-script/src/lib.rs"
// Do not link against libstd (i.e. anything defined in `std::`)
#![no_std]
#![feature(alloc_error_handler)]

use miden::*;

// Import the Account binding which wraps the bank-account component methods
use crate::bindings::Account;

/// Initialize Transaction Script
///
/// This transaction script initializes the bank account, enabling deposits.
/// It must be executed by the bank account owner before any deposits can be made.
///
/// # Flow
/// 1. Transaction is created with this script attached
/// 2. Script executes in the context of the bank account
/// 3. Calls `account.initialize()` to enable deposits
/// 4. Bank account is now "deployed" and visible on chain
#[tx_script]
fn run(_arg: Word, account: &mut Account) {
    account.initialize();
}
```

## The #[tx_script] Attribute

The `#[tx_script]` attribute marks the entry point for a transaction script:

```rust
#[tx_script]
fn run(_arg: Word, account: &mut Account) {
    account.initialize();
}
```

### Function Signature

| Parameter | Type | Description |
|-----------|------|-------------|
| `_arg` | `Word` | Optional argument passed when executing |
| `account` | `&mut Account` | Mutable reference to the account component |

The `Account` type is generated from your component's bindings and provides access to all public methods.

## The Account Binding

Unlike note scripts that import bindings like `bank_account::deposit()`, transaction scripts receive the account as a parameter:

```rust
// Note script style (indirect):
use crate::bindings::miden::bank_account::bank_account;
bank_account::deposit(depositor, asset);

// Transaction script style (direct):
use crate::bindings::Account;
fn run(_arg: Word, account: &mut Account) {
    account.initialize();  // Direct method call
}
```

The `Account` wrapper provides:
- Direct method access without module prefixes
- Proper mutable/immutable borrowing
- Automatic context binding

## Step 5: Build the Transaction Script

Build in dependency order:

```bash title=">_ Terminal"
# First, ensure the account component is built (generates WIT files)
cd contracts/bank-account
miden build

# Then build the transaction script
cd ../init-tx-script
miden build
```

<details>
<summary>Expected output</summary>

```text
   Compiling init-tx-script v0.1.0
    Finished `release` profile [optimized] target(s)
Creating Miden package /path/to/miden-bank/target/miden/release/init_tx_script.masp
```

</details>

## Account Deployment Pattern

In Miden, accounts are only visible on-chain after their first state change. Transaction scripts are commonly used for this "deployment":

```text
Execution Flow:

1. Account owner creates transaction with init-tx-script
   ┌───────────────────────────────────────┐
   │ Transaction                           │
   │  Account: Bank's AccountId            │
   │  Script: init-tx-script               │
   └───────────────────────────────────────┘

2. Transaction executes
   ┌───────────────────────────────────────┐
   │ run(_arg, account)                    │
   │  └─ account.initialize()              │
   │       └─ Sets initialized flag to 1   │
   └───────────────────────────────────────┘

3. Account state updated
   ┌───────────────────────────────────────┐
   │ Bank Account                          │
   │  Storage[0] = [1, 0, 0, 0]  ← Initialized
   │  Now visible on-chain                 │
   └───────────────────────────────────────┘
```

Before initialization:
- Account exists locally but isn't visible on the network
- Cannot receive notes or interact with other accounts

After initialization:
- Account is "deployed" and visible
- Can receive deposits and interact normally

## Using Script Arguments

The `_arg` parameter can pass data to the script:

```rust title="Example: Parameterized script"
#[tx_script]
fn run(arg: Word, account: &mut Account) {
    // Use arg as configuration
    let config_value = arg[0];
    account.configure(config_value);
}
```

When creating the transaction, provide the argument:

```rust title="Integration code (not contract code)"
let tx_script_args = Word::from([felt!(42), felt!(0), felt!(0), felt!(0)]);
let tx_context = mock_chain
    .build_tx_context(bank_account.id(), &[], &[])?
    .tx_script(init_tx_script)
    .tx_script_args(tx_script_args)  // Pass the argument
    .build()?;
```

## Try It: Verify Initialization Works

Let's test that the initialization transaction script enables deposits.

Create a test file:

```rust title="integration/tests/part6_tx_script_test.rs"
use integration::helpers::{
    build_project_in_dir, create_testing_account_from_package, AccountCreationConfig,
};
use miden_client::account::{StorageMap, StorageSlot};
use miden_client::Word;
use miden_objects::transaction::TransactionScript;
use miden_testing::MockChain;
use std::{path::Path, sync::Arc};

/// Test that the init-tx-script properly initializes the bank account
#[tokio::test]
async fn test_init_tx_script_enables_deposits() -> anyhow::Result<()> {
    // Build all required packages
    let mut builder = MockChain::builder();

    let bank_package = Arc::new(build_project_in_dir(
        Path::new("../contracts/bank-account"),
        true,
    )?);

    let init_tx_script_package = Arc::new(build_project_in_dir(
        Path::new("../contracts/init-tx-script"),
        true,
    )?);

    // Create uninitialized bank account
    let bank_cfg = AccountCreationConfig {
        storage_slots: vec![
            StorageSlot::Value(Word::default()),  // Slot 0: initialized = 0
            StorageSlot::Map(StorageMap::with_entries([])?),  // Slot 1: balances
        ],
        ..Default::default()
    };

    let mut bank_account =
        create_testing_account_from_package(bank_package.clone(), bank_cfg).await?;

    // Verify bank is NOT initialized
    let initial_storage = bank_account.storage().get_item(0)?;
    assert_eq!(
        initial_storage[0].as_int(),
        0,
        "Bank should start uninitialized"
    );

    println!("Step 1: Bank starts uninitialized (storage[0] = 0)");

    // Add bank to mock chain
    builder.add_account(bank_account.clone())?;
    let mut mock_chain = builder.build()?;

    // Create the TransactionScript from our init-tx-script
    let init_program = init_tx_script_package.unwrap_program();
    let init_tx_script = TransactionScript::new((*init_program).clone());

    // Build and execute the initialization transaction
    let init_tx_context = mock_chain
        .build_tx_context(bank_account.id(), &[], &[])?
        .tx_script(init_tx_script)
        .build()?;

    let executed_init = init_tx_context.execute().await?;
    bank_account.apply_delta(&executed_init.account_delta())?;
    mock_chain.add_pending_executed_transaction(&executed_init)?;
    mock_chain.prove_next_block()?;

    // Verify bank IS now initialized
    let final_storage = bank_account.storage().get_item(0)?;
    assert_eq!(
        final_storage[0].as_int(),
        1,
        "Bank should be initialized after tx script"
    );

    println!("Step 2: Bank initialized via transaction script (storage[0] = 1)");
    println!("\nPart 6 transaction script test passed!");

    Ok(())
}
```

Run the test from the project root:

```bash title=">_ Terminal"
cargo test --package integration part6_tx_script -- --nocapture
```

<details>
<summary>Expected output</summary>

```text
   Compiling integration v0.1.0 (/path/to/miden-bank/integration)
    Finished `test` profile [unoptimized + debuginfo] target(s)
     Running tests/part6_tx_script_test.rs

running 1 test
✓ Bank successfully initialized via transaction script
  Storage[0] changed from [0,0,0,0] to [1,0,0,0]
  Bank is now ready to accept deposits!
test test_init_tx_script_enables_deposits ... ok

test result: ok. 1 passed; 0 failed; 0 ignored
```

</details>

:::tip Troubleshooting
**"Cannot find module bindings"**: The bank-account wasn't built. Run `miden build` in `contracts/bank-account` first.

**"Dependency not found"**: Check that both dependency sections are in Cargo.toml with correct paths.
:::

## What We've Built So Far

| Component | Status | Description |
|-----------|--------|-------------|
| `bank-account` | ✅ Complete | Full deposit logic with storage and constraints |
| `deposit-note` | ✅ Complete | Note script that calls deposit method |
| `init-tx-script` | ✅ Complete | Transaction script for initialization |
| `withdraw-request-note` | Not started | Coming in Part 7 |

## Complete Code for This Part

<details>
<summary>Click to see the complete init-tx-script code</summary>

```rust title="contracts/init-tx-script/src/lib.rs"
// Do not link against libstd (i.e. anything defined in `std::`)
#![no_std]
#![feature(alloc_error_handler)]

use miden::*;

// Import the Account binding which wraps the bank-account component methods
use crate::bindings::Account;

/// Initialize Transaction Script
///
/// This transaction script initializes the bank account, enabling deposits.
/// It must be executed by the bank account owner before any deposits can be made.
///
/// # Flow
/// 1. Transaction is created with this script attached
/// 2. Script executes in the context of the bank account
/// 3. Calls `account.initialize()` to enable deposits
/// 4. Bank account is now "deployed" and visible on chain
#[tx_script]
fn run(_arg: Word, account: &mut Account) {
    account.initialize();
}
```

```toml title="contracts/init-tx-script/Cargo.toml"
[package]
name = "init-tx-script"
version = "0.1.0"
edition = "2021"

[lib]
crate-type = ["cdylib"]

[dependencies]
miden = { workspace = true }

[package.metadata.component]
package = "miden:init-tx-script"

[package.metadata.miden]
project-kind = "transaction-script"

[package.metadata.miden.dependencies]
"miden:bank-account" = { path = "../bank-account" }

[package.metadata.component.target.dependencies]
"miden:bank-account" = { path = "../bank-account/target/generated-wit/" }
```

</details>

## Key Takeaways

1. **`#[tx_script]`** marks the entry point with signature `fn run(_arg: Word, account: &mut Account)`
2. **Direct account access** - Methods called on the `account` parameter, not via module imports
3. **Owner-initiated** - Only the account owner can execute transaction scripts
4. **Deployment pattern** - First state change makes account visible on-chain
5. **Dependencies** - Same Cargo.toml configuration as note scripts

:::tip View Complete Source
See the complete transaction script implementation in the [miden-bank repository](https://github.com/keinberger/miden-bank/blob/main/contracts/init-tx-script/src/lib.rs).
:::

## Next Steps

Now that you understand transaction scripts, let's learn the advanced topic of creating output notes in [Part 7: Creating Output Notes](./07-output-notes).
````

## File: docs/builder/develop/tutorials/rust-compiler/debugging.md
````markdown
---
sidebar_position: 2
title: "Debugging Guide"
description: "Learn how to debug Miden Rust contracts using assert_eq and cycle counts."
---

# Debugging Guide

Miden contracts don't support traditional debugging tools like console.log or print statements. Instead, you can use `assert_eq` statements to check values during execution.

## Using assert_eq

The `assert_eq` function compares two `Felt` values and fails if they differ:

```rust
use miden::*;

// Check if a value equals an expected value
assert_eq(actual_value, expected_value);
```

:::note
`assert_eq` is a **function**, not a macro. Use `assert_eq(a, b)` without the exclamation mark.
:::

## Debugging with Cycle Counts

When your code fails, the error output includes a **cycle count** indicating where execution stopped. You can use this to narrow down problems:

1. **Note the cycle count** when your code fails
2. **Place an `assert_eq`** before the code you suspect is failing
3. **Run again** and check the result:
   - If the assertion fails at an **earlier cycle count**: the value you're checking is wrong
   - If the assertion passes and fails at the **same cycle count**: the value is correct, the problem is elsewhere

### Example

```rust
pub fn withdraw(&mut self, depositor: AccountId, amount: Felt) {
    let balance = self.get_balance(depositor);

    // Debug: Check if balance is what you expect
    assert_eq(balance, felt!(1000));

    // If the above passes, the problem is below this line
    // If it fails, the balance isn't what you expected

    let new_balance = balance - amount;
    self.balances.set(key, new_balance);
}
```

By moving the `assert_eq` statement around, you can isolate which value is incorrect.

## Limitations

- No console.log or print debugging in contract code
- `assert_eq` only works with `Felt` values
- This is currently the primary debugging technique available
````

## File: docs/builder/develop/tutorials/rust-compiler/index.md
````markdown
---
title: "Rust Compiler"
sidebar_position: 1
description: "Learn to build Miden smart contracts using Rust with the Miden Rust compiler."
---

# Rust Compiler

The Miden Rust compiler allows you to write smart contracts in Rust and compile them to Miden Assembly (MASM). This section provides tutorials and reference documentation for developing with the Rust compiler.

## Getting Started

If you're new to the Miden Rust compiler, start with the **Miden Bank Tutorial** - a comprehensive, step-by-step guide that teaches all the core concepts through building a complete banking application.

<div className="row margin-bottom--lg">
  <div className="col col--6">
    <div className="card">
      <div className="card__header">
        <h3>Miden Bank Tutorial</h3>
      </div>
      <div className="card__body">
        <p>Build a complete banking application while learning:</p>
        <ul>
          <li>Account components and storage</li>
          <li>Note scripts and transaction scripts</li>
          <li>Asset management</li>
          <li>Cross-component calls</li>
          <li>Output note creation</li>
        </ul>
      </div>
      <div className="card__footer">
        <a className="button button--primary button--block" href="./miden-bank/">Start Tutorial</a>
      </div>
    </div>
  </div>
</div>

## Reference Documentation

These guides provide detailed reference information for Rust compiler development:

| Guide | Description |
|-------|-------------|
| [Testing with MockChain](./testing) | Learn to test your contracts using MockChain for local blockchain simulation |
| [Debugging Guide](./debugging) | Interpret errors and debug common issues |
| [Common Pitfalls](./pitfalls) | Avoid known issues and limitations |

## Source Code

The complete source code for the Miden Bank example is available at:

**[github.com/keinberger/miden-bank](https://github.com/keinberger/miden-bank)**

## Prerequisites

Before starting, ensure you have:

- Completed the [Quick Start guide](../../../quick-start/)
- Basic familiarity with Rust programming
- Understanding of Miden concepts (accounts, notes, transactions)
````

## File: docs/builder/develop/tutorials/rust-compiler/pitfalls.md
````markdown
---
sidebar_position: 3
title: "Common Pitfalls"
description: "Reference guide for known issues, limitations, and workarounds when developing with the Miden Rust compiler."
---

# Common Pitfalls

This reference documents known issues and limitations when developing with the Miden Rust compiler, along with recommended workarounds.

## Felt Comparison Operators

### Problem

Direct comparison operators (`<`, `>`, `<=`, `>=`) on `Felt` values produce incorrect results.

```rust
// WRONG: This does NOT work correctly
let a = Felt::new(100);
let b = Felt::new(200);
if a < b {  // May produce unexpected results!
    // ...
}
```

### Solution

Always convert Felt values to `u64` before comparing:

```rust
// CORRECT: Convert to u64 first
let a = Felt::new(100);
let b = Felt::new(200);
if a.as_u64() < b.as_u64() {
    // Works correctly
}
```

### Example from Bank Contract

```rust title="contracts/bank-account/src/lib.rs"
// Validating deposit amount
let amount = asset.unwrap_fungible().amount().as_u64();

// Use u64 comparison
assert!(
    amount <= MAX_DEPOSIT_AMOUNT,  // MAX_DEPOSIT_AMOUNT is u64
    "Deposit exceeds maximum"
);
```

:::warning Always Use .as_u64()
Any time you compare Felt values, convert them first. This applies to:
- Amount comparisons
- Balance checks
- Index comparisons
- Any numeric ordering
:::

---

## Stack Limit (16 Elements)

### Problem

The Miden VM stack only allows direct access to the first 16 elements. Complex functions with many local variables trigger this error:

```
invalid stack index: only the first 16 elements on the stack are directly accessible
```

This may also appear as:
```
values not found in advice provider
```

### Solution

**1. Reduce local variables:**

```rust
// WRONG: Too many local variables
fn complex_operation(&mut self) {
    let a = self.get_a();
    let b = self.get_b();
    let c = self.get_c();
    let d = self.get_d();
    let e = self.get_e();
    let f = self.get_f();
    // ... more variables cause stack overflow
}

// CORRECT: Use values directly or minimize locals
fn complex_operation(&mut self) {
    // Process in smaller batches
    let result_ab = self.process(self.get_a(), self.get_b());
    let result_cd = self.process(self.get_c(), self.get_d());
    self.finalize(result_ab, result_cd);
}
```

**2. Break into smaller functions:**

```rust
// WRONG: One large function
fn do_everything(&mut self, a: Word, b: Word, c: Word) {
    // Many operations touching all parameters...
}

// CORRECT: Split into stages
fn stage_one(&mut self, a: Word) -> Felt {
    // Process a
}

fn stage_two(&mut self, b: Word, result: Felt) -> Felt {
    // Process b with result from stage one
}

fn stage_three(&mut self, c: Word, result: Felt) {
    // Final processing
}
```

**3. Process iteratively:**

```rust
// CORRECT: Process one at a time
for asset in assets {
    self.process_single_asset(asset);
}
```

---

## Function Argument Limit (4 Words)

### Problem

Miden functions can receive at most 4 Words (16 Felts) as arguments:

```
error: expected at most 4 words of arguments
```

```rust
// WRONG: Too many arguments
fn process(
    &mut self,
    depositor: AccountId,    // ~1 Word
    asset: Asset,            // 1 Word
    serial_num: Word,        // 1 Word
    tag: Felt,               // 1 Felt
    aux: Felt,               // 1 Felt
    note_type: Felt,         // 1 Felt
    execution_hint: Felt,    // 1 Felt
    extra_data: Word,        // 1 Word - EXCEEDS LIMIT!
) {
    // ...
}
```

### Solution

**1. Group related values into Words:**

```rust
// CORRECT: Combine into Word structures
fn process(
    &mut self,
    depositor: AccountId,    // ~1 Word
    asset: Asset,            // 1 Word
    serial_num: Word,        // 1 Word
    params: Word,            // [tag, aux, note_type, hint] - 1 Word
) {
    let tag = params[0];
    let aux = params[1];
    let note_type = params[2];
    let hint = params[3];
    // ...
}
```

**2. Use note inputs for passing data:**

For note scripts, pass complex data via `active_note::get_inputs()`:

```rust
#[note_script]
fn run(_arg: Word) {
    let inputs = active_note::get_inputs();
    // Inputs can hold many Felts without function argument limits
    let param1 = inputs[0];
    let param2 = inputs[1];
    // ... access up to the full input capacity
}
```

**3. Store data first, reference by key:**

```rust
// Store complex data in storage
fn store_config(&mut self, key: Word, config_data: Word) {
    self.configs.set(key, config_data);
}

// Reference by key in other operations
fn process_with_config(&mut self, key: Word) {
    let config = self.configs.get(&key);
    // Use config...
}
```

---

## Array Ordering (Rust/MASM Reversal)

### Problem

Arrays passed from Rust to the Miden VM are received in **reversed order**.

```rust
// In Rust, you define:
let word = Word::from([a, b, c, d]);

// In MASM, this becomes: [d, c, b, a]
```

### Solution

Be aware of this when:
- Constructing storage keys
- Parsing note inputs
- Working with asset data

**Example: Storage Key Construction**

```rust
// Balance key format in Rust
let key = Word::from([
    depositor.prefix().as_felt(),  // Position 0 in Rust
    depositor.suffix(),             // Position 1
    faucet.prefix().as_felt(),      // Position 2
    faucet.suffix(),                // Position 3
]);

// When the VM processes this, it sees:
// [faucet.suffix, faucet.prefix, depositor.suffix, depositor.prefix]
```

**Example: Asset Structure**

```rust
// Asset Word layout (Rust perspective)
// [amount, 0, faucet_suffix, faucet_prefix]

let asset_word = Word::from([
    Felt::new(amount),           // [0] amount
    Felt::new(0),                // [1] padding
    faucet.id().suffix(),        // [2] faucet suffix
    faucet.id().prefix().as_felt(), // [3] faucet prefix
]);
```

:::tip Consistency is Key
The reversal doesn't matter as long as you're **consistent**. Always construct and parse arrays the same way throughout your codebase.
:::

---

## Felt Arithmetic Underflow/Overflow

### Problem

Miden uses field element (Felt) arithmetic, which operates in a prime field with modulus `p = 2^64 - 2^32 + 1`. This means arithmetic is **modular** and will silently wrap around instead of causing an error.

```rust
// DANGEROUS: This does NOT error on underflow!
let balance = Felt::new(100);
let withdrawal = Felt::new(500);
let new_balance = balance - withdrawal;  // Silently wraps to a huge positive number!
```

When you subtract a larger value from a smaller one, the result wraps around to a large positive number (approximately `2^64`). This is NOT an error in the Miden VM - the transaction will succeed with an incorrect balance.

### Why This Happens

The Miden VM performs all Felt arithmetic as modular operations within the prime field. There is no automatic overflow or underflow detection at the VM level. The Rust compiler's default overflow mode is `Unchecked`, meaning it compiles directly to raw VM arithmetic operations.

### Solution

**Always validate before subtraction:**

```rust
// CORRECT: Check balance before subtracting
let current_balance: Felt = self.balances.get(&key);
let withdraw_amount = withdraw_asset.inner[0];

// Validate that balance is sufficient
assert!(
    current_balance.as_u64() >= withdraw_amount.as_u64(),
    "Withdrawal amount exceeds available balance"
);

// Only subtract after validation
let new_balance = current_balance - withdraw_amount;
```

### Example from Bank Contract

```rust title="contracts/bank-account/src/lib.rs"
pub fn withdraw(&mut self, depositor: AccountId, withdraw_asset: Asset, /* ... */) {
    let withdraw_amount = withdraw_asset.inner[0];

    // Get current balance and validate sufficient funds exist.
    // This check is critical: Felt arithmetic is modular, so subtracting
    // more than the balance would silently wrap to a large positive number.
    let current_balance: Felt = self.balances.get(&key);
    assert!(
        current_balance.as_u64() >= withdraw_amount.as_u64(),
        "Withdrawal amount exceeds available balance"
    );

    let new_balance = current_balance - withdraw_amount;
    self.balances.set(key, new_balance);
}
```

:::danger Critical Security Issue
Failure to validate before subtraction can lead to:
- Users withdrawing more than their balance
- Balance values becoming astronomically large
- Complete loss of funds in the contract

**Always check bounds before Felt subtraction operations.**
:::

---

## Wallet Component Requirement

### Problem

The `active_note::add_assets_to_account()` function fails if the consuming account doesn't have the basic wallet component.

```
Error: Account does not support asset operations
```

### Solution

Ensure accounts that receive assets via this function have wallet capability:

```rust
use miden_client::account::component::BasicWallet;

// When creating an account that needs to receive assets
let account = AccountBuilder::new(seed)
    .with_component(BasicWallet)  // Add wallet capability
    .with_component(YourCustomComponent)
    .build()?;
```

**Alternative: Use `native_account::add_asset()`**

For account components, use the native account API instead:

```rust
#[component]
impl Bank {
    pub fn deposit(&mut self, depositor: AccountId, asset: Asset) {
        // This works for any account - no wallet required
        native_account::add_asset(asset);

        // Track balance in storage
        self.update_balance(depositor, asset);
    }
}
```

---

## Storage Map Key Consistency

### Problem

Storage map lookups return unexpected results or zeros when keys are constructed inconsistently.

### Solution

Define a single key construction pattern and use it everywhere:

```rust title="contracts/bank-account/src/lib.rs"
#[component]
impl Bank {
    /// Construct a balance key for a depositor and asset.
    /// Key format: [depositor_prefix, depositor_suffix, faucet_prefix, faucet_suffix]
    fn balance_key(&self, depositor: AccountId, faucet_id: AccountId) -> Word {
        Word::from([
            depositor.prefix().as_felt(),
            depositor.suffix(),
            faucet_id.prefix().as_felt(),
            faucet_id.suffix(),
        ])
    }

    pub fn get_balance(&self, depositor: AccountId, faucet_id: AccountId) -> Felt {
        let key = self.balance_key(depositor, faucet_id);
        self.balances.get(&key)
    }

    fn update_balance(&mut self, depositor: AccountId, faucet_id: AccountId, amount: Felt) {
        let key = self.balance_key(depositor, faucet_id);
        self.balances.set(key, amount);
    }
}
```

---

## Note Type Values

### Problem

When creating output notes, the `note_type` parameter uses specific integer values that aren't obvious.

### Solution

Use the correct values for note types:

| Value | Type | Description |
|-------|------|-------------|
| 1 | Public | Note data is visible on-chain |
| 2 | Private | Note data is hidden (only hash on-chain) |

```rust
// In note inputs or when creating output notes
let note_type = Felt::new(1);  // Public note
// or
let note_type = Felt::new(2);  // Private note
```

---

## P2ID Script Root

### Problem

When creating P2ID (Pay-to-ID) output notes, you need the correct script root digest, which is a constant value from miden-base.

### Solution

Use the hardcoded P2ID script root:

```rust title="contracts/bank-account/src/lib.rs"
/// Get the P2ID note script root digest.
/// This is a constant from miden-base that identifies the P2ID script.
fn p2id_note_root() -> Word {
    Word::from([
        Felt::new(0xdcc1ed119ad861e7),
        Felt::new(0xc2ac8f631bd97fcc),
        Felt::new(0x53116c659dca41b),
        Felt::new(0x8c36d1e96bdd684e),
    ])
}
```

:::info Where This Comes From
This digest is computed from the P2ID note script in `miden-base`. If the P2ID script changes in a future version, this value will need to be updated.
:::

---

## Execution Hint Hardcoding

### Problem

When creating output notes, you might try to parameterize the `execution_hint`, but it's actually hardcoded in miden-base.

### Solution

Always use `NoteExecutionHint::none()` for output notes created in contracts:

```rust
// The execution hint is fixed in the P2ID note creation logic
let execution_hint = NoteExecutionHint::none();

// In miden-base, this is defined as:
// 16777216 (or NoteExecutionHint::none() in the API)
```

---

## Quick Reference Table

| Pitfall | Symptom | Solution |
|---------|---------|----------|
| Felt comparison | Wrong comparison results | Use `.as_u64()` |
| Stack overflow | "16 elements" error | Reduce locals, split functions |
| Too many args | "4 words" error | Group into Words, use inputs |
| Array reversal | Wrong data order | Be consistent with construction |
| Felt underflow | Balance wraps to huge number | Validate before subtraction |
| Missing wallet | Asset operation fails | Add `BasicWallet` component |
| Key mismatch | Zero balances | Use helper function for keys |
| Note type | Wrong note visibility | Use 1 (Public) or 2 (Private) |

:::tip View Complete Source
See these patterns in context in the [miden-bank repository](https://github.com/keinberger/miden-bank).
:::

## Next Steps

- **[Debugging Guide](./debugging)** - Troubleshoot errors
- **[Testing Guide](./testing)** - MockChain patterns
- **[Miden Bank Tutorial](./miden-bank/)** - See these patterns in context
````

## File: docs/builder/develop/index.md
````markdown
---
title: Develop on Miden
sidebar_position: 4
---

<!--
ARCHITECTURE NOTE:
Tutorials content is canonical in versioned_docs/version-X.Y/miden-tutorials/.
This landing page exists only for the "current/next" version.
Full tutorial content is available by selecting a released version.
-->

# Develop on Miden

:::info Version Note
Full tutorials and examples are available in **released versions only**. Please select a version from the dropdown (e.g., 0.12, 0.11) to access the complete tutorial documentation.
:::

## Overview

Basic tutorials and examples of how to build applications on Miden.

The goal is to make getting up to speed with building on Miden as quick and simple as possible.

All tutorials are accompanied by code examples in Rust and TypeScript, which can be found in the [Miden Tutorials](https://github.com/0xMiden/miden-tutorials) repository.
````

## File: docs/builder/quick-start/setup/_category_.json
````json
{
  "label": "Set Up",
  "position": 1
}
````

## File: docs/builder/quick-start/your-first-smart-contract/_category_.json
````json
{
  "label": "Your First Smart Contract",
  "position": 5
}
````

## File: docs/builder/quick-start/your-first-smart-contract/create.md
````markdown
---
sidebar_position: 2
title: Create Your Project
description: Set up a new Miden project and understand the counter contract implementation.
---

In this section, you'll set up a new Miden project and understand the structure and implementation of both the counter account contract and increment note script.

## Setting Up Your Project

Create a new Miden project using the CLI:

```bash title=">_ Terminal"
miden new counter-project
cd counter-project
```

This creates a workspace with the following structure:

```text
counter-project/
├── contracts/                   # Each contract as individual crate
│   ├── counter-account/         # Example: Counter account contract
│   └── increment-note/          # Example: Increment note contract
├── integration/                 # Integration crate (scripts + tests)
│   ├── src/
│   │   ├── bin/                 # Rust binaries for on-chain interactions
│   │   ├── lib.rs
│   │   └── helpers.rs           # Temporary helper file
│   └── tests/                   # Test files
├── Cargo.toml                   # Workspace root
└── rust-toolchain.toml          # Rust toolchain specification
```

The project follows Miden's design philosophy of clean separation:

- **`contracts/`**: Your primary working directory for writing Miden smart contract code
- **`integration/`**: All on-chain interactions, deployment scripts, and tests

Each contract is organized as its own individual crate, providing independent versioning, dependencies, and clear isolation between different contracts.

## Building Your Contracts

You can build individual contracts by navigating to their directory and running the Miden build command:

```bash title=">_ Terminal"
# Build the counter account contract
cd contracts/counter-account
miden build

# Build the increment note contract
cd ../increment-note
miden build
```

This compiles the Rust contract code into Miden assembly, making it ready for deployment and interaction.

## Understanding the Counter Account Contract

Let's examine the counter account contract that comes with the project template. Open `contracts/counter-account/src/lib.rs`:

```rust title="contracts/counter-account/src/lib.rs"
// Do not link against libstd (i.e. anything defined in `std::`)
#![no_std]

// However, we could still use some standard library types while
// remaining no-std compatible, if we uncommented the following lines:
//
// extern crate alloc;

use miden::{component, felt, Felt, StorageMap, StorageMapAccess, Word};

/// Main contract structure for the counter example.
#[component]
struct CounterContract {
    /// Storage map holding the counter value.
    #[storage(slot(0), description = "counter contract storage map")]
    count_map: StorageMap,
}

#[component]
impl CounterContract {
    /// Returns the current counter value stored in the contract's storage map.
    pub fn get_count(&self) -> Felt {
        // Define a fixed key for the counter value within the map
        let key = Word::from([felt!(0), felt!(0), felt!(0), felt!(1)]);
        // Read the value associated with the key from the storage map
        self.count_map.get(&key)
    }

    /// Increments the counter value stored in the contract's storage map by one.
    pub fn increment_count(&self) -> Felt {
        // Define the same fixed key
        let key = Word::from([felt!(0), felt!(0), felt!(0), felt!(1)]);
        // Read the current value
        let current_value: Felt = self.count_map.get(&key);
        // Increment the value by one
        let new_value = current_value + felt!(1);
        // Write the new value back to the storage map
        self.count_map.set(key, new_value);
        new_value
    }
}
```

### Counter Contract Walkthrough

#### No-std Environment

```rust
#![no_std]
```

Miden contracts run in a `no_std` environment, meaning they don't link against Rust's standard library. This is essential for blockchain execution where contracts need to be deterministic and lightweight.

#### Miden Library Imports

```rust
use miden::{component, felt, Felt, StorageMap, StorageMapAccess, Word};
```

These imports provide:

- **`component`**: Macro for defining contract components
- **`Felt`/`Word`**: Miden's native field element and word types
- **`StorageMap`**: Key-value storage within account storage slots
- **`StorageMapAccess`**: Needed for reading storage values (`get_count` function)

#### Contract Structure Definition

```rust
#[component]
struct CounterContract {
    /// Storage map holding the counter value.
    #[storage(slot(0), description = "counter contract storage map")]
    count_map: StorageMap,
}
```

The `#[component]` attribute marks this as a Miden component. The `count_map` field is a `StorageMap` that will be stored in storage slot 0 of the account.

**Important**: Storage slots in Miden hold `Word` values, which are composed of four field elements (`Felt`). Each `Felt` is a 64-bit unsigned integer (u64). The `StorageMap` provides a key-value interface within a single storage slot, allowing you to store multiple key-value pairs within the four-element word structure.

#### Contract Implementation

```rust
impl CounterContract {
    // Function implementations...
}
```

The `CounterContract` implementation defines the external interface that other contracts and notes can call. This is the contract's public API.

#### Storage Key Strategy

```rust
let key = Word::from([felt!(0), felt!(0), felt!(0), felt!(1)]);
```

Both functions use the same fixed key `[0, 0, 0, 1]` to store and retrieve the counter value within the storage map. This demonstrates a simple but effective storage pattern.

## Understanding the Increment Note Script

Now let's examine the increment note script at `contracts/increment-note/src/lib.rs`:

```rust title="contracts/increment-note/src/lib.rs"
// Do not link against libstd (i.e. anything defined in `std::`)
#![no_std]

// However, we could still use some standard library types while
// remaining no-std compatible, if we uncommented the following lines:
//
// extern crate alloc;
// use alloc::vec::Vec;

use miden::*;

use crate::bindings::miden::counter_account::counter_account;

#[note_script]
fn run(_arg: Word) {
    let initial_value = counter_account::get_count();
    counter_account::increment_count();
    let expected_value = initial_value + Felt::from_u32(1);
    let final_value = counter_account::get_count();
    assert_eq(final_value, expected_value);
}
```

### Increment Note Script Walkthrough

#### No-std Setup

Similar to the account contract, the note script uses `#![no_std]` with the same allocator and panic handler setup.

#### Miden Imports

```rust
use miden::*;

use crate::bindings::miden::counter_account::counter_account;
```

The wildcard import brings in all Miden note script functionality. The `counter_account` binding imports the interface functions from the counter contract, allowing the note script to call them.

#### No Struct Definition

Unlike account contracts, note scripts don't define a struct. They are purely functional code that gets executed when a note is consumed. The script defines **what happens** when the note is processed, not a persistent data structure.

Learn more about [note scripts in the Miden documentation](/miden-base/note/).

#### The Note Script Function

```rust
#[note_script]
fn run(_arg: Word) {
    let initial_value = counter_account::get_count();
    counter_account::increment_count();
    let expected_value = initial_value + Felt::from_u32(1);
    let final_value = counter_account::get_count();
    assert_eq(final_value, expected_value);
}
```

The `#[note_script]` attribute marks this function as the entry point for note execution. The function:

1. **Gets the initial counter value** using the imported `counter_account::get_count()` function
2. **Calls increment_count()** to increment the counter on the target account
3. **Verifies the operation succeeded** by checking the final value matches expectations

This demonstrates how note scripts interact with account contracts through their public interfaces, calling functions to change state.

The counter example demonstrates a complete interaction pattern: the account contract manages persistent state, while the note script provides a mechanism to trigger state changes through note consumption.

## Next Steps

Now that you understand the contract code structure, let's move on to [deploying your contract](./deploy) and learn how the integration folder enables interaction with your contracts on the Miden network.

---
````

## File: docs/builder/quick-start/your-first-smart-contract/deploy.md
````markdown
---
sidebar_position: 3
title: Deploy Your Contract
description: Learn about the integration folder and deploy your counter contract to the Miden testnet.
---

# Deploy Your Contract

In this section, you'll learn about how to deploy and interact with your counter contract using the included "increment-count" scripts.

## Understanding the Integration Folder

The `integration/` folder is a crucial part of your Miden project workspace. It serves as the command center for all interactions with your smart contracts. Let's explore its structure and purpose.

Navigate to your project's integration folder:

```bash title=">_ Terminal"
cd integration
ls -la
```

You'll see a structure like:

```text
integration/
├── Cargo.toml                  # Integration crate configuration
├── src/
│   ├── bin/                    # Executable scripts for onchain interactions
│   │   └── increment_count.rs  # Script to deploy and increment counter
│   ├── helpers.rs              # Temporary helper file
│   └── lib.rs                  # Exports helpers
└── tests/                      # Integration tests
    └── counter_test.rs         # Tests for counter contract
```

## Purpose of the Integration Folder

The integration folder serves two essential functions in Miden development:

### 1. Contract Interaction Scripts (Binary Executables)

Think of the scripts in `src/bin/` as Miden's equivalent to [**Foundry scripts**](https://getfoundry.sh/guides/scripting-with-solidity). These are executable Rust binaries that handle all your contract interactions:

- **Contract Deployment**: Scripts that create and deploy accounts to the network
- **Function/Procedure Calls**: Scripts that interact with deployed contracts through notes or [transaction scripts](/miden-base/transaction#transaction-lifecycle)
- **State Queries**: Scripts that read contract state from the network
- **Operations**: Scripts for contract upgrades, configuration changes, etc.

Each binary is designed to handle a specific task.

### 2. Testing Infrastructure

All testing logic for your smart contracts lives here:

- **Integration Tests**: End-to-end tests that verify contract behavior on Testnet
- **Mockchain Tests**: Local testing using Miden's testing framework

This separation ensures your contract logic in `contracts/` remains clean and focused while all interaction complexity is managed in the integration layer.

## The Increment Count Script

Let's examine the `increment_count.rs` script located at `integration/src/bin/increment_count.rs`. This script demonstrates the complete lifecycle of deploying and interacting with your counter contract.

The script performs these key operations:

1. **Sets up a Miden client** connected to the testnet
2. **Builds both contract packages** (counter account and increment note)
3. **Creates the counter account** with initial storage configuration
4. **Creates a sender account** for publishing notes
5. **Creates and publishes the increment note**
6. **Consumes the note** to trigger the counter increment

### Running the Script

Execute the increment script to deploy your contract:

```bash title=">_ Terminal"
cd integration
cargo run --bin increment_count --release
```

<details>
<summary>Expected Output</summary>

```text
Account ID: V0(AccountIdV0 { prefix: 14134910893364381952, suffix: 3644349760121494784 })
Sender account ID: "0xd85b347218c5a80052dbd47b2f36ad"
Counter note hash: "0xf0e821396a896eb9983e682bc056021d57ddcaa43082f34597bf9e026421e566"
Note publish transaction ID: "0xc6f080855724402cadf26650ffe993fe97a127a8f6c9c82ec621960e936e6d732
Consume transaction ID: "0x2d1d8510e546ce0fbc22fa7d1a82322259d73cd1d7e0ca86622d0be70fab0548"
Account delta: AccountDelta { account_id: V0(AccountIdV0 { prefix: 7255964780328958976, suffix: 2724050564200846336 }), storage: AccountStorageDelta { values: {}, maps: {0: StorageMapDelta({LexicographicWord(Word([0, 0, 0, 1])): Word([0, 0, 0, 1])})} }, vault: AccountVaultDelta { fungible: FungibleAssetDelta({}), non_fungible: NonFungibleAssetDelta({}) }, nonce_delta: 1 }
```

</details>

Congratulations, you have successfully deployed the Counter Contract to the Miden Testnet, and incremented its count by one!

### What Happens During Execution

The script demonstrates Miden's deployment flow:

1. **Contract Building**: The script compiles both the counter account and increment note contracts
2. **Account Creation**: Creates a counter account with initial storage (counter value = 0)
3. **Note Publishing**: Creates an increment note and publishes it to the network
4. **Note Consumption**: The counter account consumes the note, executing the increment logic
5. **State Update**: The counter value increases and the change is recorded onchain

This process shows how Miden contracts are deployed through state changes rather than separate deployment transactions.

**Miden's Deployment Flow**: In Miden, accounts (contracts) become visible onchain only when they undergo a state change. Simply creating an account locally doesn't deploy it - the account must participate in a transaction that modifies its state. In our case, by incrementing the counter, we're effectively "deploying" the contract and making it visible on the Miden testnet explorer. This is why the increment operation serves both as the deployment and the first interaction with the contract.

## How the Scripts Work

The integration scripts work by connecting to the Miden client and then building contracts from the Miden package files. These package files are generated when you run `miden build` inside each contract directory, but the scripts handle this compilation step automatically - you don't need to manually build the contracts before running the scripts.

Next, we look into how the scripts convert your Rust contract code into deployable Miden contracts.

## Script Breakdown

Let's examine key parts of the increment script:

### Client Setup

```rust
let ClientSetup { mut client, keystore } = setup_client().await?;
let sync_summary = client.sync_state().await?;
```

This establishes a connection to the Miden testnet and synchronizes with the latest network state.

### Building Contracts from Source

The first step is building the Rust contracts into Miden packages:

```rust
// Build the counter account contract from source
let counter_package = Arc::new(
    build_project_in_dir(Path::new("../contracts/counter-account"), true)
        .context("Failed to build counter account contract")?
);

// Build the increment note script from source
let note_package = Arc::new(
    build_project_in_dir(Path::new("../contracts/increment-note"), true)
        .context("Failed to build increment note contract")?
);
```

The `build_project_in_dir()` function:

- Takes the path to your contract's Rust source code
- Compiles the Rust code into Miden assembly
- Generates a package containing the compiled contract bytecode and metadata
- This is equivalent to manually running `miden build` in each contract directory

These packages contain all the information needed to deploy and interact with your contracts on the Miden network.

### Converting Packages to Deployable Accounts

Once we have the compiled packages, we convert them into deployable accounts and notes:

```rust
// Configure initial storage for the counter account
let count_storage_key = Word::from([Felt::new(0), Felt::new(0), Felt::new(0), Felt::new(1)]);
let initial_count = Word::from([Felt::new(0), Felt::new(0), Felt::new(0), Felt::new(0)]);

let counter_cfg = AccountCreationConfig {
    storage_slots: vec![miden_client::account::StorageSlot::Map(
        StorageMap::with_entries([(count_storage_key, initial_count)])
            .context("Failed to create storage map with initial counter value")?
    )],
    ..Default::default()
};

// Convert the counter package into a deployable account
let counter_account = create_account_from_package(
    &mut client,
    contract_package.clone(),
    counter_cfg
)
.await
.context("Failed to create counter account")?;
```

The `create_account_from_package()` function:

- Takes the compiled contract package
- Combines it with the provided configuration (storage, settings, etc.)
- Creates a deployable Miden account that can be used in transactions

**Important**: Accounts that use storage must have their storage slots specified when instantiating the account. This is why we define the storage configuration with:

- Storage slot 0 containing a `StorageMap`
- The counter key `[0, 0, 0, 1]` with initial value `[0, 0, 0, 0]` (representing count = 0)

This pre-initialization ensures the account's storage is properly configured before deployment.

### Converting Packages to Executable Notes

Similarly, we convert the note package into an executable note:

```rust
// Convert the increment note package into an executable note
let counter_note = create_note_from_package(
    &mut client,
    note_package.clone(),
    sender_account.id(),
    NoteCreationConfig::default()
)
.context("Failed to create counter note from package")?;

// Publish the note to the network
let note_publish_request = TransactionRequestBuilder::new()
    .own_output_notes(vec![OutputNote::Full(counter_note.clone())])
    .build()
    .context("Failed to build note publish transaction request")?;
```

The `create_note_from_package()` function:

- Takes the compiled note script package
- Combines it with the sender account ID and configuration
- Creates an executable note containing the increment script logic
- The note can then be published to the network and consumed by the target (counter) account

This demonstrates the complete workflow: Rust source code → compiled packages → deployable accounts/notes → network transactions.

### Note Consumption

```rust
let consume_note_request = TransactionRequestBuilder::new()
    .unauthenticated_input_notes([(counter_note.clone(), None)])
    .build()
    .context("Failed to build consume note transaction request")?;

let consume_tx_id = client
    .submit_new_transaction(counter_account.id(), consume_note_request)
    .await
    .context("Failed to create consume note transaction")?;
```

The counter account consumes the increment note, executing the note script which calls the counter's increment function.

## Next Steps

Congratulations! You've successfully deployed and interacted with your first Miden smart contract. The integration folder provides the foundation for managing all aspects of your contract lifecycle.

This completes the core smart contract development workflow on Miden. You're now equipped to build and deploy your own smart contracts using these patterns and tools!
````

## File: docs/builder/quick-start/your-first-smart-contract/test.md
````markdown
---
sidebar_position: 4
title: Test Your Contract
description: Learn how to write and run tests for your Miden smart contracts using the integration testing framework.
---

# Test Your Contract

In this final section, you'll learn how to test your counter contract using Miden's **Mockchain** - a purpose-built testing framework that enables fast, local testing without network dependencies.

## Test Structure and Organization

All tests for your smart contracts should be placed in the `integration/tests/` folder. This follows the same separation of concerns we've seen throughout the project:

- **`contracts/`**: Contains your contract source code
- **`integration/src/bin/`**: Contains deployment and interaction scripts
- **`integration/tests/`**: Contains all test files for your contracts

This structure keeps your contract logic clean while providing a dedicated space for comprehensive testing.

## Local Testing with Mockchain

For most testing scenarios, we use Miden's **Mockchain** - a local, mocked blockchain instance specifically designed for testing. While you can also create tests that use the Miden client for end-to-end testing and on-chain interactions, the Mockchain provides the best developer experience for unit and integration testing.

### What is the Mockchain?

The Mockchain is Miden's purpose-built testing framework that provides several key advantages over testing against a live network:

- **Blazing Fast Tests**: Run tests locally without network latency or external dependencies
- **Full State Control**: Manipulate blockchain state precisely to create specific test scenarios
- **Simpler Code**: Cleaner, more focused test logic without network complexity
- **Deterministic Results**: Consistent test outcomes independent of network conditions
- **Debugging Capabilities**: Detailed inspection of transaction execution and state changes

This makes testing faster, more reliable, and easier to debug than testing against the testnet.

## Running the Tests

Execute your tests from the integration directory using the standard Cargo test command:

```bash title="Terminal"
cd integration
cargo test --release
```

You should see output confirming the test passes:

```text title="Expected Output"
running 1 test
Test passed!
test counter_test ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
```

## Understanding the Mockchain Test

Your project includes a comprehensive test file at `integration/tests/counter_test.rs` that demonstrates how to test the counter contract using the Mockchain. Let's walk through this test to understand the testing patterns:

<details class="normal-text">
<summary>Test File</summary>

```rust title="integration/tests/counter_test.rs"
use integration::helpers::{
    build_project_in_dir, create_testing_account_from_package, create_testing_note_from_package,
    AccountCreationConfig, NoteCreationConfig,
};

use miden_client::{account::StorageMap, transaction::OutputNote, Felt, Word};
use miden_testing::{Auth, MockChain};
use std::{path::Path, sync::Arc};

#[tokio::test]
async fn counter_test() -> anyhow::Result<()> {
    // Test that after executing the increment note, the counter value is incremented by 1
    let mut builder = MockChain::builder();

    // Crate note sender account
    let sender = builder.add_existing_wallet(Auth::BasicAuth)?;

    // Build contracts
    let contract_package = Arc::new(build_project_in_dir(
        Path::new("../contracts/counter-account"),
        true,
    )?);
    let note_package = Arc::new(build_project_in_dir(
        Path::new("../contracts/increment-note"),
        true,
    )?);

    // Create the counter account with initial storage and no-auth auth component
    let count_storage_key = Word::from([Felt::new(0), Felt::new(0), Felt::new(0), Felt::new(1)]);
    let initial_count = Word::from([Felt::new(0), Felt::new(0), Felt::new(0), Felt::new(0)]);
    let counter_cfg = AccountCreationConfig {
        storage_slots: vec![miden_client::account::StorageSlot::Map(
            StorageMap::with_entries([(count_storage_key, initial_count)])?,
        )],
        ..Default::default()
    };

    // create testing counter account
    let mut counter_account =
        create_testing_account_from_package(contract_package.clone(), counter_cfg).await?;

    // create testing increment note
    let counter_note = create_testing_note_from_package(
        note_package.clone(),
        sender.id(),
        NoteCreationConfig::default(),
    )?;

    // add counter account and note to mockchain
    builder.add_account(counter_account.clone())?;
    builder.add_output_note(OutputNote::Full(counter_note.clone().into()));

    // Build the mock chain
    let mut mock_chain = builder.build()?;
    // Build the transaction context
    let tx_context = mock_chain
        .build_tx_context(counter_account.id(), &[counter_note.id()], &[])?
        .build()?;

    println!("before executing tx");

    // Execute the transaction
    let executed_transaction = tx_context.execute().await?;

    println!("after executing tx");

    // Apply the account delta to the counter account
    counter_account.apply_delta(&executed_transaction.account_delta())?;

    // Add the executed transaction to the mockchain
    mock_chain.add_pending_executed_transaction(&executed_transaction)?;
    mock_chain.prove_next_block()?;

    // Get the count from the updated counter account
    let count = counter_account
        .storage()
        .get_map_item(0, count_storage_key)?;

    // Assert that the count value is equal to 1 after executing the transaction
    assert_eq!(
        count,
        Word::from([Felt::new(0), Felt::new(0), Felt::new(0), Felt::new(1)]),
        "Count value is not equal to 1"
    );

    println!("Test passed!");
    Ok(())
}
```

</details>

## Test Code Walkthrough

Let's break down this test step by step to understand how Mockchain testing works.

### 1. Setting Up the Mockchain Builder

```rust
let mut builder = MockChain::builder();
let sender = builder.add_existing_wallet(Auth::BasicAuth)?;
```

**What's happening:**

- We instantiate the **Mockchain builder**, which is used to configure our testing environment
- We create a **sender account** using basic authentication - this account will publish the increment note
- The builder pattern allows us to incrementally add all the components needed for our test

### 2. Building the Contract Packages

```rust
let contract_package = Arc::new(build_project_in_dir(
    Path::new("../contracts/counter-account"),
    true,
)?);
let note_package = Arc::new(build_project_in_dir(
    Path::new("../contracts/increment-note"),
    true,
)?);
```

**What's happening:**

- Just like in the deployment script, we **build both contract packages** (counter account and increment note)
- The `build_project_in_dir()` function compiles the Rust contracts into Miden packages
- We wrap them in `Arc` for efficient memory sharing across the test

### 3. Creating the Test Account and Note

```rust
// Create the counter account with initial storage and no-auth auth component
let count_storage_key = Word::from([Felt::new(0), Felt::new(0), Felt::new(0), Felt::new(1)]);
let initial_count = Word::from([Felt::new(0), Felt::new(0), Felt::new(0), Felt::new(0)]);
let counter_cfg = AccountCreationConfig {
    storage_slots: vec![miden_client::account::StorageSlot::Map(
        StorageMap::with_entries([(count_storage_key, initial_count)])?,
    )],
    ..Default::default()
};

// Create testing entities
let counter_account = create_testing_account_from_package(contract_package.clone(), counter_cfg).await?;
let counter_note = create_testing_note_from_package(
    note_package.clone(),
    sender.id(),
    NoteCreationConfig::default(),
)?;
```

**What's happening:**

- We configure the **counter account's initial storage** with count = 0 at storage key `[0, 0, 0, 1]`
- We create the **testing counter account** from the compiled package using `create_testing_account_from_package()`
- We create the **testing increment note** using `create_testing_note_from_package()`
- These helper functions create test-specific versions optimized for the Mockchain environment

### 4. Adding Components to the Mockchain

```rust
builder.add_account(counter_account.clone())?;
builder.add_output_note(OutputNote::Full(counter_note.clone().into()));
let mut mock_chain = builder.build()?;
```

**What's happening:**

- We **add the counter account** to the mockchain builder
- We **add the increment note** as a full output note to the mockchain
- We **build the mockchain** - now we have a complete testing environment ready to use

### 5. Creating and Executing the Transaction

```rust
let tx_context = mock_chain.
    .build_tx_context(counter_account.id(), &[counter_note.id()], &[])?
    .build()?;

let executed_transaction = tx_context.execute().await?;
```

**What's happening:**

- We **build the transaction context** using the counter account and counter note
- We **execute the transaction** - this runs the increment logic locally in the mockchain

### 6. Verifying the Results

```rust
// Apply the account delta to the counter account
counter_account.apply_delta(&executed_transaction.account_delta())?;

// Add the executed transaction to the mockchain
mock_chain.add_pending_executed_transaction(&executed_transaction)?;
mock_chain.prove_next_block()?;

// Get the count from the updated counter account
let count = counter_account
    .storage()
    .get_map_item(0, count_storage_key)?;

// Assert that the count value is equal to 1 after executing the transaction
assert_eq!(
    count,
    Word::from([Felt::new(0), Felt::new(0), Felt::new(0), Felt::new(1)]),
    "Count value is not equal to 1"
);
```

**What's happening:**

- We **apply the account delta** from the executed transaction to the counter account to update its state
- We **add the executed transaction** to the mockchain
- We **read the counter value** from storage using the same key we initialized
- We **assert that the count equals 1** - verifying the increment operation worked correctly

The test verifies the complete flow: the increment note successfully increments the counter from 0 to 1, proving our smart contract works as expected.

## Next Steps

Congratulations! You've successfully completed the Miden smart contract quick start guide. You're now equipped to build more sophisticated smart contracts on Miden. Consider exploring:

To deepen your knowledge, we recommend exploring the following resources:

- Visit the [Tutorials section](/miden-tutorials) for detailed, hands-on guides on topics such as contract interactions, advanced storage, custom note scripting, and integrating with external applications via the Miden Web Client.
- For in-depth technical explanations of core concepts, consult the [Protocol section](/miden-base) of the documentation. Here you'll find comprehensive information on Miden's architecture, account model, transaction lifecycle, and the underlying zero-knowledge technology that powers the network.

The foundational patterns and concepts you've practiced in this Quick Start will enable you to build complex, privacy-preserving applications on the Miden network. Continue with the resources above to take your development further!
````

## File: docs/builder/quick-start/accounts.md
````markdown
---
sidebar_position: 2
title: Accounts
description: Learn how to create and manage Miden accounts programmatically using Rust and TypeScript.
---

import { CodeTabs } from '@site/src/components';

# Accounts

Miden's account model is fundamentally different from traditional blockchains. Let's explore how to create and manage accounts programmatically.

## Understanding Miden Accounts

Before diving into account creation, it's essential to understand what makes Miden accounts unique compared to traditional blockchain addresses.

**What Makes Miden Accounts Special:**

- **Smart Contract Wallets**: Every account is a programmable smart contract that can hold assets and execute custom logic
- **Modular Design**: Accounts are composed of reusable components (authentication, wallet functionality, etc.)
- **Privacy Levels**: Choose between public or private storage modes

Miden accounts differ from traditional blockchain addresses in fundamental ways.

**Account Architecture:**

- Every account is a **smart contract** with programmable logic
- Accounts can store **assets** (fungible and non-fungible tokens) in their vault
- Each account has **storage slots** for custom data
- Accounts are composed of **modular components** for different functionalities

**Storage Modes:**

- **Public**: All state visible onchain (transparent operations)
- **Private**: Only commitments onchain, full state held privately

### Account Structure

Every Miden account contains these core components:

- **Vault**: Secure asset storage
- **Storage**: Key-value data store (up to 255 slots)
- **Code**: Smart contract logic
- **Nonce**: Anti-replay counter
- **Components**: Modular functionality (authentication, wallet, etc.)

<details>
<summary>Account Struct</summary>

```rust
pub struct MidenAccount {
    /// Immutable, 120-bit ID encoding type, storage mode and version.
    pub id: [u8; 15],

    /// Determines mutability of the account (immutable, mutable).
    pub account_type: AccountType,

    /// Storage placement preference (public/private).
    pub storage_mode: StorageMode,

    /// Root commitment of the account CODE (MAST root).
    pub code_commitment: [u8; 32],

    /// Root commitment of the account STORAGE (slots / maps).
    /// Think of this as the "root hash" of the Account's storage merkle tree.
    pub storage_commitment: [u8; 32],

    /// Vault commitment. For compact headers we keep only an optional aggregate commitment.
    /// Indexers can materialize a richer view (e.g., list of assets) offchain.
    pub vault_commitment: Option<[u8; 32]>,

    /// Monotonically increasing counter; must increment exactly once when state changes.
    pub nonce: u64,

    /// Merged set of account components that defined this account's interface and storage.
    /// Accounts are composed by merging components (e.g. wallet component + an auth component).
    pub components: Vec<ComponentDescriptor>,

    /// Authentication procedure metadata (e.g. "RpoFalcon512").
    pub authentication: AuthenticationDescriptor,
}
```

**Account Types:**

```rust
pub enum AccountType {
    // Faucet that can issue fungible assets
    FungibleFaucet = 2,
    // Faucet that can issue non-fungible assets
    NonFungibleFaucet = 3,
    // Regular account with immutable code
    RegularAccountImmutableCode = 0,
    /// Regular account with updateable code
    RegularAccountUpdatableCode = 1,
}
```

**Storage Modes:**

```rust
pub enum StorageMode {
    /// State stored onchain and publicly readable.
    Public,
    /// Only a commitment is onchain; full state is held privately by the owner.
    Private,
}
```

</details>

## Set Up Development Environment

To run the code examples in this guide, you'll need to set up a development environment for either Rust or TypeScript.

### Rust Environment

Create a new Miden Rust project:

```bash title=">_ Terminal"
miden new my-project
cd my-project/integration/
```

For each code example, create a new binary file:

```bash title=">_ Terminal"
touch src/bin/demo.rs
```

Copy the Rust code example into the file, then run:

```bash title=">_ Terminal"
cargo run --bin demo --release
```

### TypeScript Environment

Create a new Miden frontend project:

```bash title=">_ Terminal"
yarn create-miden-app
cd miden-app/
```

For each code example, create a demo file:

```bash title=">_ Terminal"
touch src/lib/demo.ts
```

Copy the TypeScript code into the file, then import and call the `demo()` function in your `App.tsx`. Run the project:

```bash title=">_ Terminal"
yarn dev
# or
npm run dev
```

:::tip
For detailed frontend setup guidance, see the [Web Client tutorial](/miden-tutorials/web-client/create_deploy_tutorial#step-2-set-up-the-webclient).
:::

## Creating Accounts Programmatically

Let's start by creating accounts using the Miden client libraries:

<CodeTabs
tsFilename="src/lib/account.ts"
rustFilename="integration/src/bin/account.rs"
example={{
rust: {
code: `use miden_client::{
    account::{
        component::{AuthRpoFalcon512, BasicWallet},
        AccountBuilder, AccountStorageMode, AccountType,
    },
    auth::AuthSecretKey,
    builder::ClientBuilder,
    crypto::rpo_falcon512::SecretKey,
    keystore::FilesystemKeyStore,
    rpc::{Endpoint, GrpcClient},
};
use miden_client_sqlite_store::ClientBuilderSqliteExt;
use rand::RngCore;
use std::sync::Arc;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Initialize RPC connection
    let endpoint = Endpoint::testnet();
    let timeout_ms = 10_000;
    let rpc_client = Arc::new(GrpcClient::new(&endpoint, timeout_ms));

    // Initialize keystore
    let keystore_path = std::path::PathBuf::from("./keystore");
    let keystore: FilesystemKeyStore<rand::prelude::StdRng> =
        FilesystemKeyStore::new(keystore_path).unwrap().into();

    let store_path = std::path::PathBuf::from("./store.sqlite3");

    // Initialize client to connect with the Miden Testnet.
    // NOTE: The client is our entry point to the Miden network.
    // All interactions with the network go through the client.
    let mut client = ClientBuilder::new()
        .rpc(rpc_client)
        .sqlite_store(store_path)
        .authenticator(keystore.clone().into())
        .in_debug_mode(true.into())
        .build()
        .await?;

    client.sync_state().await?;

    let mut init_seed = [0_u8; 32];
    client.rng().fill_bytes(&mut init_seed);

    let key_pair = SecretKey::with_rng(client.rng());

    let builder = AccountBuilder::new(init_seed)
        .account_type(AccountType::RegularAccountUpdatableCode)
        .storage_mode(AccountStorageMode::Public)
        .with_auth_component(AuthRpoFalcon512::new(
            key_pair.public_key().to_commitment().into(),
        ))
        .with_component(BasicWallet);

    let account = builder.build()?;

    client.add_account(&account, false).await?;

    keystore.add_key(&AuthSecretKey::RpoFalcon512(key_pair))?;

    println!("Account ID: {}", account.id());
    println!("No assets in Vault: {:?}", account.vault().is_empty());

    Ok(())
}
` },
  typescript: {
    code:`import { WebClient, AccountStorageMode } from "@demox-labs/miden-sdk";

export async function demo() {
    // Initialize client to connect with the Miden Testnet.
    // NOTE: The client is our entry point to the Miden network.
    // All interactions with the network go through the client.
    const nodeEndpoint = "https://rpc.testnet.miden.io:443";

    // Initialize client
    const client = await WebClient.createClient(nodeEndpoint);
    await client.syncState();

    // Create new wallet account
    const account = await client.newWallet(
        AccountStorageMode.public(), // Public: account state is visible onchain
        true // Mutable: account code can be upgraded later
    );

    console.log("Account ID:", account.id().toString());
    console.log(
        "No Assets in Vault:",
        account.vault().fungibleAssets().length === 0
    );
}
`
}
}}
/>

<details>
<summary>Expected output</summary>

```text
Account ID: 0x94733054a40d1610178320cc0c8060
No Assets in Vault: true
```

</details>

## Creating a Token Faucet

Before we can work with tokens, we need a source of tokens. Let's create a fungible token faucet:

<CodeTabs
tsFilename="src/lib/faucet.ts"
rustFilename="integration/src/bin/faucet.rs"
example={{
rust: {
code: `use miden_client::{
    account::{
        component::{AuthRpoFalcon512, BasicFungibleFaucet},
        AccountBuilder, AccountStorageMode, AccountType,
    },
    asset::TokenSymbol,
    auth::AuthSecretKey,
    builder::ClientBuilder,
    crypto::rpo_falcon512::SecretKey,
    keystore::FilesystemKeyStore,
    rpc::{Endpoint, GrpcClient},
    Felt,
};
use miden_client_sqlite_store::ClientBuilderSqliteExt;
use rand::RngCore;
use std::sync::Arc;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Initialize RPC connection
    let endpoint = Endpoint::testnet();
    let timeout_ms = 10_000;
    let rpc_client = Arc::new(GrpcClient::new(&endpoint, timeout_ms));

    // Initialize keystore
    let keystore_path = std::path::PathBuf::from("./keystore");
    let keystore: FilesystemKeyStore<rand::prelude::StdRng> =
        FilesystemKeyStore::new(keystore_path).unwrap().into();

    let store_path = std::path::PathBuf::from("./store.sqlite3");

    // Initialize client to connect with the Miden Testnet.
    // NOTE: The client is our entry point to the Miden network.
    // All interactions with the network go through the client.
    let mut client = ClientBuilder::new()
        .rpc(rpc_client)
        .sqlite_store(store_path)
        .authenticator(keystore.clone().into())
        .in_debug_mode(true.into())
        .build()
        .await?;

    client.sync_state().await?;

    // Faucet seed
    let mut init_seed = [0u8; 32];
    client.rng().fill_bytes(&mut init_seed);

    // Faucet parameters
    let symbol = TokenSymbol::new("TEST")?;
    let decimals = 8;
    let max_supply = Felt::new(1_000_000);

    // Generate key pair
    let key_pair = SecretKey::with_rng(client.rng());

    // Build the account
    let builder = AccountBuilder::new(init_seed)
        .account_type(AccountType::FungibleFaucet)
        .storage_mode(AccountStorageMode::Public)
        .with_auth_component(AuthRpoFalcon512::new(
            key_pair.public_key().to_commitment().into(),
        ))
        .with_component(BasicFungibleFaucet::new(symbol, decimals, max_supply)?);

    let faucet_account = builder.build()?;

    client.add_account(&faucet_account, false).await?;
    keystore.add_key(&AuthSecretKey::RpoFalcon512(key_pair))?;

    println!("Faucet account ID: {}", faucet_account.id());

    Ok(())
}
`},
  typescript: {
    code:`import { WebClient, AccountStorageMode } from "@demox-labs/miden-sdk";

export async function demo() {
    // Initialize client to connect with the Miden Testnet.
    // NOTE: The client is our entry point to the Miden network.
    // All interactions with the network go through the client.
    const nodeEndpoint = "https://rpc.testnet.miden.io:443";

    // Initialize client
    const client = await WebClient.createClient(nodeEndpoint);
    await client.syncState();

    const symbol = "TEST";
    const decimals = 8;
    const initialSupply = BigInt(10_000_000 * 10 ** decimals);

    const faucet = await client.newFaucet(
        AccountStorageMode.public(),
        false,
        symbol,
        decimals,
        initialSupply
    );

    console.log("Faucet account ID:", faucet.id().toString());
}
`
}
}}
/>

<details>
<summary>Expected output</summary>

```text
Faucet account ID: 0xde0ba31282f7522046d3d4af40722b
```

</details>

## Key Takeaways

**Account Types:**

- **Regular Accounts**: Standard smart contract wallets that can hold assets and execute custom logic
- **Faucet Accounts**: Specialized accounts with minting permissions for tokens

**Storage Modes:**

- **Public**: Account state is fully transparent and visible onchain
- **Private**: Only cryptographic commitments are stored onchain, with full state maintained privately

**Modular Components:**

- **BasicWallet**: Provides asset management functionality
- **BasicFungibleFaucet**: Enables token minting capabilities
- **AuthRpoFalcon512**: Handles cryptographic authentication

Now that you understand how to create accounts and faucets, you're ready to learn about Miden's unique transaction model. Continue to [Notes & Transactions](./notes) to explore how assets move between accounts using notes.

---
````

## File: docs/builder/tools/index.md
````markdown
---
title: Tools
sidebar_position: 1
---

<!--
ARCHITECTURE NOTE:
Client documentation is canonical in versioned_docs/version-X.Y/miden-client/.
This landing page exists only for the "current/next" version.
Full client docs are available by selecting a released version.
-->

# Tools

:::info Version Note
Full client documentation (Rust Client, Web Client, CLI reference) is available in **released versions only**. Please select a version from the dropdown (e.g., 0.12, 0.11) to access the complete client documentation.
:::

## Miden Client

The Miden client has three main components:

1. **Miden client library** - A Rust library for integrating with the Miden rollup
2. **Miden client CLI** - Command-line interface for interacting with the network
3. **Miden web client** - Browser-based interface for managing accounts and transactions

## Additional Tools

- **Playground** - Interactive environment for testing Miden assembly
- **Explorer** - Block explorer for the Miden network
````

## File: docs/builder/_category_.json
````json
{
  "label": "Builder",
  "position": 1,
  "collapsible": false,
  "collapsed": false
}
````

## File: docs/design/_category_.json
````json
{
  "label": "Design",
  "position": 2,
  "collapsible": false,
  "collapsed": false
}
````

## File: docs/builder/develop/tutorials/rust-compiler/miden-bank/02-constants-constraints.md
````markdown
---
sidebar_position: 2
title: "Part 2: Constants and Constraints"
description: "Learn how to define constants for business rules and use assertions to validate transactions in Miden Rust contracts."
---

# Part 2: Constants and Constraints

In this section, you'll learn how to define business rules using constants and enforce them with assertions. We'll implement deposit limits and see how failed constraints cause transactions to be rejected.

## What You'll Build in This Part

By the end of this section, you will have:

- Defined constants for business rules
- Used `assert!()` for transaction validation
- Learned safe Felt comparison with `.as_u64()`
- Added a deposit method skeleton with validation
- **Verified constraints work** by testing that invalid operations fail

## Building on Part 1

In Part 1, we set up the Bank's storage structure. Now we'll add business rules:

```text
Part 1:                          Part 2:
┌──────────────────┐             ┌──────────────────┐
│ Bank             │             │ Bank             │
│ ─────────────────│    ──►      │ ─────────────────│
│ + initialize()   │             │ + initialize()   │
│ + get_balance()  │             │ + get_balance()  │
│                  │             │ + deposit()      │ ◄── NEW (skeleton)
│                  │             │ + MAX_DEPOSIT    │ ◄── NEW constant
└──────────────────┘             └──────────────────┘
```

## Defining Constants

Constants in Miden Rust contracts work just like regular Rust constants:

```rust title="contracts/bank-account/src/lib.rs"
/// Maximum allowed deposit amount per transaction.
///
/// Value: 1,000,000 tokens (arbitrary limit for demonstration)
const MAX_DEPOSIT_AMOUNT: u64 = 1_000_000;
```

Use constants for:

- Business rule limits (max amounts, timeouts)
- Magic numbers that need documentation
- Values used in multiple places

:::info Constants vs Storage
Constants are compiled into the contract code and cannot change. Use storage slots for values that need to be modified at runtime.
:::

## The assert!() Macro

The `assert!()` macro validates conditions during transaction execution:

```rust title="contracts/bank-account/src/lib.rs"
pub fn initialize(&mut self) {
    // Check not already initialized
    let current: Word = self.initialized.read();
    assert!(
        current[0].as_u64() == 0,
        "Bank already initialized"
    );

    // Set initialized flag to 1
    let initialized_word = Word::from([felt!(1), felt!(0), felt!(0), felt!(0)]);
    self.initialized.write(initialized_word);
}
```

When an assertion fails:

1. The Miden VM execution halts
2. No valid proof can be generated
3. The transaction is rejected

This is the primary mechanism for enforcing business rules in Miden contracts.

## Safe Felt Comparisons

:::warning Pitfall: Felt Comparison Operators
Never use `<`, `>`, `<=`, or `>=` operators directly on `Felt` values. They produce incorrect results due to field element ordering.
:::

**Wrong approach:**

```rust
// DON'T DO THIS - produces incorrect results
if deposit_amount > felt!(1_000_000) {
    // This comparison is unreliable!
}
```

**Correct approach:**

```rust
// CORRECT - convert to u64 first
if deposit_amount.as_u64() > MAX_DEPOSIT_AMOUNT {
    // This works correctly
}
```

The `.as_u64()` method extracts the underlying 64-bit integer from a Felt, allowing standard Rust comparisons.

## Step 1: Add the Constant and Deposit Method

Update your `contracts/bank-account/src/lib.rs` to add the constant and a deposit method skeleton:

```rust title="contracts/bank-account/src/lib.rs" {1-4,36-55}
/// Maximum allowed deposit amount per transaction.
///
/// Value: 1,000,000 tokens (arbitrary limit for demonstration)
const MAX_DEPOSIT_AMOUNT: u64 = 1_000_000;

#[component]
impl Bank {
    /// Initialize the bank account, enabling deposits.
    pub fn initialize(&mut self) {
        let current: Word = self.initialized.read();
        assert!(
            current[0].as_u64() == 0,
            "Bank already initialized"
        );

        let initialized_word = Word::from([felt!(1), felt!(0), felt!(0), felt!(0)]);
        self.initialized.write(initialized_word);
    }

    /// Get the balance for a depositor.
    pub fn get_balance(&self, depositor: AccountId) -> Felt {
        let key = Word::from([depositor.prefix, depositor.suffix, felt!(0), felt!(0)]);
        self.balances.get(&key)
    }

    /// Check that the bank is initialized.
    fn require_initialized(&self) {
        let current: Word = self.initialized.read();
        assert!(
            current[0].as_u64() == 1,
            "Bank not initialized - deposits not enabled"
        );
    }

    /// Deposit assets into the bank.
    /// For now, this just validates constraints - we'll add asset handling in Part 3.
    pub fn deposit(&mut self, depositor: AccountId, deposit_asset: Asset) {
        // ========================================================================
        // CONSTRAINT: Bank must be initialized
        // ========================================================================
        self.require_initialized();

        // Extract the fungible amount from the asset
        let deposit_amount = deposit_asset.inner[0];

        // ========================================================================
        // CONSTRAINT: Maximum deposit amount check
        // ========================================================================
        assert!(
            deposit_amount.as_u64() <= MAX_DEPOSIT_AMOUNT,
            "Deposit amount exceeds maximum allowed"
        );

        // We'll add balance tracking and asset handling in Part 3
        // For now, just validate the constraints
    }
}
```

### The require_initialized() Guard

We use a helper method to check initialization state:

```rust
fn require_initialized(&self) {
    let current: Word = self.initialized.read();
    assert!(
        current[0].as_u64() == 1,
        "Bank not initialized - deposits not enabled"
    );
}
```

This pattern:

- Centralizes the initialization check
- Provides a clear error message
- Can be reused across multiple methods

## How Assertions Affect Proving

When an assertion fails in the Miden VM:

```text
Transaction Execution Flow:
┌─────────────────────┐
│ User submits TX     │
└──────────┬──────────┘
           ▼
┌─────────────────────┐
│ VM executes code    │
└──────────┬──────────┘
           ▼
    ┌──────┴──────┐
    │ Assertion?  │
    └──────┬──────┘
     Pass  │  Fail
    ┌──────┴──────┐
    ▼             ▼
┌────────┐   ┌────────────┐
│ Prove  │   │ TX Rejected│
│ Success│   │ No Proof   │
└────────┘   └────────────┘
```

Key points:

- Failed assertions prevent proof generation
- No state changes occur if the transaction fails
- Error messages help with debugging

## Step 2: Build and Verify

Build the updated contract:

```bash title=">_ Terminal"
cd contracts/bank-account
miden build
```

## Try It: Verify Constraints Work

Let's write a test to verify our constraints work correctly. This test verifies that depositing without initialization fails:

```rust title="integration/tests/part2_constraints_test.rs"
use integration::helpers::{
    build_project_in_dir, create_testing_account_from_package, AccountCreationConfig,
};
use miden_client::account::{StorageMap, StorageSlot};
use miden_client::Word;
use std::{path::Path, sync::Arc};

/// Test that our constraint logic is set up correctly
#[tokio::test]
async fn test_constraints_are_defined() -> anyhow::Result<()> {
    // Build the bank account contract to verify it compiles with constraints
    let bank_package = Arc::new(build_project_in_dir(
        Path::new("../contracts/bank-account"),
        true,
    )?);

    // Create an uninitialized bank account
    let bank_cfg = AccountCreationConfig {
        storage_slots: vec![
            StorageSlot::Value(Word::default()),  // initialized = 0
            StorageSlot::Map(StorageMap::with_entries([])?),
        ],
        ..Default::default()
    };

    let bank_account =
        create_testing_account_from_package(bank_package.clone(), bank_cfg).await?;

    // Verify the bank starts uninitialized
    let initialized = bank_account.storage().get_item(0)?;
    assert_eq!(
        initialized[0].as_int(),
        0,
        "Bank should start uninitialized"
    );

    println!("Bank account created with constraints!");
    println!("  - MAX_DEPOSIT_AMOUNT: 1,000,000");
    println!("  - require_initialized() guard in place");
    println!("  - Initialization status: {}", initialized[0].as_int());
    println!("\nPart 2 constraints test passed!");

    Ok(())
}
```

Run the test from the project root:

```bash title=">_ Terminal"
cargo test --package integration part2_constraints -- --nocapture
```

<details>
<summary>Expected output</summary>

```text
   Compiling integration v0.1.0 (/path/to/miden-bank/integration)
    Finished `test` profile [unoptimized + debuginfo] target(s)
     Running tests/part2_constraints_test.rs

running 1 test
Bank account created with constraints!
  - MAX_DEPOSIT_AMOUNT: 1,000,000
  - require_initialized() guard in place
  - Initialization status: 0

Part 2 constraints test passed!
test test_constraints_are_defined ... ok

test result: ok. 1 passed; 0 failed; 0 ignored
```

</details>

:::tip Preview: Testing Failed Assertions
In Part 4, when we have the deposit note script, we'll write a full test that verifies:
1. Depositing without initialization fails
2. Depositing amounts over MAX_DEPOSIT_AMOUNT fails

For now, the constraint logic is in place and we've verified the contract compiles.
:::

## Common Constraint Patterns

### Balance Checks (Preview for Part 3)

```rust
fn require_sufficient_balance(&self, depositor: AccountId, amount: Felt) {
    let balance = self.get_balance(depositor);
    assert!(
        balance.as_u64() >= amount.as_u64(),
        "Insufficient balance"
    );
}
```

:::danger Critical: Always Validate Before Subtraction
This pattern is **mandatory** for any operation that subtracts from a balance. Miden uses field element (Felt) arithmetic, which is modular. Without this check, subtracting more than the balance would NOT cause an error - instead, the value would silently wrap around to a large positive number, effectively allowing unlimited withdrawals. See [Common Pitfalls](../pitfalls#felt-arithmetic-underflowoverflow) for more details.
:::

### State Checks

```rust
fn require_not_paused(&self) {
    let paused: Word = self.paused.read();
    assert!(
        paused[0].as_u64() == 0,
        "Contract is paused"
    );
}
```

## Complete Code for This Part

Here's the full `lib.rs` after Part 2:

<details>
<summary>Click to expand full code</summary>

```rust title="contracts/bank-account/src/lib.rs"
#![no_std]
#![feature(alloc_error_handler)]

#[macro_use]
extern crate alloc;

use miden::*;

/// Maximum allowed deposit amount per transaction.
const MAX_DEPOSIT_AMOUNT: u64 = 1_000_000;

/// Bank account component that tracks depositor balances.
#[component]
struct Bank {
    #[storage(slot(0), description = "initialized")]
    initialized: Value,

    #[storage(slot(1), description = "balances")]
    balances: StorageMap,
}

#[component]
impl Bank {
    /// Initialize the bank account, enabling deposits.
    pub fn initialize(&mut self) {
        let current: Word = self.initialized.read();
        assert!(
            current[0].as_u64() == 0,
            "Bank already initialized"
        );

        let initialized_word = Word::from([felt!(1), felt!(0), felt!(0), felt!(0)]);
        self.initialized.write(initialized_word);
    }

    /// Get the balance for a depositor.
    pub fn get_balance(&self, depositor: AccountId) -> Felt {
        let key = Word::from([depositor.prefix, depositor.suffix, felt!(0), felt!(0)]);
        self.balances.get(&key)
    }

    /// Check that the bank is initialized.
    fn require_initialized(&self) {
        let current: Word = self.initialized.read();
        assert!(
            current[0].as_u64() == 1,
            "Bank not initialized - deposits not enabled"
        );
    }

    /// Deposit assets into the bank.
    pub fn deposit(&mut self, depositor: AccountId, deposit_asset: Asset) {
        // CONSTRAINT: Bank must be initialized
        self.require_initialized();

        let deposit_amount = deposit_asset.inner[0];

        // CONSTRAINT: Maximum deposit amount check
        assert!(
            deposit_amount.as_u64() <= MAX_DEPOSIT_AMOUNT,
            "Deposit amount exceeds maximum allowed"
        );

        // Balance tracking and asset handling added in Part 3
    }
}
```

</details>

## Key Takeaways

1. **Constants** define immutable business rules at compile time
2. **`assert!()`** enforces constraints - failures reject the transaction
3. **Always use `.as_u64()`** for Felt comparisons, never direct operators
4. **Helper methods** like `require_initialized()` centralize validation logic
5. **Failed assertions** mean no valid proof can be generated

:::tip View Complete Source
See the complete constraint implementation in the [miden-bank repository](https://github.com/keinberger/miden-bank/blob/main/contracts/bank-account/src/lib.rs).
:::

## Next Steps

Now that you can define and enforce business rules, let's learn how to handle assets in [Part 3: Asset Management](./03-asset-management).
````

## File: docs/builder/develop/tutorials/rust-compiler/miden-bank/03-asset-management.md
````markdown
---
sidebar_position: 3
title: "Part 3: Asset Management"
description: "Learn how to handle fungible assets in Miden Rust contracts using vault operations and balance tracking."
---

# Part 3: Asset Management

In this section, you'll learn how to receive and send assets in Miden accounts. We'll complete the deposit logic that receives tokens into the bank's vault and tracks balances per depositor.

## What You'll Build in This Part

By the end of this section, you will have:

- Understood the `Asset` type structure for fungible assets
- Implemented full deposit logic with `native_account::add_asset()`
- Learned about balance key design for per-user, per-asset tracking
- Added a withdraw method skeleton (to be completed in Part 7)
- **Verified deposits work** with a MockChain test

## Building on Part 2

In Part 2, we added constraints. Now we'll complete the deposit function with actual asset handling:

```text
Part 2:                          Part 3:
┌──────────────────┐             ┌──────────────────┐
│ Bank             │             │ Bank             │
│ ─────────────────│    ──►      │ ─────────────────│
│ + deposit()      │             │ + deposit()      │ ◄── COMPLETE
│   (skeleton)     │             │   + balance tracking
│                  │             │   + vault operations
│                  │             │ + withdraw()     │ ◄── NEW (skeleton)
└──────────────────┘             └──────────────────┘
```

## The Asset Type

Miden represents fungible assets as a `Word` (4 Felts) with this layout:

```text
Asset Layout: [amount, 0, faucet_suffix, faucet_prefix]
              ━━━━━━━  ━  ━━━━━━━━━━━━━  ━━━━━━━━━━━━━
              index 0  1      index 2        index 3
```

| Index | Field           | Description                          |
| ----- | --------------- | ------------------------------------ |
| 0     | `amount`        | The quantity of tokens               |
| 1     | (reserved)      | Always 0 for fungible assets         |
| 2     | `faucet_suffix` | Second part of the faucet account ID |
| 3     | `faucet_prefix` | First part of the faucet account ID  |

Access these fields through `asset.inner`:

```rust
let amount = deposit_asset.inner[0];           // The token amount
let faucet_suffix = deposit_asset.inner[2];    // Faucet ID suffix
let faucet_prefix = deposit_asset.inner[3];    // Faucet ID prefix
```

## Receiving Assets with add_asset()

The `native_account::add_asset()` function adds an asset to the account's vault:

```rust
// Add asset to the bank's vault
native_account::add_asset(deposit_asset);
```

When called:

- The asset is added to the account's internal vault
- The vault tracks all assets the account holds
- Multiple assets of the same type are combined automatically

:::info Vault vs Balance Tracking
The vault is managed by the Miden protocol automatically. Our `StorageMap` for balances is an **application-level** tracking of who deposited what, separate from the protocol-level vault.
:::

## Step 1: Complete the Deposit Function

Update `contracts/bank-account/src/lib.rs` to complete the deposit function with balance tracking and vault operations:

```rust title="contracts/bank-account/src/lib.rs"
/// Deposit assets into the bank.
pub fn deposit(&mut self, depositor: AccountId, deposit_asset: Asset) {
    // ========================================================================
    // CONSTRAINT: Bank must be initialized
    // ========================================================================
    self.require_initialized();

    // Extract the fungible amount from the asset
    let deposit_amount = deposit_asset.inner[0];

    // ========================================================================
    // CONSTRAINT: Maximum deposit amount check
    // ========================================================================
    assert!(
        deposit_amount.as_u64() <= MAX_DEPOSIT_AMOUNT,
        "Deposit amount exceeds maximum allowed"
    );

    // ========================================================================
    // UPDATE BALANCE
    // ========================================================================
    // Create key from depositor's AccountId and asset faucet ID
    // This allows tracking balances per depositor per asset type
    let key = Word::from([
        depositor.prefix,
        depositor.suffix,
        deposit_asset.inner[3], // asset prefix (faucet)
        deposit_asset.inner[2], // asset suffix (faucet)
    ]);

    // Update balance: current + deposit_amount
    let current_balance: Felt = self.balances.get(&key);
    let new_balance = current_balance + deposit_amount;
    self.balances.set(key, new_balance);

    // ========================================================================
    // ADD ASSET TO VAULT
    // ========================================================================
    native_account::add_asset(deposit_asset);
}
```

### Balance Key Design

We construct a composite key for balance tracking:

```rust
let key = Word::from([
    depositor.prefix,      // Who deposited
    depositor.suffix,
    deposit_asset.inner[3], // Which asset type (faucet ID prefix)
    deposit_asset.inner[2], // Which asset type (faucet ID suffix)
]);
```

This design allows:

- **Per-depositor tracking**: Each user has their own balance
- **Per-asset tracking**: Different token types are tracked separately
- **Unique keys**: The combination ensures no collisions

## Step 2: Add the Withdraw Method Skeleton

Now add a withdraw method skeleton. We'll complete it in Part 7 when we cover output notes.

:::danger Critical Security Warning: Felt Arithmetic Underflow

Miden uses **modular field arithmetic**. Subtracting a larger value from a smaller one does **NOT** cause an error - it **silently wraps** to a massive positive number!

For example: `50 - 100` does NOT equal `-50`. Instead, it equals a number close to `2^64`.

**You MUST validate before ANY subtraction:**

```rust
// WRONG - DANGEROUS! Silent underflow if balance < amount
let new_balance = current_balance - withdraw_amount;

// CORRECT - Always validate first
assert!(
    current_balance.as_u64() >= withdraw_amount.as_u64(),
    "Withdrawal amount exceeds available balance"
);
let new_balance = current_balance - withdraw_amount;
```

This is not optional - it's a **security requirement** for any financial operation.
:::

Add this method to your Bank impl block:

```rust title="contracts/bank-account/src/lib.rs"
/// Withdraw assets from the bank.
/// Creates a P2ID note to send assets back to the depositor.
pub fn withdraw(
    &mut self,
    depositor: AccountId,
    withdraw_asset: Asset,
    serial_num: Word,
    tag: Felt,
    aux: Felt,
    note_type: Felt,
) {
    // ========================================================================
    // CONSTRAINT: Bank must be initialized
    // ========================================================================
    self.require_initialized();

    // Extract the fungible amount from the asset
    let withdraw_amount = withdraw_asset.inner[0];

    // Create key from depositor's AccountId and asset faucet ID
    let key = Word::from([
        depositor.prefix,
        depositor.suffix,
        withdraw_asset.inner[3],
        withdraw_asset.inner[2],
    ]);

    // ========================================================================
    // CRITICAL: Validate balance BEFORE subtraction
    // ========================================================================
    // Get current balance and validate sufficient funds exist.
    // This check is critical: Felt arithmetic is modular, so subtracting
    // more than the balance would silently wrap to a large positive number.
    let current_balance: Felt = self.balances.get(&key);
    assert!(
        current_balance.as_u64() >= withdraw_amount.as_u64(),
        "Withdrawal amount exceeds available balance"
    );

    // Now safe to subtract
    let new_balance = current_balance - withdraw_amount;
    self.balances.set(key, new_balance);

    // Create a P2ID note to send the requested asset back to the depositor
    // We'll implement create_p2id_note() in Part 7
    self.create_p2id_note(serial_num, &withdraw_asset, depositor, tag, aux, note_type);
}
```

For now, add a placeholder for `create_p2id_note()`:

```rust title="contracts/bank-account/src/lib.rs"
/// Create a P2ID note to send assets to a recipient.
/// Full implementation in Part 7.
fn create_p2id_note(
    &mut self,
    _serial_num: Word,
    _asset: &Asset,
    _recipient_id: AccountId,
    _tag: Felt,
    _aux: Felt,
    _note_type: Felt,
) {
    // Placeholder - implemented in Part 7: Output Notes
    // For now, this will cause a compile error if actually called
    todo!("P2ID note creation - see Part 7")
}
```

## Step 3: Build and Verify

Build the contract:

```bash title=">_ Terminal"
cd contracts/bank-account
miden build
```

## Try It: Verify Deposits Work

Let's write a test to verify our deposit logic works correctly:

```rust title="integration/tests/part3_deposit_test.rs"
use integration::helpers::{
    build_project_in_dir, create_testing_account_from_package,
    create_testing_note_from_package, AccountCreationConfig, NoteCreationConfig,
};
use miden_client::account::{StorageMap, StorageSlot};
use miden_client::note::NoteAssets;
use miden_client::transaction::OutputNote;
use miden_client::{Felt, Word};
use miden_objects::asset::{Asset, FungibleAsset};
use miden_objects::transaction::TransactionScript;
use miden_testing::{Auth, MockChain};
use std::{path::Path, sync::Arc};

#[tokio::test]
async fn test_deposit_updates_balance() -> anyhow::Result<()> {
    // =========================================================================
    // SETUP
    // =========================================================================
    let mut builder = MockChain::builder();

    // Create a faucet for test tokens
    let faucet = builder.add_new_faucet(Auth::NoAuth, "TEST", 10_000_000)?;

    // Create sender wallet with tokens
    let sender = builder.add_existing_wallet(Auth::BasicAuth)?;

    // Build contracts
    let bank_package = Arc::new(build_project_in_dir(
        Path::new("../contracts/bank-account"),
        true,
    )?);

    let deposit_note_package = Arc::new(build_project_in_dir(
        Path::new("../contracts/deposit-note"),
        true,
    )?);

    let init_tx_script_package = Arc::new(build_project_in_dir(
        Path::new("../contracts/init-tx-script"),
        true,
    )?);

    // Create the bank account with storage slots
    let bank_cfg = AccountCreationConfig {
        storage_slots: vec![
            StorageSlot::Value(Word::default()),  // Slot 0: initialized = 0
            StorageSlot::Map(StorageMap::with_entries([])?),  // Slot 1: balances
        ],
        ..Default::default()
    };

    let mut bank_account =
        create_testing_account_from_package(bank_package.clone(), bank_cfg).await?;

    // Add to mock chain
    builder.add_account(bank_account.clone())?;

    let mut mock_chain = builder.build()?;

    // =========================================================================
    // STEP 1: Initialize the bank
    // =========================================================================
    let init_program = init_tx_script_package.unwrap_program();
    let init_tx_script = TransactionScript::new((*init_program).clone());

    let init_tx_context = mock_chain
        .build_tx_context(bank_account.id(), &[], &[])?
        .tx_script(init_tx_script)
        .build()?;

    let executed_init = init_tx_context.execute().await?;
    bank_account.apply_delta(&executed_init.account_delta())?;
    mock_chain.add_pending_executed_transaction(&executed_init)?;
    mock_chain.prove_next_block()?;

    // Verify initialization
    let initialized = bank_account.storage().get_item(0)?;
    assert_eq!(
        initialized[0].as_int(),
        1,
        "Bank should be initialized"
    );
    println!("Bank initialized successfully!");

    // =========================================================================
    // STEP 2: Create and execute deposit
    // =========================================================================
    let deposit_amount: u64 = 1000;
    let fungible_asset = FungibleAsset::new(faucet.id(), deposit_amount)?;
    let note_assets = NoteAssets::new(vec![Asset::Fungible(fungible_asset)])?;

    let deposit_note = create_testing_note_from_package(
        deposit_note_package.clone(),
        sender.id(),
        NoteCreationConfig {
            assets: note_assets,
            ..Default::default()
        },
    )?;

    // Add note to mock chain
    mock_chain.add_note(OutputNote::Full(deposit_note.clone().into()))?;

    // Execute deposit transaction
    let tx_context = mock_chain
        .build_tx_context(bank_account.id(), &[deposit_note.id()], &[])?
        .build()?;

    let executed_transaction = tx_context.execute().await?;
    bank_account.apply_delta(&executed_transaction.account_delta())?;
    mock_chain.add_pending_executed_transaction(&executed_transaction)?;
    mock_chain.prove_next_block()?;

    println!("Deposit transaction executed!");

    // =========================================================================
    // VERIFY: Check balance was updated
    // =========================================================================
    let depositor_key = Word::from([
        sender.id().prefix().as_felt(),
        sender.id().suffix(),
        faucet.id().prefix().as_felt(),
        faucet.id().suffix(),
    ]);

    let balance = bank_account.storage().get_map_item(1, depositor_key)?;

    // Balance is stored as a single Felt in the last position of the Word
    let balance_value = balance[3].as_int();

    println!("Depositor balance: {}", balance_value);
    assert_eq!(
        balance_value,
        deposit_amount,
        "Balance should equal deposited amount"
    );

    println!("\nPart 3 deposit test passed!");

    Ok(())
}
```

:::note Test Dependencies
This test requires:
- `deposit-note` contract (Part 4)
- `init-tx-script` contract (Part 6)

If you haven't created these yet, you can run this test after completing Parts 4 and 6, or create placeholder contracts. For now, let's verify the bank-account compiles correctly.
:::

Build verification:

```bash title=">_ Terminal"
cd contracts/bank-account
miden build
```

If you have the note scripts ready, run the full test from the project root:

```bash title=">_ Terminal"
cargo test --package integration part3_deposit -- --nocapture
```

<details>
<summary>Expected output</summary>

```text
   Compiling integration v0.1.0 (/path/to/miden-bank/integration)
    Finished `test` profile [unoptimized + debuginfo] target(s)
     Running tests/part3_deposit_test.rs

running 1 test
Bank initialized successfully!
Deposit transaction executed!
Depositor balance: 1000

Part 3 deposit test passed!
test test_deposit_updates_balance ... ok

test result: ok. 1 passed; 0 failed; 0 ignored
```

</details>

## Asset Flow Summary

```text
DEPOSIT FLOW:
┌───────────┐   deposit_note    ┌────────────┐
│ Depositor │ ──────────────────▶ Bank Vault │
│  Wallet   │    (with asset)   │  + Balance │
└───────────┘                   └────────────┘

WITHDRAW FLOW:
┌────────────┐   P2ID note      ┌───────────┐
│ Bank Vault │ ──────────────────▶ Depositor │
│  - Balance │   (with asset)   │  Wallet   │
└────────────┘                  └───────────┘
```

## Complete Code for This Part

Here's the full `lib.rs` after Part 3:

<details>
<summary>Click to expand full code</summary>

```rust title="contracts/bank-account/src/lib.rs"
#![no_std]
#![feature(alloc_error_handler)]

#[macro_use]
extern crate alloc;

use miden::*;

/// Maximum allowed deposit amount per transaction.
const MAX_DEPOSIT_AMOUNT: u64 = 1_000_000;

/// Bank account component that tracks depositor balances.
#[component]
struct Bank {
    #[storage(slot(0), description = "initialized")]
    initialized: Value,

    #[storage(slot(1), description = "balances")]
    balances: StorageMap,
}

#[component]
impl Bank {
    /// Initialize the bank account, enabling deposits.
    pub fn initialize(&mut self) {
        let current: Word = self.initialized.read();
        assert!(
            current[0].as_u64() == 0,
            "Bank already initialized"
        );

        let initialized_word = Word::from([felt!(1), felt!(0), felt!(0), felt!(0)]);
        self.initialized.write(initialized_word);
    }

    /// Get the balance for a depositor.
    pub fn get_balance(&self, depositor: AccountId) -> Felt {
        let key = Word::from([depositor.prefix, depositor.suffix, felt!(0), felt!(0)]);
        self.balances.get(&key)
    }

    /// Check that the bank is initialized.
    fn require_initialized(&self) {
        let current: Word = self.initialized.read();
        assert!(
            current[0].as_u64() == 1,
            "Bank not initialized - deposits not enabled"
        );
    }

    /// Deposit assets into the bank.
    pub fn deposit(&mut self, depositor: AccountId, deposit_asset: Asset) {
        self.require_initialized();

        let deposit_amount = deposit_asset.inner[0];

        assert!(
            deposit_amount.as_u64() <= MAX_DEPOSIT_AMOUNT,
            "Deposit amount exceeds maximum allowed"
        );

        let key = Word::from([
            depositor.prefix,
            depositor.suffix,
            deposit_asset.inner[3],
            deposit_asset.inner[2],
        ]);

        let current_balance: Felt = self.balances.get(&key);
        let new_balance = current_balance + deposit_amount;
        self.balances.set(key, new_balance);

        native_account::add_asset(deposit_asset);
    }

    /// Withdraw assets from the bank.
    pub fn withdraw(
        &mut self,
        depositor: AccountId,
        withdraw_asset: Asset,
        serial_num: Word,
        tag: Felt,
        aux: Felt,
        note_type: Felt,
    ) {
        self.require_initialized();

        let withdraw_amount = withdraw_asset.inner[0];

        let key = Word::from([
            depositor.prefix,
            depositor.suffix,
            withdraw_asset.inner[3],
            withdraw_asset.inner[2],
        ]);

        // CRITICAL: Validate balance BEFORE subtraction
        let current_balance: Felt = self.balances.get(&key);
        assert!(
            current_balance.as_u64() >= withdraw_amount.as_u64(),
            "Withdrawal amount exceeds available balance"
        );

        let new_balance = current_balance - withdraw_amount;
        self.balances.set(key, new_balance);

        self.create_p2id_note(serial_num, &withdraw_asset, depositor, tag, aux, note_type);
    }

    /// Create a P2ID note - placeholder for Part 7.
    fn create_p2id_note(
        &mut self,
        _serial_num: Word,
        _asset: &Asset,
        _recipient_id: AccountId,
        _tag: Felt,
        _aux: Felt,
        _note_type: Felt,
    ) {
        todo!("P2ID note creation - see Part 7")
    }
}
```

</details>

## Key Takeaways

1. **Asset layout**: `[amount, 0, faucet_suffix, faucet_prefix]`
2. **`native_account::add_asset()`** adds assets to the vault
3. **`native_account::remove_asset()`** removes assets from the vault (Part 7)
4. **Balance tracking** is application-level logic using `StorageMap`
5. **Composite keys** allow per-user, per-asset balance tracking
6. **CRITICAL: Always validate before subtraction** - Felt arithmetic wraps silently!

:::tip View Complete Source
See the complete deposit and withdraw implementations in the [miden-bank repository](https://github.com/keinberger/miden-bank/blob/main/contracts/bank-account/src/lib.rs).
:::

## Next Steps

Now that you understand asset management, let's learn how to trigger these operations with [Part 4: Note Scripts](./04-note-scripts).
````

## File: docs/builder/develop/tutorials/rust-compiler/miden-bank/04-note-scripts.md
````markdown
---
sidebar_position: 4
title: "Part 4: Note Scripts"
description: "Learn how to write note scripts that execute when notes are consumed, using active_note APIs to access sender, assets, and inputs."
---

# Part 4: Note Scripts

In this section, you'll learn how to write note scripts - code that executes when a note is consumed by an account. We'll create the deposit note that lets users deposit tokens into the bank.

## What You'll Build in This Part

By the end of this section, you will have:

- Created the `deposit-note` contract
- Understood the `#[note_script]` attribute
- Used `active_note` APIs to access sender and assets
- Built the note script and its dependencies
- **Verified it works** with a complete deposit flow test

## Building on Part 3

In Part 3, we completed the bank's deposit method. Now we need a way to trigger it:

```text
Part 3:                          Part 4:
┌──────────────────┐             ┌──────────────────┐
│ Bank (complete)  │             │ Bank (complete)  │
│ ─────────────────│             │ ─────────────────│
│ + deposit()      │             │ + deposit()      │
│ + withdraw()     │             │ + withdraw()     │
└──────────────────┘             └──────────────────┘
                                          ▲
                                          │ calls
                                 ┌────────────────────┐
                                 │ deposit-note       │ ◄── NEW
                                 │ (note script)      │
                                 └────────────────────┘
```

## Note Scripts vs Account Components

| Feature | Account Component | Note Script |
|---------|------------------|-------------|
| Purpose | Persistent account logic | One-time execution when consumed |
| Storage | Has persistent storage | No storage (reads from note data) |
| Attribute | `#[component]` | `#[note_script]` |
| Entry point | Methods on struct | `fn run(_arg: Word)` |
| Invocation | Called by other contracts | Executes when note is consumed |

Note scripts are like "messages" that carry code along with data and assets.

## Step 1: Create the Deposit Note Project

First, create the deposit-note contract. If you used `miden new`, you may have an `increment-note` folder - rename or replace it:

```bash title=">_ Terminal"
# Remove or rename the example
rm -rf contracts/increment-note
# Or: mv contracts/increment-note contracts/increment-note-backup

# Create the deposit-note directory
mkdir -p contracts/deposit-note/src
```

## Step 2: Configure Cargo.toml

Create the `Cargo.toml` for the deposit note:

```toml title="contracts/deposit-note/Cargo.toml"
[package]
name = "deposit-note"
version = "0.1.0"
edition = "2021"

[lib]
crate-type = ["cdylib"]

[dependencies]
miden = { workspace = true }

[package.metadata.component]
package = "miden:deposit-note"

[package.metadata.miden]
project-kind = "note-script"

# Dependencies on account components
[package.metadata.miden.dependencies]
"miden:bank-account" = { path = "../bank-account" }

[package.metadata.component.target.dependencies]
"miden:bank-account" = { path = "../bank-account/target/generated-wit/" }
```

Key configuration:
- `project-kind = "note-script"` - Marks this as a note script
- Dependencies sections declare which accounts it can interact with

## Step 3: Implement the Deposit Note

Create the note script implementation:

```rust title="contracts/deposit-note/src/lib.rs"
#![no_std]
#![feature(alloc_error_handler)]

#[macro_use]
extern crate alloc;

use miden::*;

// Import the bank account's generated bindings
use crate::bindings::miden::bank_account::bank_account;

/// Deposit Note Script
///
/// When consumed by the Bank account, this note transfers all its assets
/// to the bank and credits the depositor (note sender) with the deposited amount.
///
/// # Execution Flow
/// 1. User creates note with tokens attached
/// 2. Bank account consumes the note
/// 3. This script executes:
///    - Gets the sender (depositor) from note metadata
///    - Gets the assets attached to the note
///    - Calls bank_account::deposit() for each asset
#[note_script]
fn run(_arg: Word) {
    // The depositor is whoever created/sent this note
    let depositor = active_note::get_sender();

    // Get all assets attached to this note
    let assets = active_note::get_assets();

    // Deposit each asset into the bank
    for asset in assets {
        bank_account::deposit(depositor, asset);
    }
}
```

### The #[note_script] Attribute

The `#[note_script]` attribute marks the entry point for a note script. The function signature is always:

```rust
fn run(_arg: Word)
```

The `_arg` parameter can pass additional data, but we don't use it in the deposit note.

## Note Context APIs

The `active_note` module provides APIs to access note data during execution:

### get_sender() - Who Created the Note

```rust
let depositor = active_note::get_sender();
```

Returns the `AccountId` of the account that created/sent the note. In our bank:
- The sender is the depositor
- Their ID is used to credit their balance

### get_assets() - Attached Assets

```rust
let assets = active_note::get_assets();
for asset in assets {
    // Process each asset
}
```

Returns an iterator over all assets attached to the note.

### get_inputs() - Note Parameters

```rust
let inputs = active_note::get_inputs();
let first_input = inputs[0];
```

Returns a vector of `Felt` values passed when the note was created. We'll use inputs in the withdraw request note (Part 7).

## Step 4: Update the Workspace

Update the root `Cargo.toml` to include the new contract:

```toml title="Cargo.toml" {5}
[workspace]
resolver = "2"

members = [
    "contracts/bank-account",
    "contracts/deposit-note",
    "integration",
]

[workspace.dependencies]
miden = { version = "0.8" }
```

## Step 5: Build the Note Script

:::info Build Order Matters
Build account components **first** before building note scripts that depend on them. The note script needs the generated WIT files from the account.
:::

```bash title=">_ Terminal"
# First, ensure bank-account is built (generates WIT files)
cd contracts/bank-account
miden build

# Now build the deposit note
cd ../deposit-note
miden build
```

<details>
<summary>Expected output</summary>

```text
   Compiling deposit-note v0.1.0
    Finished `release` profile [optimized] target(s)
Creating Miden package /path/to/miden-bank/target/miden/release/deposit_note.masp
```

</details>

## Execution Flow Diagram

```text
1. User creates deposit note with 100 tokens attached
   ┌───────────────────────────────────────┐
   │ Note: deposit-note                    │
   │ Sender: User's AccountId              │
   │ Assets: [100 tokens]                  │
   └───────────────────────────────────────┘

2. Bank account consumes the note
   ┌───────────────────────────────────────┐
   │ Bank receives assets into vault       │
   │ Note script executes...               │
   └───────────────────────────────────────┘

3. Note script runs
   depositor = get_sender()  → User's AccountId
   assets = get_assets()     → [100 tokens]
   bank_account::deposit(depositor, 100 tokens)

4. Bank's deposit() method executes
   - Validates initialization and amount
   - Updates balance: balances[User] += 100
   - Adds asset to vault
```

## Try It: Verify Deposits Work

Now let's write a test to verify the complete deposit flow. This test:
1. Initializes the bank
2. Creates a deposit note with tokens
3. Has the bank consume the note
4. Verifies the balance was updated

```rust title="integration/tests/part4_deposit_note_test.rs"
use integration::helpers::{
    build_project_in_dir, create_testing_account_from_package,
    create_testing_note_from_package, AccountCreationConfig, NoteCreationConfig,
};
use miden_client::account::{StorageMap, StorageSlot};
use miden_client::note::NoteAssets;
use miden_client::transaction::OutputNote;
use miden_client::{Felt, Word};
use miden_objects::asset::{Asset, FungibleAsset};
use miden_objects::transaction::TransactionScript;
use miden_testing::{Auth, MockChain};
use std::{path::Path, sync::Arc};

#[tokio::test]
async fn test_deposit_note_credits_depositor() -> anyhow::Result<()> {
    // =========================================================================
    // SETUP: Build contracts and create mock chain
    // =========================================================================
    let mut builder = MockChain::builder();

    // Create a faucet for test tokens
    let faucet = builder.add_new_faucet(Auth::NoAuth, "TEST", 10_000_000)?;

    // Create sender (depositor) wallet
    let sender = builder.add_existing_wallet(Auth::BasicAuth)?;

    // Build all contracts
    let bank_package = Arc::new(build_project_in_dir(
        Path::new("../contracts/bank-account"),
        true,
    )?);

    let deposit_note_package = Arc::new(build_project_in_dir(
        Path::new("../contracts/deposit-note"),
        true,
    )?);

    let init_tx_script_package = Arc::new(build_project_in_dir(
        Path::new("../contracts/init-tx-script"),
        true,
    )?);

    // Create bank account
    let bank_cfg = AccountCreationConfig {
        storage_slots: vec![
            StorageSlot::Value(Word::default()),
            StorageSlot::Map(StorageMap::with_entries([])?),
        ],
        ..Default::default()
    };

    let mut bank_account =
        create_testing_account_from_package(bank_package.clone(), bank_cfg).await?;

    builder.add_account(bank_account.clone())?;
    let mut mock_chain = builder.build()?;

    // =========================================================================
    // STEP 1: Initialize the bank
    // =========================================================================
    let init_program = init_tx_script_package.unwrap_program();
    let init_tx_script = TransactionScript::new((*init_program).clone());

    let init_tx_context = mock_chain
        .build_tx_context(bank_account.id(), &[], &[])?
        .tx_script(init_tx_script)
        .build()?;

    let executed_init = init_tx_context.execute().await?;
    bank_account.apply_delta(&executed_init.account_delta())?;
    mock_chain.add_pending_executed_transaction(&executed_init)?;
    mock_chain.prove_next_block()?;

    println!("Step 1: Bank initialized");

    // =========================================================================
    // STEP 2: Create and execute deposit
    // =========================================================================
    let deposit_amount: u64 = 1000;
    let fungible_asset = FungibleAsset::new(faucet.id(), deposit_amount)?;
    let note_assets = NoteAssets::new(vec![Asset::Fungible(fungible_asset)])?;

    let deposit_note = create_testing_note_from_package(
        deposit_note_package.clone(),
        sender.id(),  // Sender is the depositor
        NoteCreationConfig {
            assets: note_assets,
            ..Default::default()
        },
    )?;

    mock_chain.add_note(OutputNote::Full(deposit_note.clone().into()))?;

    let tx_context = mock_chain
        .build_tx_context(bank_account.id(), &[deposit_note.id()], &[])?
        .build()?;

    let executed_transaction = tx_context.execute().await?;
    bank_account.apply_delta(&executed_transaction.account_delta())?;
    mock_chain.add_pending_executed_transaction(&executed_transaction)?;
    mock_chain.prove_next_block()?;

    println!("Step 2: Deposit note consumed");

    // =========================================================================
    // VERIFY: Balance was updated
    // =========================================================================
    let depositor_key = Word::from([
        sender.id().prefix().as_felt(),
        sender.id().suffix(),
        faucet.id().prefix().as_felt(),
        faucet.id().suffix(),
    ]);

    let balance = bank_account.storage().get_map_item(1, depositor_key)?;
    let balance_value = balance[3].as_int();

    println!("Step 3: Verified balance = {}", balance_value);

    assert_eq!(
        balance_value,
        deposit_amount,
        "Balance should equal deposited amount"
    );

    println!("\nPart 4 deposit note test passed!");

    Ok(())
}
```

:::note Dependencies
This test requires the `init-tx-script` contract which we'll create in Part 6. You can either:
1. Skip ahead to create a minimal init-tx-script (see Part 6)
2. Run this test after completing Part 6

For now, verify that your deposit-note builds successfully.
:::

Run the test from the project root (after creating init-tx-script in Part 6):

```bash title=">_ Terminal"
cargo test --package integration part4_deposit -- --nocapture
```

<details>
<summary>Expected output</summary>

```text
   Compiling integration v0.1.0 (/path/to/miden-bank/integration)
    Finished `test` profile [unoptimized + debuginfo] target(s)
     Running tests/part4_deposit_note_test.rs

running 1 test
Step 1: Bank initialized
Step 2: Deposit note consumed
Step 3: Verified balance = 1000

Part 4 deposit note test passed!
test test_deposit_note_credits_depositor ... ok

test result: ok. 1 passed; 0 failed; 0 ignored
```

</details>

## Preview: Withdraw Request Note

For withdrawals, we'll use note inputs to pass parameters. Here's a preview of the withdraw request note (implemented in Part 7):

```rust title="contracts/withdraw-request-note/src/lib.rs (preview)"
/// Withdraw Request Note Script
///
/// # Note Inputs (11 Felts)
/// [0-3]: withdraw asset (amount, 0, faucet_suffix, faucet_prefix)
/// [4-7]: serial_num (random/unique per note)
/// [8]: tag (P2ID note tag for routing)
/// [9]: aux (auxiliary data)
/// [10]: note_type (1 = Public, 2 = Private)
#[note_script]
fn run(_arg: Word) {
    let depositor = active_note::get_sender();
    let inputs = active_note::get_inputs();

    // Parse parameters from inputs
    let withdraw_asset = Asset::new(Word::from([
        inputs[0], inputs[1], inputs[2], inputs[3]
    ]));

    let serial_num = Word::from([
        inputs[4], inputs[5], inputs[6], inputs[7]
    ]);

    let tag = inputs[8];
    let aux = inputs[9];
    let note_type = inputs[10];

    bank_account::withdraw(depositor, withdraw_asset, serial_num, tag, aux, note_type);
}
```

:::warning Stack Limits
Note inputs are limited. Keep your input layout compact. See [Common Pitfalls](../pitfalls) for stack-related constraints.
:::

## Complete Code for This Part

<details>
<summary>Click to expand deposit-note/src/lib.rs</summary>

```rust title="contracts/deposit-note/src/lib.rs"
#![no_std]
#![feature(alloc_error_handler)]

#[macro_use]
extern crate alloc;

use miden::*;

use crate::bindings::miden::bank_account::bank_account;

/// Deposit Note Script
#[note_script]
fn run(_arg: Word) {
    let depositor = active_note::get_sender();
    let assets = active_note::get_assets();

    for asset in assets {
        bank_account::deposit(depositor, asset);
    }
}
```

</details>

## Key Takeaways

1. **`#[note_script]`** marks the entry point function `fn run(_arg: Word)`
2. **`active_note::get_sender()`** returns who created the note
3. **`active_note::get_assets()`** returns assets attached to the note
4. **`active_note::get_inputs()`** returns parameterized data
5. **Note scripts execute once** when consumed - no persistent state
6. **Build order matters** - account components first, then note scripts

:::tip View Complete Source
See the complete note script implementations:
- [Deposit Note](https://github.com/keinberger/miden-bank/blob/main/contracts/deposit-note/src/lib.rs)
- [Withdraw Request Note](https://github.com/keinberger/miden-bank/blob/main/contracts/withdraw-request-note/src/lib.rs)
:::

## Next Steps

Now that you understand note scripts, let's learn how they call account methods in [Part 5: Cross-Component Calls](./05-cross-component-calls).
````

## File: docs/builder/develop/tutorials/rust-compiler/miden-bank/07-output-notes.md
````markdown
---
sidebar_position: 7
title: "Part 7: Creating Output Notes"
description: "Learn how to create output notes programmatically within account methods, including the P2ID (Pay-to-ID) note pattern for sending assets."
---

# Part 7: Creating Output Notes

In this section, you'll learn how to create output notes from within account methods. We'll implement the full withdrawal logic that creates P2ID (Pay-to-ID) notes to send assets back to depositors.

## What You'll Build in This Part

By the end of this section, you will have:

- Created the `withdraw-request-note` note script project
- Implemented the `withdraw()` method with balance validation
- Implemented `create_p2id_note()` for sending assets
- **Verified withdrawals work** via a MockChain test

## Building on Part 6

In Part 6, you created a transaction script for initialization. Now you'll complete the bank by implementing withdrawals that create output notes:

```text
┌────────────────────────────────────────────────────────────────┐
│                   Complete Bank Flow                            │
├────────────────────────────────────────────────────────────────┤
│                                                                 │
│   Part 6: Initialize                                            │
│   ┌─────────────────┐    init-tx-script     ┌───────────────┐  │
│   │ Bank (uninit)   │ ──────────────────────▶│ Bank (ready)  │  │
│   └─────────────────┘                        └───────────────┘  │
│                                                                 │
│   Part 4: Deposit                                               │
│   ┌─────────────────┐    deposit-note        ┌───────────────┐  │
│   │ User sends      │ ──────────────────────▶│ Balance += X  │  │
│   │ deposit note    │                        │ Vault += X    │  │
│   └─────────────────┘                        └───────────────┘  │
│                                                                 │
│   Part 7: Withdraw (NEW)                                        │
│   ┌─────────────────┐   withdraw-request     ┌───────────────┐  │
│   │ User sends      │ ──────────────────────▶│ Balance -= X  │  │
│   │ withdraw note   │                        │ Creates P2ID  │  │
│   └─────────────────┘                        │ output note   │  │
│                                              └───────────────┘  │
│                                                                 │
└────────────────────────────────────────────────────────────────┘
```

## Output Notes Overview

When an account needs to send assets to another account, it creates an **output note**. The note travels through the network until the recipient consumes it.

```text
WITHDRAW FLOW:
┌────────────────┐          ┌────────────────┐          ┌────────────────┐
│ Bank Account   │ creates  │ P2ID Note      │ consumed │ Depositor      │
│                │ ────────▶│ (with assets)  │ ────────▶│ Wallet         │
│ remove_asset() │          │                │          │ receives asset │
└────────────────┘          └────────────────┘          └────────────────┘
```

## The P2ID Note Pattern

P2ID (Pay-to-ID) is a standard note pattern in Miden that sends assets to a specific account:

- **Target account**: Only one account can consume the note
- **Asset transfer**: Assets are transferred on consumption
- **Standard script**: Uses a well-known script from miden-lib

## Step 1: Add Withdraw Method to Bank Account

First, let's add the `withdraw()` method to your bank account. Update `contracts/bank-account/src/lib.rs`:

```rust title="contracts/bank-account/src/lib.rs"
#[component]
impl Bank {
    // ... existing methods (initialize, deposit, get_balance) ...

    /// Withdraw assets back to the depositor.
    ///
    /// Creates a P2ID note that sends the requested asset to the depositor's account.
    ///
    /// # Arguments
    /// * `depositor` - The AccountId of the user withdrawing
    /// * `withdraw_asset` - The fungible asset to withdraw
    /// * `serial_num` - Unique serial number for the P2ID output note
    /// * `tag` - The note tag for the P2ID output note (allows caller to specify routing)
    /// * `aux` - Auxiliary data for the note (application-specific, typically 0)
    /// * `note_type` - Note type: 1 = Public (stored on-chain), 2 = Private (off-chain)
    ///
    /// # Panics
    /// Panics if the withdrawal amount exceeds the depositor's current balance.
    /// Panics if the bank has not been initialized.
    pub fn withdraw(
        &mut self,
        depositor: AccountId,
        withdraw_asset: Asset,
        serial_num: Word,
        tag: Felt,
        aux: Felt,
        note_type: Felt,
    ) {
        // Ensure the bank is initialized before processing withdrawals
        self.require_initialized();

        // Extract the fungible amount from the asset
        let withdraw_amount = withdraw_asset.inner[0];

        // Create key from depositor's AccountId and asset faucet ID
        let key = Word::from([
            depositor.prefix,
            depositor.suffix,
            withdraw_asset.inner[3], // asset prefix (faucet)
            withdraw_asset.inner[2], // asset suffix (faucet)
        ]);

        // Get current balance and validate sufficient funds exist.
        // This check is critical: Felt arithmetic is modular, so subtracting
        // more than the balance would silently wrap to a large positive number.
        let current_balance: Felt = self.balances.get(&key);
        assert!(
            current_balance.as_u64() >= withdraw_amount.as_u64(),
            "Withdrawal amount exceeds available balance"
        );

        // Update balance: current - withdraw_amount
        let new_balance = current_balance - withdraw_amount;
        self.balances.set(key, new_balance);

        // Create a P2ID note to send the requested asset back to the depositor
        self.create_p2id_note(serial_num, &withdraw_asset, depositor, tag, aux, note_type);
    }
}
```

:::danger Critical Security: Balance Validation
Always validate `current_balance >= withdraw_amount` BEFORE subtraction. Miden uses modular field arithmetic - subtracting a larger value silently wraps to a massive positive number!
:::

## Step 2: Add the P2ID Note Root

The P2ID note uses a standard script from miden-lib. Add this helper function:

```rust title="contracts/bank-account/src/lib.rs"
#[component]
impl Bank {
    // ... other methods ...

    /// Returns the P2ID note script root digest.
    ///
    /// This is a constant value derived from the standard P2ID note script in miden-lib.
    /// The digest is the MAST root of the compiled P2ID note script.
    fn p2id_note_root() -> Digest {
        Digest::from_word(Word::new([
            Felt::from_u64_unchecked(15783632360113277539),
            Felt::from_u64_unchecked(7403765918285273520),
            Felt::from_u64_unchecked(15691985194755641846),
            Felt::from_u64_unchecked(10399643920503194563),
        ]))
    }
}
```

:::warning Version-Specific
This digest is specific to miden-lib version. If the P2ID script changes in a future version, this digest must be updated.
:::

## Step 3: Implement create_p2id_note

Add the private method that creates the output note:

```rust title="contracts/bank-account/src/lib.rs"
#[component]
impl Bank {
    // ... other methods ...

    /// Create a P2ID (Pay-to-ID) note to send assets to a recipient.
    ///
    /// # Arguments
    /// * `serial_num` - Unique serial number for the note
    /// * `asset` - The asset to include in the note
    /// * `recipient_id` - The AccountId that can consume this note
    /// * `tag` - The note tag (passed by caller to allow proper P2ID routing)
    /// * `aux` - Auxiliary data for application-specific purposes
    /// * `note_type` - Note type as Felt: 1 = Public, 2 = Private
    fn create_p2id_note(
        &mut self,
        serial_num: Word,
        asset: &Asset,
        recipient_id: AccountId,
        tag: Felt,
        aux: Felt,
        note_type: Felt,
    ) {
        // Convert the passed tag Felt to a Tag
        // The caller is responsible for computing the proper P2ID tag
        // (typically LocalAny with account ID bits embedded)
        let tag = Tag::from(tag);

        // Convert note_type Felt to NoteType
        // 1 = Public (stored on-chain), 2 = Private (off-chain)
        let note_type = NoteType::from(note_type);

        // Execution hint: always (standard P2ID behavior per miden-base)
        // This is hardcoded to match miden-base's standard P2ID note implementation
        // which uses NoteExecutionHint::always() - represented as 0 in Felt form
        let execution_hint = felt!(0);

        // Get the P2ID note script root digest
        let script_root = Self::p2id_note_root();

        // Compute the recipient hash from:
        // - serial_num: unique identifier for this note instance
        // - script_root: the P2ID note script's MAST root
        // - inputs: the target account ID (padded to 8 elements)
        //
        // The P2ID script expects inputs as [suffix, prefix, 0, 0, 0, 0, 0, 0]
        let recipient = Recipient::compute(
            serial_num,
            script_root,
            vec![
                recipient_id.suffix,
                recipient_id.prefix,
                felt!(0),
                felt!(0),
                felt!(0),
                felt!(0),
                felt!(0),
                felt!(0),
            ],
        );

        // Create the output note
        let note_idx = output_note::create(tag, aux, note_type, execution_hint, recipient);

        // Remove the asset from the bank's vault
        native_account::remove_asset(asset.clone());

        // Add the asset to the output note
        output_note::add_asset(asset.clone(), note_idx);
    }
}
```

### Understanding Recipient::compute()

| Parameter | Description |
|-----------|-------------|
| `serial_num` | Unique 4-Felt value preventing note reuse |
| `script_root` | The P2ID script's MAST root digest |
| `inputs` | Script inputs (account ID for P2ID) |

:::warning Array Ordering
Note the order: `suffix` comes before `prefix`. This is the opposite of how `AccountId` fields are typically accessed. See [Common Pitfalls](../../pitfalls#array-ordering-rustmasm-reversal) for details.
:::

### Understanding output_note::create()

| Parameter | Type | Description |
|-----------|------|-------------|
| `tag` | `Tag` | Routing information for the note |
| `aux` | `Felt` | Auxiliary data (application-specific) |
| `note_type` | `NoteType` | Public (1) or Private (2) |
| `execution_hint` | `Felt` | When the note should execute |
| `recipient` | `Recipient` | Who can consume the note |

## Step 4: Create the Withdraw Request Note Project

Create the directory structure:

```bash title=">_ Terminal"
mkdir -p contracts/withdraw-request-note/src
```

### Configure Cargo.toml

```toml title="contracts/withdraw-request-note/Cargo.toml"
[package]
name = "withdraw-request-note"
version = "0.1.0"
edition = "2021"

[lib]
crate-type = ["cdylib"]

[dependencies]
miden = { workspace = true }

[package.metadata.component]
package = "miden:withdraw-request-note"

[package.metadata.miden]
project-kind = "note-script"

[package.metadata.miden.dependencies]
"miden:bank-account" = { path = "../bank-account" }

[package.metadata.component.target.dependencies]
"miden:bank-account" = { path = "../bank-account/target/generated-wit/" }
```

### Update Workspace

Add to your root `Cargo.toml`:

```toml title="Cargo.toml" {7}
[workspace]
resolver = "2"

members = [
    "contracts/bank-account",
    "contracts/deposit-note",
    "contracts/init-tx-script",
    "contracts/withdraw-request-note",  # Add this line
    "integration",
]

[workspace.dependencies]
miden = { version = "0.8" }
```

## Step 5: Implement the Withdraw Request Note Script

```rust title="contracts/withdraw-request-note/src/lib.rs"
// Do not link against libstd (i.e. anything defined in `std::`)
#![no_std]
#![feature(alloc_error_handler)]

use miden::*;

// Import the bank account's generated bindings
use crate::bindings::miden::bank_account::bank_account;

/// Withdraw Request Note Script
///
/// When consumed by the Bank account, this note requests a withdrawal and
/// the bank creates a P2ID note to send assets back to the depositor.
///
/// # Flow
/// 1. Note is created by a depositor specifying the withdrawal details
/// 2. Bank account consumes this note
/// 3. Note script reads the sender (depositor) and inputs
/// 4. Calls `bank_account::withdraw(depositor, asset, serial_num, tag, aux, note_type)`
/// 5. Bank updates the depositor's balance
/// 6. Bank creates a P2ID note with the specified parameters to send assets back
///
/// # Note Inputs (11 Felts)
/// [0-3]: withdraw asset (amount, 0, faucet_suffix, faucet_prefix)
/// [4-7]: serial_num (random/unique per note)
/// [8]: tag (P2ID note tag for routing)
/// [9]: aux (auxiliary data, application-specific, typically 0)
/// [10]: note_type (1 = Public, 2 = Private)
#[note_script]
fn run(_arg: Word) {
    // The depositor is whoever created/sent this note
    let depositor = active_note::get_sender();

    // Get the inputs
    let inputs = active_note::get_inputs();

    // Asset: [amount, 0, faucet_suffix, faucet_prefix]
    let withdraw_asset = Asset::new(Word::from([inputs[0], inputs[1], inputs[2], inputs[3]]));

    // Serial number: full 4 Felts (random/unique per note)
    let serial_num = Word::from([inputs[4], inputs[5], inputs[6], inputs[7]]);

    // Tag: single Felt for P2ID note routing
    let tag = inputs[8];

    // Aux: auxiliary data for application-specific purposes
    let aux = inputs[9];

    // Note type: 1 = Public, 2 = Private
    let note_type = inputs[10];

    // Call the bank account to withdraw the assets
    bank_account::withdraw(depositor, withdraw_asset, serial_num, tag, aux, note_type);
}
```

### Note Input Layout

The withdraw-request-note expects 11 Felt inputs:

```text
Note Inputs (11 Felts):
┌───────────────────────────────────────────────────────────────────────────┐
│ Index │ Value           │ Description                                     │
├───────┼─────────────────┼─────────────────────────────────────────────────┤
│ 0     │ amount          │ Token amount to withdraw                        │
│ 1     │ 0               │ Reserved (always 0 for fungible)                │
│ 2     │ faucet_suffix   │ Faucet ID suffix (identifies asset type)        │
│ 3     │ faucet_prefix   │ Faucet ID prefix (identifies asset type)        │
│ 4-7   │ serial_num      │ Unique ID for the output P2ID note (4 Felts)    │
│ 8     │ tag             │ Note routing tag for P2ID note                  │
│ 9     │ aux             │ Auxiliary data (typically 0)                    │
│ 10    │ note_type       │ 1 (Public) or 2 (Private)                       │
└───────────────────────────────────────────────────────────────────────────┘
```

:::note Why the Asset is in Inputs
Unlike the deposit note which gets assets from `active_note::get_assets()`, the withdraw request note doesn't carry assets. Instead, the asset to withdraw is specified in the note inputs. The bank then withdraws from its own vault based on these inputs.
:::

## Step 6: Build All Components

Build in dependency order:

```bash title=">_ Terminal"
# 1. Build the account component (generates WIT files)
cd contracts/bank-account
miden build

# 2. Build the withdraw request note
cd ../withdraw-request-note
miden build
```

## Try It: Verify Withdrawals Work

Let's test the complete withdraw flow. This test:
1. Creates a bank account and initializes it
2. Creates a deposit note and processes it
3. Creates a withdraw-request note with the 11-Felt input layout
4. Processes the withdrawal and verifies a P2ID output note is created

```rust title="integration/tests/part7_withdraw_test.rs"
use integration::helpers::{
    build_project_in_dir, create_testing_account_from_package, create_testing_note_from_package,
    AccountCreationConfig, NoteCreationConfig,
};
use miden_client::{
    account::StorageMap,
    note::{Note, NoteAssets, NoteExecutionHint, NoteMetadata, NoteTag, NoteType},
    transaction::OutputNote,
    Felt, Word,
};
use miden_lib::note::utils::build_p2id_recipient;
use miden_objects::{
    account::AccountId,
    asset::{Asset, FungibleAsset},
    transaction::TransactionScript,
};
use miden_testing::{Auth, MockChain};
use std::{path::Path, sync::Arc};

/// Compute a P2ID note tag for a local account.
fn compute_p2id_tag_for_local_account(account_id: AccountId) -> NoteTag {
    const LOCAL_ANY_PREFIX: u32 = 0xC000_0000;
    const TAG_BITS: u8 = 14;

    let prefix_u64 = account_id.prefix().as_u64();
    let shifted = (prefix_u64 >> 34) as u32;
    let mask = u32::MAX << (30 - TAG_BITS);
    let account_bits = shifted & mask;
    let tag_value = LOCAL_ANY_PREFIX | account_bits;

    NoteTag::LocalAny(tag_value)
}

#[tokio::test]
async fn test_withdraw_creates_p2id_note() -> anyhow::Result<()> {
    // =========================================================================
    // SETUP
    // =========================================================================
    let mut builder = MockChain::builder();

    let deposit_amount: u64 = 1000;

    // Create faucet and sender (depositor)
    let faucet =
        builder.add_existing_basic_faucet(Auth::BasicAuth, "TEST", deposit_amount, Some(10))?;
    let sender = builder.add_existing_wallet_with_assets(
        Auth::BasicAuth,
        [FungibleAsset::new(faucet.id(), deposit_amount)?.into()],
    )?;

    // Build contracts
    let bank_package = Arc::new(build_project_in_dir(
        Path::new("../contracts/bank-account"),
        true,
    )?);
    let deposit_note_package = Arc::new(build_project_in_dir(
        Path::new("../contracts/deposit-note"),
        true,
    )?);
    let init_tx_script_package = Arc::new(build_project_in_dir(
        Path::new("../contracts/init-tx-script"),
        true,
    )?);
    let withdraw_request_note_package = Arc::new(build_project_in_dir(
        Path::new("../contracts/withdraw-request-note"),
        true,
    )?);

    // Create bank account
    let bank_cfg = AccountCreationConfig {
        storage_slots: vec![
            miden_client::account::StorageSlot::Value(Word::default()),
            miden_client::account::StorageSlot::Map(StorageMap::with_entries([])?),
        ],
        ..Default::default()
    };
    let mut bank_account =
        create_testing_account_from_package(bank_package.clone(), bank_cfg).await?;

    // Create deposit note
    let fungible_asset = FungibleAsset::new(faucet.id(), deposit_amount)?;
    let note_assets = NoteAssets::new(vec![Asset::Fungible(fungible_asset)])?;
    let deposit_note = create_testing_note_from_package(
        deposit_note_package.clone(),
        sender.id(),
        NoteCreationConfig {
            assets: note_assets,
            ..Default::default()
        },
    )?;

    // Add accounts and notes to builder
    builder.add_account(bank_account.clone())?;
    builder.add_output_note(OutputNote::Full(deposit_note.clone().into()));

    // =========================================================================
    // CRAFT WITHDRAW REQUEST NOTE (11-Felt input layout)
    // =========================================================================
    let withdraw_amount = deposit_amount / 2;

    // Compute P2ID tag for the sender
    let p2id_tag = compute_p2id_tag_for_local_account(sender.id());
    let p2id_tag_u32 = match p2id_tag {
        NoteTag::LocalAny(v) => v,
        _ => panic!("Expected LocalAny tag"),
    };
    let p2id_tag_felt = Felt::new(p2id_tag_u32 as u64);

    // Serial number for output note
    let p2id_output_note_serial_num = Word::from([
        Felt::new(0x1234567890abcdef),
        Felt::new(0xfedcba0987654321),
        Felt::new(0xdeadbeefcafebabe),
        Felt::new(0x0123456789abcdef),
    ]);

    let aux = Felt::new(0);
    let note_type_felt = Felt::new(1); // Public

    // Note inputs: 11 Felts
    // [0-3]: withdraw asset (amount, 0, faucet_suffix, faucet_prefix)
    // [4-7]: serial_num
    // [8]: tag
    // [9]: aux
    // [10]: note_type
    let withdraw_request_note_inputs = vec![
        Felt::new(withdraw_amount),
        Felt::new(0),
        faucet.id().suffix(),
        faucet.id().prefix().as_felt(),
        p2id_output_note_serial_num[0],
        p2id_output_note_serial_num[1],
        p2id_output_note_serial_num[2],
        p2id_output_note_serial_num[3],
        p2id_tag_felt,
        aux,
        note_type_felt,
    ];

    let withdraw_request_note = create_testing_note_from_package(
        withdraw_request_note_package.clone(),
        sender.id(),
        NoteCreationConfig {
            inputs: withdraw_request_note_inputs,
            ..Default::default()
        },
    )?;

    builder.add_output_note(OutputNote::Full(withdraw_request_note.clone().into()));

    // =========================================================================
    // EXECUTE: Initialize, Deposit, Withdraw
    // =========================================================================
    let mut mock_chain = builder.build()?;

    // Initialize bank
    let init_program = init_tx_script_package.unwrap_program();
    let init_tx_script = TransactionScript::new((*init_program).clone());
    let init_tx_context = mock_chain
        .build_tx_context(bank_account.id(), &[], &[])?
        .tx_script(init_tx_script)
        .build()?;
    let executed_init = init_tx_context.execute().await?;
    bank_account.apply_delta(&executed_init.account_delta())?;
    mock_chain.add_pending_executed_transaction(&executed_init)?;
    mock_chain.prove_next_block()?;

    println!("Step 1: Bank initialized");

    // Process deposit
    let deposit_tx_context = mock_chain
        .build_tx_context(bank_account.id(), &[deposit_note.id()], &[])?
        .build()?;
    let executed_deposit = deposit_tx_context.execute().await?;
    bank_account.apply_delta(&executed_deposit.account_delta())?;
    mock_chain.add_pending_executed_transaction(&executed_deposit)?;
    mock_chain.prove_next_block()?;

    println!("Step 2: Deposited {} tokens", deposit_amount);

    // Process withdraw with expected P2ID output note
    let recipient = build_p2id_recipient(sender.id(), p2id_output_note_serial_num)?;
    let p2id_output_note_asset = FungibleAsset::new(faucet.id(), withdraw_amount)?;
    let p2id_output_note_assets = NoteAssets::new(vec![p2id_output_note_asset.into()])?;
    let p2id_output_note_metadata = NoteMetadata::new(
        bank_account.id(),
        NoteType::Public,
        p2id_tag,
        NoteExecutionHint::none(),
        aux,
    )?;
    let p2id_output_note = Note::new(
        p2id_output_note_assets,
        p2id_output_note_metadata,
        recipient,
    );

    let withdraw_tx_context = mock_chain
        .build_tx_context(bank_account.id(), &[withdraw_request_note.id()], &[])?
        .extend_expected_output_notes(vec![OutputNote::Full(p2id_output_note.into())])
        .build()?;
    let executed_withdraw = withdraw_tx_context.execute().await?;
    bank_account.apply_delta(&executed_withdraw.account_delta())?;
    mock_chain.add_pending_executed_transaction(&executed_withdraw)?;
    mock_chain.prove_next_block()?;

    println!("Step 3: Withdrew {} tokens", withdraw_amount);
    println!("\nPart 7 withdraw test passed!");

    Ok(())
}
```

Run the test from the project root:

```bash title=">_ Terminal"
cargo test --package integration part7_withdraw -- --nocapture
```

<details>
<summary>Expected output</summary>

```text
   Compiling integration v0.1.0 (/path/to/miden-bank/integration)
    Finished `test` profile [unoptimized + debuginfo] target(s)
     Running tests/part7_withdraw_test.rs

running 1 test
Step 1: Bank initialized
Step 2: Deposited 1000 tokens
Step 3: Withdrew 500 tokens

Part 7 withdraw test passed!
test test_withdraw_creates_p2id_note ... ok

test result: ok. 1 passed; 0 failed; 0 ignored
```

</details>

:::tip Troubleshooting
**"Insufficient balance for withdrawal"**: Make sure the deposit was processed before attempting withdrawal.

**"Missing expected output note"**: Verify the P2ID note parameters (tag, serial_num, etc.) match exactly.
:::

## What We've Built So Far

| Component | Status | Description |
|-----------|--------|-------------|
| `bank-account` | ✅ Complete | Full deposit AND withdraw logic |
| `deposit-note` | ✅ Complete | Note script for deposits |
| `withdraw-request-note` | ✅ Complete | Note script for withdrawals |
| `init-tx-script` | ✅ Complete | Transaction script for initialization |

## Complete Code for This Part

<details>
<summary>Click to see the complete withdraw-request-note code</summary>

```rust title="contracts/withdraw-request-note/src/lib.rs"
// Do not link against libstd (i.e. anything defined in `std::`)
#![no_std]
#![feature(alloc_error_handler)]

use miden::*;

// Import the bank account's generated bindings
use crate::bindings::miden::bank_account::bank_account;

/// Withdraw Request Note Script
///
/// When consumed by the Bank account, this note requests a withdrawal and
/// the bank creates a P2ID note to send assets back to the depositor.
///
/// # Note Inputs (11 Felts)
/// [0-3]: withdraw asset (amount, 0, faucet_suffix, faucet_prefix)
/// [4-7]: serial_num (random/unique per note)
/// [8]: tag (P2ID note tag for routing)
/// [9]: aux (auxiliary data)
/// [10]: note_type (1 = Public, 2 = Private)
#[note_script]
fn run(_arg: Word) {
    // The depositor is whoever created/sent this note
    let depositor = active_note::get_sender();

    // Get the inputs
    let inputs = active_note::get_inputs();

    // Asset: [amount, 0, faucet_suffix, faucet_prefix]
    let withdraw_asset = Asset::new(Word::from([inputs[0], inputs[1], inputs[2], inputs[3]]));

    // Serial number: full 4 Felts (random/unique per note)
    let serial_num = Word::from([inputs[4], inputs[5], inputs[6], inputs[7]]);

    // Tag: single Felt for P2ID note routing
    let tag = inputs[8];

    // Aux: auxiliary data for application-specific purposes
    let aux = inputs[9];

    // Note type: 1 = Public, 2 = Private
    let note_type = inputs[10];

    // Call the bank account to withdraw the assets
    bank_account::withdraw(depositor, withdraw_asset, serial_num, tag, aux, note_type);
}
```

</details>

## Key Takeaways

1. **`Recipient::compute()`** creates a cryptographic commitment from serial number, script root, and inputs
2. **`output_note::create()`** creates the note with tag, type, and recipient
3. **`output_note::add_asset()`** attaches assets to the created note
4. **P2ID pattern** uses a standard script with account ID as input
5. **Serial numbers** must be unique to prevent note replay
6. **Array ordering** - P2ID expects `[suffix, prefix, ...]` not `[prefix, suffix, ...]`
7. **Always validate before subtraction** to prevent underflow exploits

:::tip View Complete Source
See the complete implementation in the [miden-bank repository](https://github.com/keinberger/miden-bank).
:::

## Next Steps

Now that you've built all the components, let's see how they work together in [Part 8: Complete Flows](./08-complete-flows).
````

## File: docs/builder/develop/tutorials/rust-compiler/miden-bank/index.md
````markdown
---
sidebar_position: 4
title: "Building a Bank with Miden Rust"
description: "Learn Miden Rust compiler fundamentals by building a complete banking application with deposits, withdrawals, and asset management."
---

# Building a Bank with Miden Rust

Welcome to the **Miden Rust Compiler Tutorial**! This hands-on guide teaches you how to build smart contracts on Miden using Rust by walking through a complete banking application.

## What You'll Build

You'll create a **banking system** consisting of:

- **Bank Account Component**: A smart contract that manages depositor balances and vault operations
- **Deposit Note**: A note script that processes deposits into the bank
- **Withdraw Request Note**: A note script that requests withdrawals from the bank
- **Initialization Script**: A transaction script to deploy and initialize the bank

Each part ends with a **runnable MockChain test** that verifies what you built works correctly.

## Tutorial Structure

This tutorial is designed for hands-on learning. Each part builds on the previous one, and every part includes:

- **What You'll Build** - Clear objectives for the section
- **Step-by-step code** - Progressively building functionality
- **Try It section** - A MockChain test to verify your code works
- **Complete code** - Full code listing for reference

### Parts Overview

| Part | Topic | What You'll Build |
|------|-------|-------------------|
| **Part 0** | [Project Setup](./00-project-setup) | Create project with `miden new` |
| **Part 1** | [Account Components](./01-account-components) | Bank struct with storage |
| **Part 2** | [Constants & Constraints](./02-constants-constraints) | Business rules and validation |
| **Part 3** | [Asset Management](./03-asset-management) | Deposit logic with balance tracking |
| **Part 4** | [Note Scripts](./04-note-scripts) | Deposit note for receiving assets |
| **Part 5** | [Cross-Component Calls](./05-cross-component-calls) | How bindings enable calls |
| **Part 6** | [Transaction Scripts](./06-transaction-scripts) | Initialization script |
| **Part 7** | [Output Notes](./07-output-notes) | Withdraw with P2ID output |
| **Part 8** | [Complete Flows](./08-complete-flows) | End-to-end verification |

## Tutorial Cards

import DocCard from '@theme/DocCard';

<div className="row">
  <div className="col col--6">
    <DocCard
      item={{
        type: 'link',
        href: './00-project-setup',
        label: 'Part 0: Project Setup',
        description: 'Create your project with miden new and understand the workspace structure.',
      }}
    />
  </div>
  <div className="col col--6">
    <DocCard
      item={{
        type: 'link',
        href: './01-account-components',
        label: 'Part 1: Account Components',
        description: 'Learn #[component], Value storage, and StorageMap for managing state.',
      }}
    />
  </div>
</div>

<div className="row">
  <div className="col col--6">
    <DocCard
      item={{
        type: 'link',
        href: './02-constants-constraints',
        label: 'Part 2: Constants & Constraints',
        description: 'Define business rules with constants and validate with assertions.',
      }}
    />
  </div>
  <div className="col col--6">
    <DocCard
      item={{
        type: 'link',
        href: './03-asset-management',
        label: 'Part 3: Asset Management',
        description: 'Handle fungible assets with vault operations and balance tracking.',
      }}
    />
  </div>
</div>

<div className="row">
  <div className="col col--6">
    <DocCard
      item={{
        type: 'link',
        href: './04-note-scripts',
        label: 'Part 4: Note Scripts',
        description: 'Write scripts that execute when notes are consumed.',
      }}
    />
  </div>
  <div className="col col--6">
    <DocCard
      item={{
        type: 'link',
        href: './05-cross-component-calls',
        label: 'Part 5: Cross-Component Calls',
        description: 'Call account methods from note scripts via bindings.',
      }}
    />
  </div>
</div>

<div className="row">
  <div className="col col--6">
    <DocCard
      item={{
        type: 'link',
        href: './06-transaction-scripts',
        label: 'Part 6: Transaction Scripts',
        description: 'Write scripts for account initialization and owner operations.',
      }}
    />
  </div>
  <div className="col col--6">
    <DocCard
      item={{
        type: 'link',
        href: './07-output-notes',
        label: 'Part 7: Creating Output Notes',
        description: 'Create P2ID notes programmatically for withdrawals.',
      }}
    />
  </div>
</div>

<div className="row">
  <div className="col col--6">
    <DocCard
      item={{
        type: 'link',
        href: './08-complete-flows',
        label: 'Part 8: Complete Flows',
        description: 'Walk through end-to-end deposit and withdraw operations.',
      }}
    />
  </div>
</div>

## Prerequisites

Before starting this tutorial, ensure you have:

- Completed the [Quick Start guide](../../../quick-start/) (familiarity with `midenup`, `miden new`, basic tooling)
- Basic understanding of Miden concepts (accounts, notes, transactions)
- Rust programming experience

:::tip No Miden Rust Experience Required
This tutorial assumes no prior experience with the Miden Rust compiler. We'll explain each concept as we encounter it.
:::

## Concepts Covered

This tutorial covers the following Miden Rust compiler features:

| Concept               | Description                                                | Part |
| --------------------- | ---------------------------------------------------------- | ---- |
| `#[component]`        | Define account components with storage                     | 1 |
| Storage Types         | `Value` for single values, `StorageMap` for key-value data | 1 |
| Constants             | Define compile-time business rules                         | 2 |
| Assertions            | Validate conditions and handle errors                      | 2 |
| Asset Handling        | Add and remove assets from account vaults                  | 3 |
| `#[note_script]`      | Scripts that execute when notes are consumed               | 4 |
| Cross-Component Calls | Call account methods from note scripts                     | 5 |
| `#[tx_script]`        | Transaction scripts for account operations                 | 6 |
| Output Notes          | Create notes programmatically                              | 7 |

## Source Code Repository

The complete source code for this tutorial is available in the **[miden-bank repository](https://github.com/keinberger/miden-bank)**. You can clone it to follow along or reference the implementation:

```bash title=">_ Terminal"
git clone https://github.com/keinberger/miden-bank.git
cd miden-bank
```

## Supplementary Guides

These standalone guides complement the tutorial:

- **[Testing with MockChain](../../testing)** - Learn to test your contracts
- **[Debugging](../../debugging)** - Troubleshoot common issues
- **[Common Pitfalls](../../pitfalls)** - Avoid known gotchas

## Getting Help

If you get stuck during this tutorial:

- Check the [Miden Docs](https://docs.miden.xyz) for detailed technical references
- Join the [Build On Miden](https://t.me/BuildOnMiden) Telegram community for support
- Review the complete code in the [miden-bank repository](https://github.com/keinberger/miden-bank)

Ready to build your first Miden banking application? Let's get started with [Part 0: Project Setup](./00-project-setup)!
````

## File: docs/builder/develop/tutorials/rust-compiler/miden-bank/08-complete-flows.md
````markdown
---
sidebar_position: 8
title: "Part 8: Complete Flows"
description: "Walk through end-to-end deposit and withdrawal flows, understanding how all the pieces work together in the banking application."
---

# Part 8: Complete Flows

In this final section, we'll bring everything together and walk through the complete deposit and withdrawal flows, verifying that all the components work as a unified banking system.

## What You'll Build in This Part

By the end of this section, you will have:

- Understood the complete deposit flow from note creation to balance update
- Understood the complete withdraw flow including P2ID note creation
- **Verified the entire system works** with an end-to-end MockChain test
- Completed the Miden Bank tutorial! 🎉

## Building on Parts 0-7

You've built all the pieces. Now let's see them work together:

```text
┌────────────────────────────────────────────────────────────────┐
│                 COMPLETE BANK SYSTEM                           │
├────────────────────────────────────────────────────────────────┤
│                                                                 │
│   Components Built:                                             │
│   ┌─────────────────────────────────────────────────────────┐  │
│   │ bank-account    │ Storage + deposit() + withdraw()       │  │
│   ├─────────────────┼───────────────────────────────────────┤  │
│   │ deposit-note    │ Note script → bank_account::deposit()  │  │
│   ├─────────────────┼───────────────────────────────────────┤  │
│   │ withdraw-note   │ Note script → bank_account::withdraw() │  │
│   ├─────────────────┼───────────────────────────────────────┤  │
│   │ init-tx-script  │ Transaction script → initialize()      │  │
│   └─────────────────┴───────────────────────────────────────┘  │
│                                                                 │
│   Storage Layout:                                               │
│   ┌─────────────────────────────────────────────────────────┐  │
│   │ Slot 0: initialized │ Word: [1, 0, 0, 0] when ready     │  │
│   │ Slot 1: balances    │ Map: user_key → [balance, 0, 0, 0]│  │
│   └─────────────────────────────────────────────────────────┘  │
│                                                                 │
└────────────────────────────────────────────────────────────────┘
```

## The Complete Deposit Flow

Let's trace through exactly what happens when a user deposits tokens:

```text
┌─────────────────────────────────────────────────────────────────────┐
│                        DEPOSIT FLOW                                  │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  1. USER CREATES DEPOSIT NOTE                                        │
│     ┌──────────────────────┐                                        │
│     │ Deposit Note         │                                        │
│     │  sender: User        │                                        │
│     │  assets: [1000 tok]  │                                        │
│     │  script: deposit-note│                                        │
│     │  target: Bank        │                                        │
│     └──────────────────────┘                                        │
│              │                                                       │
│              ▼                                                       │
│  2. BANK CONSUMES NOTE (Transaction begins)                         │
│     ┌──────────────────────┐                                        │
│     │ Bank Account         │                                        │
│     │  vault += 1000 tokens│  ◀── Protocol adds assets to vault    │
│     └──────────────────────┘                                        │
│              │                                                       │
│              ▼                                                       │
│  3. NOTE SCRIPT EXECUTES                                            │
│     depositor = active_note::get_sender() → User's AccountId        │
│     assets = active_note::get_assets()    → [1000 tokens]           │
│     for asset in assets:                                            │
│         bank_account::deposit(depositor, asset)  ◀── Cross-component│
│              │                                                       │
│              ▼                                                       │
│  4. DEPOSIT METHOD RUNS (in bank-account context)                   │
│     ┌──────────────────────────────────────────┐                    │
│     │ require_initialized()     ✓ Passes       │                    │
│     │ amount <= MAX_DEPOSIT     ✓ 1000 <= 100k │                    │
│     │ native_account::add_asset() ← Confirm    │                    │
│     │ balances[User] += 1000    ← Update       │                    │
│     └──────────────────────────────────────────┘                    │
│              │                                                       │
│              ▼                                                       │
│  5. TRANSACTION COMPLETES                                           │
│     Bank storage: balances[User] = 1000                             │
│     Bank vault: +1000 tokens                                        │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

## The Complete Withdraw Flow

Now let's trace the withdrawal process:

```text
┌─────────────────────────────────────────────────────────────────────┐
│                       WITHDRAW FLOW                                  │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  1. USER CREATES WITHDRAW REQUEST NOTE                              │
│     ┌──────────────────────────────┐                                │
│     │ Withdraw Request Note        │                                │
│     │  sender: User                │                                │
│     │  inputs: [serial, tag,       │                                │
│     │           aux, note_type]    │                                │
│     │  assets: [withdraw amount]   │                                │
│     │  target: Bank                │                                │
│     └──────────────────────────────┘                                │
│              │                                                       │
│              ▼                                                       │
│  2. BANK CONSUMES REQUEST (Transaction begins)                      │
│     ┌──────────────────────────────┐                                │
│     │ Note script executes:        │                                │
│     │  sender = get_sender()       │                                │
│     │  inputs = get_inputs()       │                                │
│     │  asset = Asset from inputs   │                                │
│     │  bank_account::withdraw(...) │                                │
│     └──────────────────────────────┘                                │
│              │                                                       │
│              ▼                                                       │
│  3. WITHDRAW METHOD RUNS                                            │
│     ┌──────────────────────────────────────────────────────┐        │
│     │ require_initialized()                 ✓ Passes       │        │
│     │ current_balance = get_balance(User)   → 1000         │        │
│     │ VALIDATE: 1000 >= 400                 ✓ Passes       │  ◀ CRITICAL
│     │ balances[User] = 1000 - 400           → 600          │        │
│     │ create_p2id_note(...)                 → Output note  │        │
│     └──────────────────────────────────────────────────────┘        │
│              │                                                       │
│              ▼                                                       │
│  4. P2ID NOTE CREATED (inside create_p2id_note)                     │
│     ┌──────────────────────────────────────────────────────┐        │
│     │ script_root = p2id_note_root()        → MAST digest  │        │
│     │ recipient = Recipient::compute(                       │        │
│     │     serial_num, script_root,                          │        │
│     │     [user.suffix, user.prefix, 0, 0, 0, 0, 0, 0]     │        │
│     │ )                                                     │        │
│     │ note_idx = output_note::create(tag, aux, ...)         │        │
│     │ native_account::remove_asset(400 tokens)              │        │
│     │ output_note::add_asset(400 tokens, note_idx)          │        │
│     └──────────────────────────────────────────────────────┘        │
│              │                                                       │
│              ▼                                                       │
│  5. TRANSACTION COMPLETES                                           │
│     Bank storage: balances[User] = 600                              │
│     Bank vault: -400 tokens                                         │
│     Output: P2ID note with 400 tokens → User                        │
│              │                                                       │
│              ▼                                                       │
│  6. USER CONSUMES P2ID NOTE (separate transaction)                  │
│     User's wallet receives 400 tokens                               │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

## Try It: Complete End-to-End Test

Let's create a comprehensive test that exercises the entire bank system:

```rust title="integration/tests/part8_complete_flow_test.rs"
use integration::helpers::{
    build_project_in_dir, create_testing_account_from_package, create_testing_note_from_package,
    AccountCreationConfig, NoteCreationConfig,
};
use miden_client::{
    account::StorageMap,
    note::{Note, NoteAssets, NoteExecutionHint, NoteMetadata, NoteTag, NoteType},
    transaction::OutputNote,
    Felt, Word,
};
use miden_lib::note::utils::build_p2id_recipient;
use miden_objects::{
    account::AccountId,
    asset::{Asset, FungibleAsset},
    transaction::TransactionScript,
};
use miden_testing::{Auth, MockChain};
use std::{path::Path, sync::Arc};

/// Compute a P2ID note tag for a local account.
fn compute_p2id_tag_for_local_account(account_id: AccountId) -> NoteTag {
    const LOCAL_ANY_PREFIX: u32 = 0xC000_0000;
    const TAG_BITS: u8 = 14;

    let prefix_u64 = account_id.prefix().as_u64();
    let shifted = (prefix_u64 >> 34) as u32;
    let mask = u32::MAX << (30 - TAG_BITS);
    let account_bits = shifted & mask;
    let tag_value = LOCAL_ANY_PREFIX | account_bits;

    NoteTag::LocalAny(tag_value)
}

/// Complete end-to-end test of the Miden Bank
///
/// This test exercises:
/// 1. Bank initialization via transaction script
/// 2. Deposit via deposit-note
/// 3. Withdrawal via withdraw-request-note
/// 4. Balance verification at each step
#[tokio::test]
async fn test_complete_bank_flow() -> anyhow::Result<()> {
    println!("╔══════════════════════════════════════════════════════════════╗");
    println!("║            MIDEN BANK - COMPLETE FLOW TEST                   ║");
    println!("╚══════════════════════════════════════════════════════════════╝");

    // ═══════════════════════════════════════════════════════════════════
    // SETUP
    // ═══════════════════════════════════════════════════════════════════
    println!("\n📦 Setting up test environment...");

    let mut builder = MockChain::builder();

    let deposit_amount: u64 = 1000;
    let withdraw_amount: u64 = 400;

    // Create a faucet to mint test assets
    let faucet =
        builder.add_existing_basic_faucet(Auth::BasicAuth, "TEST", deposit_amount, Some(10))?;

    // Create note sender account (the depositor)
    let sender = builder.add_existing_wallet_with_assets(
        Auth::BasicAuth,
        [FungibleAsset::new(faucet.id(), deposit_amount)?.into()],
    )?;
    println!("   ✓ Faucet and sender wallet created");

    // Build all packages
    let bank_package = Arc::new(build_project_in_dir(
        Path::new("../contracts/bank-account"),
        true,
    )?);
    let deposit_note_package = Arc::new(build_project_in_dir(
        Path::new("../contracts/deposit-note"),
        true,
    )?);
    let init_tx_script_package = Arc::new(build_project_in_dir(
        Path::new("../contracts/init-tx-script"),
        true,
    )?);
    let withdraw_request_note_package = Arc::new(build_project_in_dir(
        Path::new("../contracts/withdraw-request-note"),
        true,
    )?);
    println!("   ✓ All packages built");

    // Create bank account with storage slots
    let bank_cfg = AccountCreationConfig {
        storage_slots: vec![
            miden_client::account::StorageSlot::Value(Word::default()),
            miden_client::account::StorageSlot::Map(StorageMap::with_entries([])?),
        ],
        ..Default::default()
    };
    let mut bank_account =
        create_testing_account_from_package(bank_package.clone(), bank_cfg).await?;
    println!("   ✓ Bank account created: {:?}", bank_account.id());

    // Create deposit note with assets
    let fungible_asset = FungibleAsset::new(faucet.id(), deposit_amount)?;
    let note_assets = NoteAssets::new(vec![Asset::Fungible(fungible_asset)])?;
    let deposit_note = create_testing_note_from_package(
        deposit_note_package.clone(),
        sender.id(),
        NoteCreationConfig {
            assets: note_assets,
            ..Default::default()
        },
    )?;

    // Craft withdraw request note with 11-Felt input layout
    let p2id_tag = compute_p2id_tag_for_local_account(sender.id());
    let p2id_tag_u32 = match p2id_tag {
        NoteTag::LocalAny(v) => v,
        _ => panic!("Expected LocalAny tag"),
    };
    let p2id_tag_felt = Felt::new(p2id_tag_u32 as u64);

    let p2id_output_note_serial_num = Word::from([
        Felt::new(0x1234567890abcdef),
        Felt::new(0xfedcba0987654321),
        Felt::new(0xdeadbeefcafebabe),
        Felt::new(0x0123456789abcdef),
    ]);

    let aux = Felt::new(0);
    let note_type_felt = Felt::new(1); // Public

    // Note inputs: 11 Felts
    // [0-3]: withdraw asset (amount, 0, faucet_suffix, faucet_prefix)
    // [4-7]: serial_num
    // [8]: tag
    // [9]: aux
    // [10]: note_type
    let withdraw_request_note_inputs = vec![
        Felt::new(withdraw_amount),
        Felt::new(0),
        faucet.id().suffix(),
        faucet.id().prefix().as_felt(),
        p2id_output_note_serial_num[0],
        p2id_output_note_serial_num[1],
        p2id_output_note_serial_num[2],
        p2id_output_note_serial_num[3],
        p2id_tag_felt,
        aux,
        note_type_felt,
    ];

    let withdraw_request_note = create_testing_note_from_package(
        withdraw_request_note_package.clone(),
        sender.id(),
        NoteCreationConfig {
            inputs: withdraw_request_note_inputs,
            ..Default::default()
        },
    )?;

    // Add to builder
    builder.add_account(bank_account.clone())?;
    builder.add_output_note(OutputNote::Full(deposit_note.clone().into()));
    builder.add_output_note(OutputNote::Full(withdraw_request_note.clone().into()));

    let mut mock_chain = builder.build()?;
    println!("   ✓ MockChain built");

    // ═══════════════════════════════════════════════════════════════════
    // STEP 1: Initialize the bank
    // ═══════════════════════════════════════════════════════════════════
    println!("\n1️⃣  INITIALIZING BANK...");

    let init_program = init_tx_script_package.unwrap_program();
    let init_tx_script = TransactionScript::new((*init_program).clone());

    let init_tx_context = mock_chain
        .build_tx_context(bank_account.id(), &[], &[])?
        .tx_script(init_tx_script)
        .build()?;

    let executed_init = init_tx_context.execute().await?;
    bank_account.apply_delta(&executed_init.account_delta())?;
    mock_chain.add_pending_executed_transaction(&executed_init)?;
    mock_chain.prove_next_block()?;

    println!("   ✓ Bank initialized (storage[0] = [1, 0, 0, 0])");

    // ═══════════════════════════════════════════════════════════════════
    // STEP 2: Deposit tokens
    // ═══════════════════════════════════════════════════════════════════
    println!("\n2️⃣  DEPOSITING TOKENS...");
    println!("   Deposit amount: {} tokens", deposit_amount);

    let deposit_tx_context = mock_chain
        .build_tx_context(bank_account.id(), &[deposit_note.id()], &[])?
        .build()?;

    let executed_deposit = deposit_tx_context.execute().await?;
    bank_account.apply_delta(&executed_deposit.account_delta())?;
    mock_chain.add_pending_executed_transaction(&executed_deposit)?;
    mock_chain.prove_next_block()?;

    // Verify balance after deposit
    let depositor_key = Word::from([
        sender.id().prefix().as_felt(),
        sender.id().suffix(),
        faucet.id().prefix().as_felt(),
        faucet.id().suffix(),
    ]);
    let balance_after_deposit = bank_account.storage().get_map_item(1, depositor_key)?;
    println!(
        "   ✓ Bank processed deposit, balance: {} tokens",
        balance_after_deposit[3].as_int()
    );

    // ═══════════════════════════════════════════════════════════════════
    // STEP 3: Withdraw tokens
    // ═══════════════════════════════════════════════════════════════════
    println!("\n3️⃣  WITHDRAWING TOKENS...");
    println!("   Withdraw amount: {} tokens", withdraw_amount);

    // Build expected P2ID output note
    let recipient = build_p2id_recipient(sender.id(), p2id_output_note_serial_num)?;
    let p2id_output_note_asset = FungibleAsset::new(faucet.id(), withdraw_amount)?;
    let p2id_output_note_assets = NoteAssets::new(vec![p2id_output_note_asset.into()])?;
    let p2id_output_note_metadata = NoteMetadata::new(
        bank_account.id(),
        NoteType::Public,
        p2id_tag,
        NoteExecutionHint::none(),
        aux,
    )?;
    let p2id_output_note = Note::new(
        p2id_output_note_assets,
        p2id_output_note_metadata,
        recipient,
    );

    let withdraw_tx_context = mock_chain
        .build_tx_context(bank_account.id(), &[withdraw_request_note.id()], &[])?
        .extend_expected_output_notes(vec![OutputNote::Full(p2id_output_note.into())])
        .build()?;

    let executed_withdraw = withdraw_tx_context.execute().await?;
    bank_account.apply_delta(&executed_withdraw.account_delta())?;
    mock_chain.add_pending_executed_transaction(&executed_withdraw)?;
    mock_chain.prove_next_block()?;

    println!("   ✓ Bank processed withdraw request");
    println!("   ✓ P2ID output note created for sender");

    // Verify final balance
    let final_balance = bank_account.storage().get_map_item(1, depositor_key)?;
    let final_balance_amount = final_balance[3].as_int();
    let expected_final = deposit_amount - withdraw_amount;

    println!("   ✓ Final balance verified: {} tokens", final_balance_amount);

    // ═══════════════════════════════════════════════════════════════════
    // SUMMARY
    // ═══════════════════════════════════════════════════════════════════
    println!("\n╔══════════════════════════════════════════════════════════════╗");
    println!("║                      TEST SUMMARY                            ║");
    println!("╠══════════════════════════════════════════════════════════════╣");
    println!(
        "║  Initial deposit:     {:>6} tokens                          ║",
        deposit_amount
    );
    println!(
        "║  Withdrawal:         -{:>6} tokens                          ║",
        withdraw_amount
    );
    println!(
        "║  Final balance:       {:>6} tokens                          ║",
        final_balance_amount
    );
    println!("║                                                              ║");
    println!("║  ✅ All operations completed successfully!                   ║");
    println!("╚══════════════════════════════════════════════════════════════╝");

    assert_eq!(
        final_balance_amount, expected_final,
        "Final balance should be deposit - withdraw"
    );

    Ok(())
}
```

Run the complete test from the project root:

```bash title=">_ Terminal"
cargo test --package integration part8_complete_flow -- --nocapture
```

<details>
<summary>Expected output</summary>

```text
   Compiling integration v0.1.0 (/path/to/miden-bank/integration)
    Finished `test` profile [unoptimized + debuginfo] target(s)
     Running tests/part8_complete_flow_test.rs

running 1 test
╔══════════════════════════════════════════════════════════════╗
║            MIDEN BANK - COMPLETE FLOW TEST                   ║
╚══════════════════════════════════════════════════════════════╝

📦 Setting up test environment...
   ✓ Faucet and sender wallet created
   ✓ All packages built
   ✓ Bank account created: 0x...
   ✓ MockChain built

1️⃣  INITIALIZING BANK...
   ✓ Bank initialized (storage[0] = [1, 0, 0, 0])

2️⃣  DEPOSITING TOKENS...
   Deposit amount: 1000 tokens
   ✓ Bank processed deposit, balance: 1000 tokens

3️⃣  WITHDRAWING TOKENS...
   Withdraw amount: 400 tokens
   ✓ Bank processed withdraw request
   ✓ P2ID output note created for sender
   ✓ Final balance verified: 600 tokens

╔══════════════════════════════════════════════════════════════╗
║                      TEST SUMMARY                            ║
╠══════════════════════════════════════════════════════════════╣
║  Initial deposit:       1000 tokens                          ║
║  Withdrawal:         -   400 tokens                          ║
║  Final balance:          600 tokens                          ║
║                                                              ║
║  ✅ All operations completed successfully!                   ║
╚══════════════════════════════════════════════════════════════╝
test test_complete_bank_flow ... ok

test result: ok. 1 passed; 0 failed; 0 ignored
```

</details>

## Summary: All Components

Here's the complete picture of what you've built:

| Component | Type | Purpose |
|-----------|------|---------|
| `bank-account` | Account Component | Manages balances and vault |
| `deposit-note` | Note Script | Processes incoming deposits |
| `withdraw-request-note` | Note Script | Requests withdrawals |
| `init-tx-script` | Transaction Script | Initializes the bank |

| Storage Slot | Type | Content |
|--------------|------|---------|
| 0 | `Value` | Initialization flag |
| 1 | `StorageMap` | Depositor balances |

| API | Purpose |
|-----|---------|
| `active_note::get_sender()` | Identify note creator |
| `active_note::get_assets()` | Get attached assets |
| `active_note::get_inputs()` | Get note parameters |
| `native_account::add_asset()` | Receive into vault |
| `native_account::remove_asset()` | Send from vault |
| `output_note::create()` | Create output note |
| `output_note::add_asset()` | Attach assets to note |

## Key Security Patterns

Remember these critical patterns from this tutorial:

:::danger Always Validate Before Subtraction
```rust
// ❌ DANGEROUS: Silent underflow!
let new_balance = current_balance - withdraw_amount;

// ✅ SAFE: Validate first
assert!(
    current_balance.as_u64() >= withdraw_amount.as_u64(),
    "Insufficient balance"
);
let new_balance = Felt::from_u64_unchecked(
    current_balance.as_u64() - withdraw_amount.as_u64()
);
```
:::

:::warning Felt Comparison Operators
Never use `<`, `>` on Felt values directly. Always convert to u64 first:
```rust
// ❌ BROKEN: Produces incorrect results
if current_balance < withdraw_amount { ... }

// ✅ CORRECT: Use as_u64()
if current_balance.as_u64() < withdraw_amount.as_u64() { ... }
```
:::

## Congratulations! 🎉

You've completed the Miden Bank tutorial! You now understand:

- ✅ **Account components** with storage (`Value` and `StorageMap`)
- ✅ **Constants and constraints** for business rules
- ✅ **Asset management** with vault operations
- ✅ **Note scripts** for processing incoming notes
- ✅ **Cross-component calls** via generated bindings
- ✅ **Transaction scripts** for owner operations
- ✅ **Output notes** for sending assets (P2ID pattern)
- ✅ **Security patterns** for safe arithmetic

### Continue Learning

- **[Testing with MockChain](../testing)** - Deep dive into testing patterns
- **[Debugging Guide](../debugging)** - Troubleshoot common issues
- **[Common Pitfalls](../pitfalls)** - Avoid known gotchas

### Build More

Use these patterns to build:
- Token faucets
- DEX contracts
- NFT marketplaces
- Multi-signature wallets
- And more!

:::tip View Complete Source
Explore the complete banking application:
- [All Contracts](https://github.com/keinberger/miden-bank/tree/main/contracts)
- [Integration Tests](https://github.com/keinberger/miden-bank/tree/main/integration/tests)
- [Test Helpers](https://github.com/keinberger/miden-bank/blob/main/integration/src/helpers.rs)
:::

Happy building on Miden! 🚀
````

## File: docs/builder/index.md
````markdown
---
sidebar_label: Introduction
sidebar_position: 0
---

# Miden Documentation

![Miden Docs Background](/img/docs-background.png)

Miden is a zero-knowledge rollup for high-throughput, private applications. Build payments, DeFi, and asset management apps secured by Ethereum and Agglayer.

:::note
Miden is currently on **v0.13** – approaching mainnet readiness for the 2026 launch. Breaking changes may still occur in some components.
:::

### Why Miden?

- **Privacy by default** – Accounts and notes are private, with the network only storing cryptographic commitments
- **Client-side execution** – Transactions are executed and proven locally, enabling parallel processing and lower fees
- **Programmable everything** – Accounts are smart contracts, and notes can contain arbitrary logic
- **Ethereum security** – Settled on Ethereum with validity proofs via the Agglayer

### Key Concepts

- **Accounts** – Smart contracts that hold assets and execute custom logic
- **Notes** – Programmable messages that transfer assets between accounts
- **Transactions** – State changes proven locally using zero-knowledge proofs

import DocCard from '@theme/DocCard';

## Getting Started

<div className="row">
  <div className="col col--6">
    <DocCard
      item={{
        type: 'link',
        href: './quick-start',
        label: 'Quick Start',
        description: 'Install Miden tools, create your first wallet, and build your first transaction.',
      }}
    />
  </div>
  <div className="col col--6">
    <DocCard
      item={{
        type: 'link',
        href: './quick-start/setup/installation',
        label: 'Installation',
        description: 'Set up your development environment with the midenup toolchain.',
      }}
    />
  </div>
</div>

## Build on Miden

<div className="row">
  <div className="col col--6">
    <DocCard
      item={{
        type: 'link',
        href: './develop',
        label: 'Tutorials',
        description: 'Step-by-step guides for building applications on Miden.',
      }}
    />
  </div>
  <div className="col col--6">
    <DocCard
      item={{
        type: 'link',
        href: './tools',
        label: 'Tools',
        description: 'Miden Client libraries, CLI, and developer tooling.',
      }}
    />
  </div>
</div>

<div className="row">
  <div className="col col--6">
    <DocCard
      item={{
        type: 'link',
        href: './migration',
        label: 'Migration',
        description: 'Upgrade guides for migrating between Miden versions.',
      }}
    />
  </div>
</div>

## Resources

<div className="row">
  <div className="col col--6">
    <DocCard
      item={{
        type: 'link',
        href: './faq',
        label: 'FAQ',
        description: 'Frequently asked questions about Miden.',
      }}
    />
  </div>
  <div className="col col--6">
    <DocCard
      item={{
        type: 'link',
        href: './glossary',
        label: 'Glossary',
        description: 'Key terms and definitions used in Miden.',
      }}
    />
  </div>
</div>

### Community

- [Telegram](https://t.me/BuildOnMiden) – Join the technical discussion
- [GitHub](https://github.com/0xMiden) – Explore the source code
- [Roadmap](https://miden.xyz/roadmap) – See what's coming next

---

Licensed under the [MIT License](http://opensource.org/licenses/MIT).
````

## File: docs/design/index.md
````markdown
---
sidebar_label: Introduction
sidebar_position: 0
---

<!--
ARCHITECTURE NOTE:
This landing page is the ONLY Design content in docs/.
Full Design documentation (Protocol, VM, Compiler, Node) lives in versioned_docs/
and is populated by ingestion from external source repositories.
DO NOT add protocol documentation files here.
-->

# Miden Design

This section provides a comprehensive technical reference for the Miden architecture, covering the protocol design, virtual machine, compiler toolchain, and node infrastructure.

:::info Version Note
Full Design documentation is available in **released versions only**. Please select a version from the dropdown (e.g., 0.12, 0.11) to access the complete documentation.
:::

## Architecture Overview

Miden is a zero-knowledge rollup that fundamentally rethinks blockchain architecture. Instead of a single global state updated sequentially, Miden uses an **actor model** where each account is an independent state machine that executes transactions locally and generates validity proofs.

### Core Design Principles

| Principle | How Miden Achieves It |
|-----------|----------------------|
| **Privacy** | Accounts and notes store only cryptographic commitments on-chain; full data remains with users |
| **Parallelism** | Single-account transactions enable concurrent execution without contention |
| **Scalability** | Client-side proving offloads computation; proof aggregation reduces on-chain verification |
| **Programmability** | Turing-complete VM supports arbitrary smart contract logic in accounts and notes |


1. **Local Execution** – Users execute transactions on their devices, consuming input notes and updating account state
2. **Proof Generation** – The client generates a STARK proof attesting to valid state transitions
3. **Note Creation** – Transactions produce output notes carrying assets and data to recipients
4. **Verification** – The node verifies proofs, updates state commitments, and makes notes available

---

## Protocol (miden-base)

The protocol layer defines Miden's data structures, state model, and transaction semantics.

### Accounts

Accounts are programmable entities that hold assets and execute code:

- **ID** – Unique 64-bit identifier derived from initial code and storage
- **Code** – Immutable smart contract logic defining the account's interface
- **Storage** – Key-value store with up to 256 slots for persistent data
- **Vault** – Container holding fungible and non-fungible assets
- **Nonce** – Monotonically increasing counter preventing replay attacks

Account code is composed from **components** – modular building blocks that add capabilities like wallet functionality, token standards, or custom logic.

### Notes

Notes are programmable messages that transfer assets between accounts:

- **Script** – Code executed when the note is consumed
- **Inputs** – Public data available to the consuming transaction
- **Assets** – Tokens transferred to the recipient
- **Metadata** – Sender, tag (for discovery), and auxiliary data

Notes can be **public** (all data on-chain) or **private** (only a commitment stored). Private notes require off-chain communication between sender and recipient.

### State Model

Miden maintains three core databases:

| Database | Structure | Purpose |
|----------|-----------|---------|
| **Accounts** | Sparse Merkle Tree | Maps account IDs to state commitments |
| **Notes** | Merkle Mountain Range | Append-only log of created notes |
| **Nullifiers** | Sparse Merkle Tree | Tracks consumed notes to prevent double-spending |

This separation enables efficient state proofs and supports both public and private modes for accounts and notes.

### Transactions

Transactions are single-account operations that:

1. Consume zero or more input notes
2. Execute account code and optionally a transaction script
3. Update account state (storage, vault, nonce)
4. Produce zero or more output notes

The single-account model means transactions don't contend for shared state, enabling **parallel execution** across the network.

---

## Virtual Machine (miden-vm)

The Miden VM is a STARK-based virtual machine optimized for zero-knowledge proof generation.

### Architecture

- **Stack-based** – Operates on a push-down stack of 64-bit prime field elements
- **Turing-complete** – Supports loops, conditionals, and recursive procedures
- **Deterministic** – Same inputs always produce same outputs (with controlled nondeterminism for advice)

### Core Components

| Component | Function |
|-----------|----------|
| **Decoder** | Fetches and decodes instructions, manages control flow |
| **Stack** | 16 directly accessible elements, unlimited depth via memory |
| **Memory** | Random-access read/write storage |
| **Chiplets** | Specialized circuits for cryptographic and bitwise operations |

### Chiplets

Chiplets are co-processors that accelerate common operations:

- **Hash Chiplet** – Rescue Prime Optimized hashing, Merkle tree operations
- **Bitwise Chiplet** – AND, XOR, and other bitwise operations on 32-bit integers
- **Memory Chiplet** – Efficient random-access memory with read/write tracking
- **Kernel ROM** – Secure execution of privileged kernel procedures

### Miden Assembly (MASM)

MASM is the native instruction set with:

- **Field operations** – Arithmetic on prime field elements
- **U32 operations** – 32-bit integer arithmetic, bitwise, and comparison
- **Cryptographic operations** – Hashing, Merkle proofs, signature verification
- **Control flow** – Conditionals, loops, and procedure calls
- **Memory operations** – Load/store to local and global memory

---

## Compiler

The compiler toolchain enables writing Miden programs in high-level languages.

### Components

- **cargo-miden** – Cargo extension for building Miden projects
- **midenc** – Core compiler from WebAssembly to Miden Assembly
- **Debugger** – Interactive debugging with breakpoints and state inspection

### Compilation Pipeline

```
   Rust       →    WebAssembly    →    Miden IR    →    MASM
 (source)         (Wasm binary)      (compiler IR)    (assembly)
```

The compiler supports:

- **Account components** – Reusable smart contract modules
- **Note scripts** – Logic executed when notes are consumed
- **Transaction scripts** – Custom transaction execution logic

---

## Node (miden-node)

The node is the network infrastructure that receives transactions and produces blocks.

### Responsibilities

- Receive and validate proven transactions via gRPC
- Aggregate transaction proofs into batches
- Produce blocks with aggregated proofs
- Maintain state databases and serve sync requests

### gRPC API

The node exposes endpoints for:

- **Account queries** – Get account details, proofs, and storage
- **Note queries** – Retrieve notes by ID or script
- **Block queries** – Fetch block headers and contents
- **Sync operations** – Synchronize client state with the network
- **Transaction submission** – Submit proven transactions

---

## Further Reading

- **[Build Documentation](../builder/)** – Practical guides for building on Miden
- **[Quick Start](../builder/quick-start/)** – Get started with your first transaction
- **[FAQ](../builder/faq)** – Common questions answered
````
